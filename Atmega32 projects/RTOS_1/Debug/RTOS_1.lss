
RTOS_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000390e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000040  00800060  0000390e  000039a2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e5  008000a0  008000a0  000039e2  2**0
                  ALLOC
  3 .stab         00004bf0  00000000  00000000  000039e4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002b19  00000000  00000000  000085d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0000b0ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000b22d  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000b39d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  0000cfe6  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  0000ded1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  0000ec80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  0000ede0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0000f06d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000f83b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 99 10 	jmp	0x2132	; 0x2132 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e0       	ldi	r30, 0x0E	; 14
      68:	f9 e3       	ldi	r31, 0x39	; 57
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a0 3a       	cpi	r26, 0xA0	; 160
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	13 e0       	ldi	r17, 0x03	; 3
      78:	a0 ea       	ldi	r26, 0xA0	; 160
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a5 38       	cpi	r26, 0x85	; 133
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 a3 05 	call	0xb46	; 0xb46 <main>
      8a:	0c 94 85 1c 	jmp	0x390a	; 0x390a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 2f 1c 	jmp	0x385e	; 0x385e <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a5 e9       	ldi	r26, 0x95	; 149
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 4b 1c 	jmp	0x3896	; 0x3896 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 2f 1c 	jmp	0x385e	; 0x385e <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	85 e9       	ldi	r24, 0x95	; 149
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 4b 1c 	jmp	0x3896	; 0x3896 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 3b 1c 	jmp	0x3876	; 0x3876 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 3f 1c 	jmp	0x387e	; 0x387e <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 5b 1c 	jmp	0x38b6	; 0x38b6 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <main>:
/*tasks codes prototypes */
static void task1_code(void*pvParamter);
static void task2_code(void*pvParamter);

int main(void)
{
     b46:	af 92       	push	r10
     b48:	bf 92       	push	r11
     b4a:	cf 92       	push	r12
     b4c:	df 92       	push	r13
     b4e:	ef 92       	push	r14
     b50:	ff 92       	push	r15
     b52:	0f 93       	push	r16
     b54:	df 93       	push	r29
     b56:	cf 93       	push	r28
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62

	/*initialize LCD*/
	lcd_init();	
     b5c:	0e 94 5d 0b 	call	0x16ba	; 0x16ba <lcd_init>
	/*Creat tasks*/
	xTaskCreate(task1_code,(const signed char *)"task1",configMINIMAL_STACK_SIZE,NULL,TASK1_PRIORITY,NULL);
     b60:	20 e6       	ldi	r18, 0x60	; 96
     b62:	30 e0       	ldi	r19, 0x00	; 0
     b64:	82 ee       	ldi	r24, 0xE2	; 226
     b66:	95 e0       	ldi	r25, 0x05	; 5
     b68:	b9 01       	movw	r22, r18
     b6a:	45 e5       	ldi	r20, 0x55	; 85
     b6c:	50 e0       	ldi	r21, 0x00	; 0
     b6e:	20 e0       	ldi	r18, 0x00	; 0
     b70:	30 e0       	ldi	r19, 0x00	; 0
     b72:	01 e0       	ldi	r16, 0x01	; 1
     b74:	ee 24       	eor	r14, r14
     b76:	ff 24       	eor	r15, r15
     b78:	cc 24       	eor	r12, r12
     b7a:	dd 24       	eor	r13, r13
     b7c:	aa 24       	eor	r10, r10
     b7e:	bb 24       	eor	r11, r11
     b80:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <xTaskGenericCreate>
	xTaskCreate(task2_code,(const signed char *)"task2",configMINIMAL_STACK_SIZE,NULL,TASK2_PRIORITY,NULL);
     b84:	26 e6       	ldi	r18, 0x66	; 102
     b86:	30 e0       	ldi	r19, 0x00	; 0
     b88:	8a e7       	ldi	r24, 0x7A	; 122
     b8a:	96 e0       	ldi	r25, 0x06	; 6
     b8c:	b9 01       	movw	r22, r18
     b8e:	45 e5       	ldi	r20, 0x55	; 85
     b90:	50 e0       	ldi	r21, 0x00	; 0
     b92:	20 e0       	ldi	r18, 0x00	; 0
     b94:	30 e0       	ldi	r19, 0x00	; 0
     b96:	02 e0       	ldi	r16, 0x02	; 2
     b98:	ee 24       	eor	r14, r14
     b9a:	ff 24       	eor	r15, r15
     b9c:	cc 24       	eor	r12, r12
     b9e:	dd 24       	eor	r13, r13
     ba0:	aa 24       	eor	r10, r10
     ba2:	bb 24       	eor	r11, r11
     ba4:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <xTaskGenericCreate>
	/*start Scheduler */
	vTaskStartScheduler();
     ba8:	0e 94 16 17 	call	0x2e2c	; 0x2e2c <vTaskStartScheduler>
	

	return 0;
     bac:	80 e0       	ldi	r24, 0x00	; 0
     bae:	90 e0       	ldi	r25, 0x00	; 0
    
}
     bb0:	cf 91       	pop	r28
     bb2:	df 91       	pop	r29
     bb4:	0f 91       	pop	r16
     bb6:	ff 90       	pop	r15
     bb8:	ef 90       	pop	r14
     bba:	df 90       	pop	r13
     bbc:	cf 90       	pop	r12
     bbe:	bf 90       	pop	r11
     bc0:	af 90       	pop	r10
     bc2:	08 95       	ret

00000bc4 <task1_code>:

/*Task1 Code */
static void task1_code(void*pvParamter)
{
     bc4:	df 93       	push	r29
     bc6:	cf 93       	push	r28
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
     bcc:	61 97       	sbiw	r28, 0x11	; 17
     bce:	0f b6       	in	r0, 0x3f	; 63
     bd0:	f8 94       	cli
     bd2:	de bf       	out	0x3e, r29	; 62
     bd4:	0f be       	out	0x3f, r0	; 63
     bd6:	cd bf       	out	0x3d, r28	; 61
     bd8:	99 8b       	std	Y+17, r25	; 0x11
     bda:	88 8b       	std	Y+16, r24	; 0x10
    char counter=0;
     bdc:	1f 86       	std	Y+15, r1	; 0x0f
	for (;;)
	{
		counter = (counter+1)%10;
     bde:	8f 85       	ldd	r24, Y+15	; 0x0f
     be0:	88 2f       	mov	r24, r24
     be2:	90 e0       	ldi	r25, 0x00	; 0
     be4:	01 96       	adiw	r24, 0x01	; 1
     be6:	2a e0       	ldi	r18, 0x0A	; 10
     be8:	30 e0       	ldi	r19, 0x00	; 0
     bea:	b9 01       	movw	r22, r18
     bec:	0e 94 08 1c 	call	0x3810	; 0x3810 <__divmodhi4>
     bf0:	8f 87       	std	Y+15, r24	; 0x0f
		lcd_clrScreen();
     bf2:	0e 94 4a 0c 	call	0x1894	; 0x1894 <lcd_clrScreen>
		lcd_dispString("I am Task 1");
     bf6:	8c e6       	ldi	r24, 0x6C	; 108
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <lcd_dispString>
		
		lcd_displayChar((counter+'0'));
     bfe:	8f 85       	ldd	r24, Y+15	; 0x0f
     c00:	80 5d       	subi	r24, 0xD0	; 208
     c02:	0e 94 bc 0b 	call	0x1778	; 0x1778 <lcd_displayChar>
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	90 e0       	ldi	r25, 0x00	; 0
     c0a:	aa e7       	ldi	r26, 0x7A	; 122
     c0c:	b4 e4       	ldi	r27, 0x44	; 68
     c0e:	8b 87       	std	Y+11, r24	; 0x0b
     c10:	9c 87       	std	Y+12, r25	; 0x0c
     c12:	ad 87       	std	Y+13, r26	; 0x0d
     c14:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     c16:	6b 85       	ldd	r22, Y+11	; 0x0b
     c18:	7c 85       	ldd	r23, Y+12	; 0x0c
     c1a:	8d 85       	ldd	r24, Y+13	; 0x0d
     c1c:	9e 85       	ldd	r25, Y+14	; 0x0e
     c1e:	20 e0       	ldi	r18, 0x00	; 0
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	4a ef       	ldi	r20, 0xFA	; 250
     c24:	54 e4       	ldi	r21, 0x44	; 68
     c26:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c2a:	dc 01       	movw	r26, r24
     c2c:	cb 01       	movw	r24, r22
     c2e:	8f 83       	std	Y+7, r24	; 0x07
     c30:	98 87       	std	Y+8, r25	; 0x08
     c32:	a9 87       	std	Y+9, r26	; 0x09
     c34:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     c36:	6f 81       	ldd	r22, Y+7	; 0x07
     c38:	78 85       	ldd	r23, Y+8	; 0x08
     c3a:	89 85       	ldd	r24, Y+9	; 0x09
     c3c:	9a 85       	ldd	r25, Y+10	; 0x0a
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	30 e0       	ldi	r19, 0x00	; 0
     c42:	40 e8       	ldi	r20, 0x80	; 128
     c44:	5f e3       	ldi	r21, 0x3F	; 63
     c46:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     c4a:	88 23       	and	r24, r24
     c4c:	2c f4       	brge	.+10     	; 0xc58 <task1_code+0x94>
		__ticks = 1;
     c4e:	81 e0       	ldi	r24, 0x01	; 1
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	9e 83       	std	Y+6, r25	; 0x06
     c54:	8d 83       	std	Y+5, r24	; 0x05
     c56:	3f c0       	rjmp	.+126    	; 0xcd6 <task1_code+0x112>
	else if (__tmp > 65535)
     c58:	6f 81       	ldd	r22, Y+7	; 0x07
     c5a:	78 85       	ldd	r23, Y+8	; 0x08
     c5c:	89 85       	ldd	r24, Y+9	; 0x09
     c5e:	9a 85       	ldd	r25, Y+10	; 0x0a
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	3f ef       	ldi	r19, 0xFF	; 255
     c64:	4f e7       	ldi	r20, 0x7F	; 127
     c66:	57 e4       	ldi	r21, 0x47	; 71
     c68:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     c6c:	18 16       	cp	r1, r24
     c6e:	4c f5       	brge	.+82     	; 0xcc2 <task1_code+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     c70:	6b 85       	ldd	r22, Y+11	; 0x0b
     c72:	7c 85       	ldd	r23, Y+12	; 0x0c
     c74:	8d 85       	ldd	r24, Y+13	; 0x0d
     c76:	9e 85       	ldd	r25, Y+14	; 0x0e
     c78:	20 e0       	ldi	r18, 0x00	; 0
     c7a:	30 e0       	ldi	r19, 0x00	; 0
     c7c:	40 e2       	ldi	r20, 0x20	; 32
     c7e:	51 e4       	ldi	r21, 0x41	; 65
     c80:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c84:	dc 01       	movw	r26, r24
     c86:	cb 01       	movw	r24, r22
     c88:	bc 01       	movw	r22, r24
     c8a:	cd 01       	movw	r24, r26
     c8c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     c90:	dc 01       	movw	r26, r24
     c92:	cb 01       	movw	r24, r22
     c94:	9e 83       	std	Y+6, r25	; 0x06
     c96:	8d 83       	std	Y+5, r24	; 0x05
     c98:	0f c0       	rjmp	.+30     	; 0xcb8 <task1_code+0xf4>
     c9a:	88 ec       	ldi	r24, 0xC8	; 200
     c9c:	90 e0       	ldi	r25, 0x00	; 0
     c9e:	9c 83       	std	Y+4, r25	; 0x04
     ca0:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     ca2:	8b 81       	ldd	r24, Y+3	; 0x03
     ca4:	9c 81       	ldd	r25, Y+4	; 0x04
     ca6:	01 97       	sbiw	r24, 0x01	; 1
     ca8:	f1 f7       	brne	.-4      	; 0xca6 <task1_code+0xe2>
     caa:	9c 83       	std	Y+4, r25	; 0x04
     cac:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     cae:	8d 81       	ldd	r24, Y+5	; 0x05
     cb0:	9e 81       	ldd	r25, Y+6	; 0x06
     cb2:	01 97       	sbiw	r24, 0x01	; 1
     cb4:	9e 83       	std	Y+6, r25	; 0x06
     cb6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     cb8:	8d 81       	ldd	r24, Y+5	; 0x05
     cba:	9e 81       	ldd	r25, Y+6	; 0x06
     cbc:	00 97       	sbiw	r24, 0x00	; 0
     cbe:	69 f7       	brne	.-38     	; 0xc9a <task1_code+0xd6>
     cc0:	14 c0       	rjmp	.+40     	; 0xcea <task1_code+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     cc2:	6f 81       	ldd	r22, Y+7	; 0x07
     cc4:	78 85       	ldd	r23, Y+8	; 0x08
     cc6:	89 85       	ldd	r24, Y+9	; 0x09
     cc8:	9a 85       	ldd	r25, Y+10	; 0x0a
     cca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     cce:	dc 01       	movw	r26, r24
     cd0:	cb 01       	movw	r24, r22
     cd2:	9e 83       	std	Y+6, r25	; 0x06
     cd4:	8d 83       	std	Y+5, r24	; 0x05
     cd6:	8d 81       	ldd	r24, Y+5	; 0x05
     cd8:	9e 81       	ldd	r25, Y+6	; 0x06
     cda:	9a 83       	std	Y+2, r25	; 0x02
     cdc:	89 83       	std	Y+1, r24	; 0x01
     cde:	89 81       	ldd	r24, Y+1	; 0x01
     ce0:	9a 81       	ldd	r25, Y+2	; 0x02
     ce2:	01 97       	sbiw	r24, 0x01	; 1
     ce4:	f1 f7       	brne	.-4      	; 0xce2 <task1_code+0x11e>
     ce6:	9a 83       	std	Y+2, r25	; 0x02
     ce8:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(1000);
		vTaskDelay(500);
     cea:	84 ef       	ldi	r24, 0xF4	; 244
     cec:	91 e0       	ldi	r25, 0x01	; 1
     cee:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <vTaskDelay>
     cf2:	75 cf       	rjmp	.-278    	; 0xbde <task1_code+0x1a>

00000cf4 <task2_code>:
		
}

///*Task 2 Code*/
static void task2_code(void*pvParamter)
{
     cf4:	df 93       	push	r29
     cf6:	cf 93       	push	r28
     cf8:	cd b7       	in	r28, 0x3d	; 61
     cfa:	de b7       	in	r29, 0x3e	; 62
     cfc:	61 97       	sbiw	r28, 0x11	; 17
     cfe:	0f b6       	in	r0, 0x3f	; 63
     d00:	f8 94       	cli
     d02:	de bf       	out	0x3e, r29	; 62
     d04:	0f be       	out	0x3f, r0	; 63
     d06:	cd bf       	out	0x3d, r28	; 61
     d08:	99 8b       	std	Y+17, r25	; 0x11
     d0a:	88 8b       	std	Y+16, r24	; 0x10
	char x =3;
     d0c:	83 e0       	ldi	r24, 0x03	; 3
     d0e:	8f 87       	std	Y+15, r24	; 0x0f
	
	lcd_dispString("I am Task 3");
     d10:	88 e7       	ldi	r24, 0x78	; 120
     d12:	90 e0       	ldi	r25, 0x00	; 0
     d14:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <lcd_dispString>
	//vTaskDelay(2000);
	
	
		
		x++;
     d18:	8f 85       	ldd	r24, Y+15	; 0x0f
     d1a:	8f 5f       	subi	r24, 0xFF	; 255
     d1c:	8f 87       	std	Y+15, r24	; 0x0f
		//func();
		lcd_clrScreen();
     d1e:	0e 94 4a 0c 	call	0x1894	; 0x1894 <lcd_clrScreen>
		lcd_dispString("I am Task 2");
     d22:	84 e8       	ldi	r24, 0x84	; 132
     d24:	90 e0       	ldi	r25, 0x00	; 0
     d26:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <lcd_dispString>
     d2a:	80 e0       	ldi	r24, 0x00	; 0
     d2c:	90 e0       	ldi	r25, 0x00	; 0
     d2e:	aa e7       	ldi	r26, 0x7A	; 122
     d30:	b4 e4       	ldi	r27, 0x44	; 68
     d32:	8b 87       	std	Y+11, r24	; 0x0b
     d34:	9c 87       	std	Y+12, r25	; 0x0c
     d36:	ad 87       	std	Y+13, r26	; 0x0d
     d38:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     d3a:	6b 85       	ldd	r22, Y+11	; 0x0b
     d3c:	7c 85       	ldd	r23, Y+12	; 0x0c
     d3e:	8d 85       	ldd	r24, Y+13	; 0x0d
     d40:	9e 85       	ldd	r25, Y+14	; 0x0e
     d42:	20 e0       	ldi	r18, 0x00	; 0
     d44:	30 e0       	ldi	r19, 0x00	; 0
     d46:	4a ef       	ldi	r20, 0xFA	; 250
     d48:	54 e4       	ldi	r21, 0x44	; 68
     d4a:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d4e:	dc 01       	movw	r26, r24
     d50:	cb 01       	movw	r24, r22
     d52:	8f 83       	std	Y+7, r24	; 0x07
     d54:	98 87       	std	Y+8, r25	; 0x08
     d56:	a9 87       	std	Y+9, r26	; 0x09
     d58:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     d5a:	6f 81       	ldd	r22, Y+7	; 0x07
     d5c:	78 85       	ldd	r23, Y+8	; 0x08
     d5e:	89 85       	ldd	r24, Y+9	; 0x09
     d60:	9a 85       	ldd	r25, Y+10	; 0x0a
     d62:	20 e0       	ldi	r18, 0x00	; 0
     d64:	30 e0       	ldi	r19, 0x00	; 0
     d66:	40 e8       	ldi	r20, 0x80	; 128
     d68:	5f e3       	ldi	r21, 0x3F	; 63
     d6a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     d6e:	88 23       	and	r24, r24
     d70:	2c f4       	brge	.+10     	; 0xd7c <task2_code+0x88>
		__ticks = 1;
     d72:	81 e0       	ldi	r24, 0x01	; 1
     d74:	90 e0       	ldi	r25, 0x00	; 0
     d76:	9e 83       	std	Y+6, r25	; 0x06
     d78:	8d 83       	std	Y+5, r24	; 0x05
     d7a:	3f c0       	rjmp	.+126    	; 0xdfa <task2_code+0x106>
	else if (__tmp > 65535)
     d7c:	6f 81       	ldd	r22, Y+7	; 0x07
     d7e:	78 85       	ldd	r23, Y+8	; 0x08
     d80:	89 85       	ldd	r24, Y+9	; 0x09
     d82:	9a 85       	ldd	r25, Y+10	; 0x0a
     d84:	20 e0       	ldi	r18, 0x00	; 0
     d86:	3f ef       	ldi	r19, 0xFF	; 255
     d88:	4f e7       	ldi	r20, 0x7F	; 127
     d8a:	57 e4       	ldi	r21, 0x47	; 71
     d8c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     d90:	18 16       	cp	r1, r24
     d92:	4c f5       	brge	.+82     	; 0xde6 <task2_code+0xf2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     d94:	6b 85       	ldd	r22, Y+11	; 0x0b
     d96:	7c 85       	ldd	r23, Y+12	; 0x0c
     d98:	8d 85       	ldd	r24, Y+13	; 0x0d
     d9a:	9e 85       	ldd	r25, Y+14	; 0x0e
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	30 e0       	ldi	r19, 0x00	; 0
     da0:	40 e2       	ldi	r20, 0x20	; 32
     da2:	51 e4       	ldi	r21, 0x41	; 65
     da4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     da8:	dc 01       	movw	r26, r24
     daa:	cb 01       	movw	r24, r22
     dac:	bc 01       	movw	r22, r24
     dae:	cd 01       	movw	r24, r26
     db0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     db4:	dc 01       	movw	r26, r24
     db6:	cb 01       	movw	r24, r22
     db8:	9e 83       	std	Y+6, r25	; 0x06
     dba:	8d 83       	std	Y+5, r24	; 0x05
     dbc:	0f c0       	rjmp	.+30     	; 0xddc <task2_code+0xe8>
     dbe:	88 ec       	ldi	r24, 0xC8	; 200
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	9c 83       	std	Y+4, r25	; 0x04
     dc4:	8b 83       	std	Y+3, r24	; 0x03
     dc6:	8b 81       	ldd	r24, Y+3	; 0x03
     dc8:	9c 81       	ldd	r25, Y+4	; 0x04
     dca:	01 97       	sbiw	r24, 0x01	; 1
     dcc:	f1 f7       	brne	.-4      	; 0xdca <task2_code+0xd6>
     dce:	9c 83       	std	Y+4, r25	; 0x04
     dd0:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     dd2:	8d 81       	ldd	r24, Y+5	; 0x05
     dd4:	9e 81       	ldd	r25, Y+6	; 0x06
     dd6:	01 97       	sbiw	r24, 0x01	; 1
     dd8:	9e 83       	std	Y+6, r25	; 0x06
     dda:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     ddc:	8d 81       	ldd	r24, Y+5	; 0x05
     dde:	9e 81       	ldd	r25, Y+6	; 0x06
     de0:	00 97       	sbiw	r24, 0x00	; 0
     de2:	69 f7       	brne	.-38     	; 0xdbe <task2_code+0xca>
     de4:	14 c0       	rjmp	.+40     	; 0xe0e <task2_code+0x11a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     de6:	6f 81       	ldd	r22, Y+7	; 0x07
     de8:	78 85       	ldd	r23, Y+8	; 0x08
     dea:	89 85       	ldd	r24, Y+9	; 0x09
     dec:	9a 85       	ldd	r25, Y+10	; 0x0a
     dee:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     df2:	dc 01       	movw	r26, r24
     df4:	cb 01       	movw	r24, r22
     df6:	9e 83       	std	Y+6, r25	; 0x06
     df8:	8d 83       	std	Y+5, r24	; 0x05
     dfa:	8d 81       	ldd	r24, Y+5	; 0x05
     dfc:	9e 81       	ldd	r25, Y+6	; 0x06
     dfe:	9a 83       	std	Y+2, r25	; 0x02
     e00:	89 83       	std	Y+1, r24	; 0x01
     e02:	89 81       	ldd	r24, Y+1	; 0x01
     e04:	9a 81       	ldd	r25, Y+2	; 0x02
     e06:	01 97       	sbiw	r24, 0x01	; 1
     e08:	f1 f7       	brne	.-4      	; 0xe06 <task2_code+0x112>
     e0a:	9a 83       	std	Y+2, r25	; 0x02
     e0c:	89 83       	std	Y+1, r24	; 0x01
		_delay_ms(1000);
		vTaskDelay(2000);
     e0e:	80 ed       	ldi	r24, 0xD0	; 208
     e10:	97 e0       	ldi	r25, 0x07	; 7
     e12:	0e 94 e1 16 	call	0x2dc2	; 0x2dc2 <vTaskDelay>
	
}
     e16:	61 96       	adiw	r28, 0x11	; 17
     e18:	0f b6       	in	r0, 0x3f	; 63
     e1a:	f8 94       	cli
     e1c:	de bf       	out	0x3e, r29	; 62
     e1e:	0f be       	out	0x3f, r0	; 63
     e20:	cd bf       	out	0x3d, r28	; 61
     e22:	cf 91       	pop	r28
     e24:	df 91       	pop	r29
     e26:	08 95       	ret

00000e28 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     e28:	df 93       	push	r29
     e2a:	cf 93       	push	r28
     e2c:	cd b7       	in	r28, 0x3d	; 61
     e2e:	de b7       	in	r29, 0x3e	; 62
     e30:	27 97       	sbiw	r28, 0x07	; 7
     e32:	0f b6       	in	r0, 0x3f	; 63
     e34:	f8 94       	cli
     e36:	de bf       	out	0x3e, r29	; 62
     e38:	0f be       	out	0x3f, r0	; 63
     e3a:	cd bf       	out	0x3d, r28	; 61
     e3c:	9d 83       	std	Y+5, r25	; 0x05
     e3e:	8c 83       	std	Y+4, r24	; 0x04
     e40:	6e 83       	std	Y+6, r22	; 0x06
     e42:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     e44:	8a e1       	ldi	r24, 0x1A	; 26
     e46:	90 e0       	ldi	r25, 0x00	; 0
     e48:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <pvPortMalloc>
     e4c:	9a 83       	std	Y+2, r25	; 0x02
     e4e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     e50:	89 81       	ldd	r24, Y+1	; 0x01
     e52:	9a 81       	ldd	r25, Y+2	; 0x02
     e54:	00 97       	sbiw	r24, 0x00	; 0
     e56:	09 f4       	brne	.+2      	; 0xe5a <xCoRoutineCreate+0x32>
     e58:	6f c0       	rjmp	.+222    	; 0xf38 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     e5a:	80 91 a0 00 	lds	r24, 0x00A0
     e5e:	90 91 a1 00 	lds	r25, 0x00A1
     e62:	00 97       	sbiw	r24, 0x00	; 0
     e64:	41 f4       	brne	.+16     	; 0xe76 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     e66:	89 81       	ldd	r24, Y+1	; 0x01
     e68:	9a 81       	ldd	r25, Y+2	; 0x02
     e6a:	90 93 a1 00 	sts	0x00A1, r25
     e6e:	80 93 a0 00 	sts	0x00A0, r24
			prvInitialiseCoRoutineLists();
     e72:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     e76:	8e 81       	ldd	r24, Y+6	; 0x06
     e78:	82 30       	cpi	r24, 0x02	; 2
     e7a:	10 f0       	brcs	.+4      	; 0xe80 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     e7c:	81 e0       	ldi	r24, 0x01	; 1
     e7e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     e80:	e9 81       	ldd	r30, Y+1	; 0x01
     e82:	fa 81       	ldd	r31, Y+2	; 0x02
     e84:	11 8e       	std	Z+25, r1	; 0x19
     e86:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     e88:	e9 81       	ldd	r30, Y+1	; 0x01
     e8a:	fa 81       	ldd	r31, Y+2	; 0x02
     e8c:	8e 81       	ldd	r24, Y+6	; 0x06
     e8e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     e90:	e9 81       	ldd	r30, Y+1	; 0x01
     e92:	fa 81       	ldd	r31, Y+2	; 0x02
     e94:	8f 81       	ldd	r24, Y+7	; 0x07
     e96:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     e98:	e9 81       	ldd	r30, Y+1	; 0x01
     e9a:	fa 81       	ldd	r31, Y+2	; 0x02
     e9c:	8c 81       	ldd	r24, Y+4	; 0x04
     e9e:	9d 81       	ldd	r25, Y+5	; 0x05
     ea0:	91 83       	std	Z+1, r25	; 0x01
     ea2:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     ea4:	89 81       	ldd	r24, Y+1	; 0x01
     ea6:	9a 81       	ldd	r25, Y+2	; 0x02
     ea8:	02 96       	adiw	r24, 0x02	; 2
     eaa:	0e 94 b9 0c 	call	0x1972	; 0x1972 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     eae:	89 81       	ldd	r24, Y+1	; 0x01
     eb0:	9a 81       	ldd	r25, Y+2	; 0x02
     eb2:	0c 96       	adiw	r24, 0x0c	; 12
     eb4:	0e 94 b9 0c 	call	0x1972	; 0x1972 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     eb8:	e9 81       	ldd	r30, Y+1	; 0x01
     eba:	fa 81       	ldd	r31, Y+2	; 0x02
     ebc:	89 81       	ldd	r24, Y+1	; 0x01
     ebe:	9a 81       	ldd	r25, Y+2	; 0x02
     ec0:	91 87       	std	Z+9, r25	; 0x09
     ec2:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     ec4:	e9 81       	ldd	r30, Y+1	; 0x01
     ec6:	fa 81       	ldd	r31, Y+2	; 0x02
     ec8:	89 81       	ldd	r24, Y+1	; 0x01
     eca:	9a 81       	ldd	r25, Y+2	; 0x02
     ecc:	93 8b       	std	Z+19, r25	; 0x13
     ece:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     ed0:	8e 81       	ldd	r24, Y+6	; 0x06
     ed2:	28 2f       	mov	r18, r24
     ed4:	30 e0       	ldi	r19, 0x00	; 0
     ed6:	83 e0       	ldi	r24, 0x03	; 3
     ed8:	90 e0       	ldi	r25, 0x00	; 0
     eda:	82 1b       	sub	r24, r18
     edc:	93 0b       	sbc	r25, r19
     ede:	e9 81       	ldd	r30, Y+1	; 0x01
     ee0:	fa 81       	ldd	r31, Y+2	; 0x02
     ee2:	95 87       	std	Z+13, r25	; 0x0d
     ee4:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     ee6:	e9 81       	ldd	r30, Y+1	; 0x01
     ee8:	fa 81       	ldd	r31, Y+2	; 0x02
     eea:	96 89       	ldd	r25, Z+22	; 0x16
     eec:	80 91 a2 00 	lds	r24, 0x00A2
     ef0:	89 17       	cp	r24, r25
     ef2:	28 f4       	brcc	.+10     	; 0xefe <xCoRoutineCreate+0xd6>
     ef4:	e9 81       	ldd	r30, Y+1	; 0x01
     ef6:	fa 81       	ldd	r31, Y+2	; 0x02
     ef8:	86 89       	ldd	r24, Z+22	; 0x16
     efa:	80 93 a2 00 	sts	0x00A2, r24
     efe:	e9 81       	ldd	r30, Y+1	; 0x01
     f00:	fa 81       	ldd	r31, Y+2	; 0x02
     f02:	86 89       	ldd	r24, Z+22	; 0x16
     f04:	28 2f       	mov	r18, r24
     f06:	30 e0       	ldi	r19, 0x00	; 0
     f08:	c9 01       	movw	r24, r18
     f0a:	88 0f       	add	r24, r24
     f0c:	99 1f       	adc	r25, r25
     f0e:	88 0f       	add	r24, r24
     f10:	99 1f       	adc	r25, r25
     f12:	88 0f       	add	r24, r24
     f14:	99 1f       	adc	r25, r25
     f16:	82 0f       	add	r24, r18
     f18:	93 1f       	adc	r25, r19
     f1a:	ac 01       	movw	r20, r24
     f1c:	47 55       	subi	r20, 0x57	; 87
     f1e:	5f 4f       	sbci	r21, 0xFF	; 255
     f20:	89 81       	ldd	r24, Y+1	; 0x01
     f22:	9a 81       	ldd	r25, Y+2	; 0x02
     f24:	9c 01       	movw	r18, r24
     f26:	2e 5f       	subi	r18, 0xFE	; 254
     f28:	3f 4f       	sbci	r19, 0xFF	; 255
     f2a:	ca 01       	movw	r24, r20
     f2c:	b9 01       	movw	r22, r18
     f2e:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>

		xReturn = pdPASS;
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	8b 83       	std	Y+3, r24	; 0x03
     f36:	02 c0       	rjmp	.+4      	; 0xf3c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f38:	8f ef       	ldi	r24, 0xFF	; 255
     f3a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     f3c:	8b 81       	ldd	r24, Y+3	; 0x03
}
     f3e:	27 96       	adiw	r28, 0x07	; 7
     f40:	0f b6       	in	r0, 0x3f	; 63
     f42:	f8 94       	cli
     f44:	de bf       	out	0x3e, r29	; 62
     f46:	0f be       	out	0x3f, r0	; 63
     f48:	cd bf       	out	0x3d, r28	; 61
     f4a:	cf 91       	pop	r28
     f4c:	df 91       	pop	r29
     f4e:	08 95       	ret

00000f50 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     f50:	df 93       	push	r29
     f52:	cf 93       	push	r28
     f54:	00 d0       	rcall	.+0      	; 0xf56 <vCoRoutineAddToDelayedList+0x6>
     f56:	00 d0       	rcall	.+0      	; 0xf58 <vCoRoutineAddToDelayedList+0x8>
     f58:	00 d0       	rcall	.+0      	; 0xf5a <vCoRoutineAddToDelayedList+0xa>
     f5a:	cd b7       	in	r28, 0x3d	; 61
     f5c:	de b7       	in	r29, 0x3e	; 62
     f5e:	9c 83       	std	Y+4, r25	; 0x04
     f60:	8b 83       	std	Y+3, r24	; 0x03
     f62:	7e 83       	std	Y+6, r23	; 0x06
     f64:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     f66:	20 91 a3 00 	lds	r18, 0x00A3
     f6a:	30 91 a4 00 	lds	r19, 0x00A4
     f6e:	8b 81       	ldd	r24, Y+3	; 0x03
     f70:	9c 81       	ldd	r25, Y+4	; 0x04
     f72:	82 0f       	add	r24, r18
     f74:	93 1f       	adc	r25, r19
     f76:	9a 83       	std	Y+2, r25	; 0x02
     f78:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f7a:	80 91 a0 00 	lds	r24, 0x00A0
     f7e:	90 91 a1 00 	lds	r25, 0x00A1
     f82:	02 96       	adiw	r24, 0x02	; 2
     f84:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     f88:	e0 91 a0 00 	lds	r30, 0x00A0
     f8c:	f0 91 a1 00 	lds	r31, 0x00A1
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	9a 81       	ldd	r25, Y+2	; 0x02
     f94:	93 83       	std	Z+3, r25	; 0x03
     f96:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     f98:	20 91 a3 00 	lds	r18, 0x00A3
     f9c:	30 91 a4 00 	lds	r19, 0x00A4
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	9a 81       	ldd	r25, Y+2	; 0x02
     fa4:	82 17       	cp	r24, r18
     fa6:	93 07       	cpc	r25, r19
     fa8:	70 f4       	brcc	.+28     	; 0xfc6 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     faa:	80 91 cf 00 	lds	r24, 0x00CF
     fae:	90 91 d0 00 	lds	r25, 0x00D0
     fb2:	20 91 a0 00 	lds	r18, 0x00A0
     fb6:	30 91 a1 00 	lds	r19, 0x00A1
     fba:	2e 5f       	subi	r18, 0xFE	; 254
     fbc:	3f 4f       	sbci	r19, 0xFF	; 255
     fbe:	b9 01       	movw	r22, r18
     fc0:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>
     fc4:	0d c0       	rjmp	.+26     	; 0xfe0 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fc6:	80 91 cd 00 	lds	r24, 0x00CD
     fca:	90 91 ce 00 	lds	r25, 0x00CE
     fce:	20 91 a0 00 	lds	r18, 0x00A0
     fd2:	30 91 a1 00 	lds	r19, 0x00A1
     fd6:	2e 5f       	subi	r18, 0xFE	; 254
     fd8:	3f 4f       	sbci	r19, 0xFF	; 255
     fda:	b9 01       	movw	r22, r18
     fdc:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>
	}

	if( pxEventList )
     fe0:	8d 81       	ldd	r24, Y+5	; 0x05
     fe2:	9e 81       	ldd	r25, Y+6	; 0x06
     fe4:	00 97       	sbiw	r24, 0x00	; 0
     fe6:	61 f0       	breq	.+24     	; 0x1000 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     fe8:	80 91 a0 00 	lds	r24, 0x00A0
     fec:	90 91 a1 00 	lds	r25, 0x00A1
     ff0:	9c 01       	movw	r18, r24
     ff2:	24 5f       	subi	r18, 0xF4	; 244
     ff4:	3f 4f       	sbci	r19, 0xFF	; 255
     ff6:	8d 81       	ldd	r24, Y+5	; 0x05
     ff8:	9e 81       	ldd	r25, Y+6	; 0x06
     ffa:	b9 01       	movw	r22, r18
     ffc:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>
	}
}
    1000:	26 96       	adiw	r28, 0x06	; 6
    1002:	0f b6       	in	r0, 0x3f	; 63
    1004:	f8 94       	cli
    1006:	de bf       	out	0x3e, r29	; 62
    1008:	0f be       	out	0x3f, r0	; 63
    100a:	cd bf       	out	0x3d, r28	; 61
    100c:	cf 91       	pop	r28
    100e:	df 91       	pop	r29
    1010:	08 95       	ret

00001012 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1012:	df 93       	push	r29
    1014:	cf 93       	push	r28
    1016:	00 d0       	rcall	.+0      	; 0x1018 <prvCheckPendingReadyList+0x6>
    1018:	cd b7       	in	r28, 0x3d	; 61
    101a:	de b7       	in	r29, 0x3e	; 62
    101c:	3a c0       	rjmp	.+116    	; 0x1092 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    101e:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1020:	e0 91 d6 00 	lds	r30, 0x00D6
    1024:	f0 91 d7 00 	lds	r31, 0x00D7
    1028:	86 81       	ldd	r24, Z+6	; 0x06
    102a:	97 81       	ldd	r25, Z+7	; 0x07
    102c:	9a 83       	std	Y+2, r25	; 0x02
    102e:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1030:	89 81       	ldd	r24, Y+1	; 0x01
    1032:	9a 81       	ldd	r25, Y+2	; 0x02
    1034:	0c 96       	adiw	r24, 0x0c	; 12
    1036:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    103a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    103c:	89 81       	ldd	r24, Y+1	; 0x01
    103e:	9a 81       	ldd	r25, Y+2	; 0x02
    1040:	02 96       	adiw	r24, 0x02	; 2
    1042:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1046:	e9 81       	ldd	r30, Y+1	; 0x01
    1048:	fa 81       	ldd	r31, Y+2	; 0x02
    104a:	96 89       	ldd	r25, Z+22	; 0x16
    104c:	80 91 a2 00 	lds	r24, 0x00A2
    1050:	89 17       	cp	r24, r25
    1052:	28 f4       	brcc	.+10     	; 0x105e <prvCheckPendingReadyList+0x4c>
    1054:	e9 81       	ldd	r30, Y+1	; 0x01
    1056:	fa 81       	ldd	r31, Y+2	; 0x02
    1058:	86 89       	ldd	r24, Z+22	; 0x16
    105a:	80 93 a2 00 	sts	0x00A2, r24
    105e:	e9 81       	ldd	r30, Y+1	; 0x01
    1060:	fa 81       	ldd	r31, Y+2	; 0x02
    1062:	86 89       	ldd	r24, Z+22	; 0x16
    1064:	28 2f       	mov	r18, r24
    1066:	30 e0       	ldi	r19, 0x00	; 0
    1068:	c9 01       	movw	r24, r18
    106a:	88 0f       	add	r24, r24
    106c:	99 1f       	adc	r25, r25
    106e:	88 0f       	add	r24, r24
    1070:	99 1f       	adc	r25, r25
    1072:	88 0f       	add	r24, r24
    1074:	99 1f       	adc	r25, r25
    1076:	82 0f       	add	r24, r18
    1078:	93 1f       	adc	r25, r19
    107a:	ac 01       	movw	r20, r24
    107c:	47 55       	subi	r20, 0x57	; 87
    107e:	5f 4f       	sbci	r21, 0xFF	; 255
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	9a 81       	ldd	r25, Y+2	; 0x02
    1084:	9c 01       	movw	r18, r24
    1086:	2e 5f       	subi	r18, 0xFE	; 254
    1088:	3f 4f       	sbci	r19, 0xFF	; 255
    108a:	ca 01       	movw	r24, r20
    108c:	b9 01       	movw	r22, r18
    108e:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1092:	80 91 d1 00 	lds	r24, 0x00D1
    1096:	88 23       	and	r24, r24
    1098:	09 f0       	breq	.+2      	; 0x109c <prvCheckPendingReadyList+0x8a>
    109a:	c1 cf       	rjmp	.-126    	; 0x101e <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    109c:	0f 90       	pop	r0
    109e:	0f 90       	pop	r0
    10a0:	cf 91       	pop	r28
    10a2:	df 91       	pop	r29
    10a4:	08 95       	ret

000010a6 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    10a6:	df 93       	push	r29
    10a8:	cf 93       	push	r28
    10aa:	00 d0       	rcall	.+0      	; 0x10ac <prvCheckDelayedList+0x6>
    10ac:	00 d0       	rcall	.+0      	; 0x10ae <prvCheckDelayedList+0x8>
    10ae:	cd b7       	in	r28, 0x3d	; 61
    10b0:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    10b2:	0e 94 ef 17 	call	0x2fde	; 0x2fde <xTaskGetTickCount>
    10b6:	20 91 a5 00 	lds	r18, 0x00A5
    10ba:	30 91 a6 00 	lds	r19, 0x00A6
    10be:	82 1b       	sub	r24, r18
    10c0:	93 0b       	sbc	r25, r19
    10c2:	90 93 a8 00 	sts	0x00A8, r25
    10c6:	80 93 a7 00 	sts	0x00A7, r24
    10ca:	85 c0       	rjmp	.+266    	; 0x11d6 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    10cc:	80 91 a3 00 	lds	r24, 0x00A3
    10d0:	90 91 a4 00 	lds	r25, 0x00A4
    10d4:	01 96       	adiw	r24, 0x01	; 1
    10d6:	90 93 a4 00 	sts	0x00A4, r25
    10da:	80 93 a3 00 	sts	0x00A3, r24
		xPassedTicks--;
    10de:	80 91 a7 00 	lds	r24, 0x00A7
    10e2:	90 91 a8 00 	lds	r25, 0x00A8
    10e6:	01 97       	sbiw	r24, 0x01	; 1
    10e8:	90 93 a8 00 	sts	0x00A8, r25
    10ec:	80 93 a7 00 	sts	0x00A7, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    10f0:	80 91 a3 00 	lds	r24, 0x00A3
    10f4:	90 91 a4 00 	lds	r25, 0x00A4
    10f8:	00 97       	sbiw	r24, 0x00	; 0
    10fa:	09 f0       	breq	.+2      	; 0x10fe <prvCheckDelayedList+0x58>
    10fc:	64 c0       	rjmp	.+200    	; 0x11c6 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    10fe:	80 91 cd 00 	lds	r24, 0x00CD
    1102:	90 91 ce 00 	lds	r25, 0x00CE
    1106:	9a 83       	std	Y+2, r25	; 0x02
    1108:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    110a:	80 91 cf 00 	lds	r24, 0x00CF
    110e:	90 91 d0 00 	lds	r25, 0x00D0
    1112:	90 93 ce 00 	sts	0x00CE, r25
    1116:	80 93 cd 00 	sts	0x00CD, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    111a:	89 81       	ldd	r24, Y+1	; 0x01
    111c:	9a 81       	ldd	r25, Y+2	; 0x02
    111e:	90 93 d0 00 	sts	0x00D0, r25
    1122:	80 93 cf 00 	sts	0x00CF, r24
    1126:	4f c0       	rjmp	.+158    	; 0x11c6 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1128:	e0 91 cd 00 	lds	r30, 0x00CD
    112c:	f0 91 ce 00 	lds	r31, 0x00CE
    1130:	05 80       	ldd	r0, Z+5	; 0x05
    1132:	f6 81       	ldd	r31, Z+6	; 0x06
    1134:	e0 2d       	mov	r30, r0
    1136:	86 81       	ldd	r24, Z+6	; 0x06
    1138:	97 81       	ldd	r25, Z+7	; 0x07
    113a:	9c 83       	std	Y+4, r25	; 0x04
    113c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    113e:	eb 81       	ldd	r30, Y+3	; 0x03
    1140:	fc 81       	ldd	r31, Y+4	; 0x04
    1142:	22 81       	ldd	r18, Z+2	; 0x02
    1144:	33 81       	ldd	r19, Z+3	; 0x03
    1146:	80 91 a3 00 	lds	r24, 0x00A3
    114a:	90 91 a4 00 	lds	r25, 0x00A4
    114e:	82 17       	cp	r24, r18
    1150:	93 07       	cpc	r25, r19
    1152:	08 f4       	brcc	.+2      	; 0x1156 <prvCheckDelayedList+0xb0>
    1154:	40 c0       	rjmp	.+128    	; 0x11d6 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1156:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    1158:	8b 81       	ldd	r24, Y+3	; 0x03
    115a:	9c 81       	ldd	r25, Y+4	; 0x04
    115c:	02 96       	adiw	r24, 0x02	; 2
    115e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1162:	eb 81       	ldd	r30, Y+3	; 0x03
    1164:	fc 81       	ldd	r31, Y+4	; 0x04
    1166:	84 89       	ldd	r24, Z+20	; 0x14
    1168:	95 89       	ldd	r25, Z+21	; 0x15
    116a:	00 97       	sbiw	r24, 0x00	; 0
    116c:	29 f0       	breq	.+10     	; 0x1178 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    116e:	8b 81       	ldd	r24, Y+3	; 0x03
    1170:	9c 81       	ldd	r25, Y+4	; 0x04
    1172:	0c 96       	adiw	r24, 0x0c	; 12
    1174:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1178:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    117a:	eb 81       	ldd	r30, Y+3	; 0x03
    117c:	fc 81       	ldd	r31, Y+4	; 0x04
    117e:	96 89       	ldd	r25, Z+22	; 0x16
    1180:	80 91 a2 00 	lds	r24, 0x00A2
    1184:	89 17       	cp	r24, r25
    1186:	28 f4       	brcc	.+10     	; 0x1192 <prvCheckDelayedList+0xec>
    1188:	eb 81       	ldd	r30, Y+3	; 0x03
    118a:	fc 81       	ldd	r31, Y+4	; 0x04
    118c:	86 89       	ldd	r24, Z+22	; 0x16
    118e:	80 93 a2 00 	sts	0x00A2, r24
    1192:	eb 81       	ldd	r30, Y+3	; 0x03
    1194:	fc 81       	ldd	r31, Y+4	; 0x04
    1196:	86 89       	ldd	r24, Z+22	; 0x16
    1198:	28 2f       	mov	r18, r24
    119a:	30 e0       	ldi	r19, 0x00	; 0
    119c:	c9 01       	movw	r24, r18
    119e:	88 0f       	add	r24, r24
    11a0:	99 1f       	adc	r25, r25
    11a2:	88 0f       	add	r24, r24
    11a4:	99 1f       	adc	r25, r25
    11a6:	88 0f       	add	r24, r24
    11a8:	99 1f       	adc	r25, r25
    11aa:	82 0f       	add	r24, r18
    11ac:	93 1f       	adc	r25, r19
    11ae:	ac 01       	movw	r20, r24
    11b0:	47 55       	subi	r20, 0x57	; 87
    11b2:	5f 4f       	sbci	r21, 0xFF	; 255
    11b4:	8b 81       	ldd	r24, Y+3	; 0x03
    11b6:	9c 81       	ldd	r25, Y+4	; 0x04
    11b8:	9c 01       	movw	r18, r24
    11ba:	2e 5f       	subi	r18, 0xFE	; 254
    11bc:	3f 4f       	sbci	r19, 0xFF	; 255
    11be:	ca 01       	movw	r24, r20
    11c0:	b9 01       	movw	r22, r18
    11c2:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    11c6:	e0 91 cd 00 	lds	r30, 0x00CD
    11ca:	f0 91 ce 00 	lds	r31, 0x00CE
    11ce:	80 81       	ld	r24, Z
    11d0:	88 23       	and	r24, r24
    11d2:	09 f0       	breq	.+2      	; 0x11d6 <prvCheckDelayedList+0x130>
    11d4:	a9 cf       	rjmp	.-174    	; 0x1128 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    11d6:	80 91 a7 00 	lds	r24, 0x00A7
    11da:	90 91 a8 00 	lds	r25, 0x00A8
    11de:	00 97       	sbiw	r24, 0x00	; 0
    11e0:	09 f0       	breq	.+2      	; 0x11e4 <prvCheckDelayedList+0x13e>
    11e2:	74 cf       	rjmp	.-280    	; 0x10cc <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    11e4:	80 91 a3 00 	lds	r24, 0x00A3
    11e8:	90 91 a4 00 	lds	r25, 0x00A4
    11ec:	90 93 a6 00 	sts	0x00A6, r25
    11f0:	80 93 a5 00 	sts	0x00A5, r24
}
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	0f 90       	pop	r0
    11fa:	0f 90       	pop	r0
    11fc:	cf 91       	pop	r28
    11fe:	df 91       	pop	r29
    1200:	08 95       	ret

00001202 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1202:	df 93       	push	r29
    1204:	cf 93       	push	r28
    1206:	00 d0       	rcall	.+0      	; 0x1208 <vCoRoutineSchedule+0x6>
    1208:	cd b7       	in	r28, 0x3d	; 61
    120a:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    120c:	0e 94 09 08 	call	0x1012	; 0x1012 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1210:	0e 94 53 08 	call	0x10a6	; 0x10a6 <prvCheckDelayedList>
    1214:	0a c0       	rjmp	.+20     	; 0x122a <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1216:	80 91 a2 00 	lds	r24, 0x00A2
    121a:	88 23       	and	r24, r24
    121c:	09 f4       	brne	.+2      	; 0x1220 <vCoRoutineSchedule+0x1e>
    121e:	66 c0       	rjmp	.+204    	; 0x12ec <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1220:	80 91 a2 00 	lds	r24, 0x00A2
    1224:	81 50       	subi	r24, 0x01	; 1
    1226:	80 93 a2 00 	sts	0x00A2, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    122a:	80 91 a2 00 	lds	r24, 0x00A2
    122e:	28 2f       	mov	r18, r24
    1230:	30 e0       	ldi	r19, 0x00	; 0
    1232:	c9 01       	movw	r24, r18
    1234:	88 0f       	add	r24, r24
    1236:	99 1f       	adc	r25, r25
    1238:	88 0f       	add	r24, r24
    123a:	99 1f       	adc	r25, r25
    123c:	88 0f       	add	r24, r24
    123e:	99 1f       	adc	r25, r25
    1240:	82 0f       	add	r24, r18
    1242:	93 1f       	adc	r25, r19
    1244:	fc 01       	movw	r30, r24
    1246:	e7 55       	subi	r30, 0x57	; 87
    1248:	ff 4f       	sbci	r31, 0xFF	; 255
    124a:	80 81       	ld	r24, Z
    124c:	88 23       	and	r24, r24
    124e:	19 f3       	breq	.-58     	; 0x1216 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1250:	80 91 a2 00 	lds	r24, 0x00A2
    1254:	28 2f       	mov	r18, r24
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	c9 01       	movw	r24, r18
    125a:	88 0f       	add	r24, r24
    125c:	99 1f       	adc	r25, r25
    125e:	88 0f       	add	r24, r24
    1260:	99 1f       	adc	r25, r25
    1262:	88 0f       	add	r24, r24
    1264:	99 1f       	adc	r25, r25
    1266:	82 0f       	add	r24, r18
    1268:	93 1f       	adc	r25, r19
    126a:	87 55       	subi	r24, 0x57	; 87
    126c:	9f 4f       	sbci	r25, 0xFF	; 255
    126e:	9a 83       	std	Y+2, r25	; 0x02
    1270:	89 83       	std	Y+1, r24	; 0x01
    1272:	e9 81       	ldd	r30, Y+1	; 0x01
    1274:	fa 81       	ldd	r31, Y+2	; 0x02
    1276:	01 80       	ldd	r0, Z+1	; 0x01
    1278:	f2 81       	ldd	r31, Z+2	; 0x02
    127a:	e0 2d       	mov	r30, r0
    127c:	82 81       	ldd	r24, Z+2	; 0x02
    127e:	93 81       	ldd	r25, Z+3	; 0x03
    1280:	e9 81       	ldd	r30, Y+1	; 0x01
    1282:	fa 81       	ldd	r31, Y+2	; 0x02
    1284:	92 83       	std	Z+2, r25	; 0x02
    1286:	81 83       	std	Z+1, r24	; 0x01
    1288:	e9 81       	ldd	r30, Y+1	; 0x01
    128a:	fa 81       	ldd	r31, Y+2	; 0x02
    128c:	21 81       	ldd	r18, Z+1	; 0x01
    128e:	32 81       	ldd	r19, Z+2	; 0x02
    1290:	89 81       	ldd	r24, Y+1	; 0x01
    1292:	9a 81       	ldd	r25, Y+2	; 0x02
    1294:	03 96       	adiw	r24, 0x03	; 3
    1296:	28 17       	cp	r18, r24
    1298:	39 07       	cpc	r19, r25
    129a:	59 f4       	brne	.+22     	; 0x12b2 <vCoRoutineSchedule+0xb0>
    129c:	e9 81       	ldd	r30, Y+1	; 0x01
    129e:	fa 81       	ldd	r31, Y+2	; 0x02
    12a0:	01 80       	ldd	r0, Z+1	; 0x01
    12a2:	f2 81       	ldd	r31, Z+2	; 0x02
    12a4:	e0 2d       	mov	r30, r0
    12a6:	82 81       	ldd	r24, Z+2	; 0x02
    12a8:	93 81       	ldd	r25, Z+3	; 0x03
    12aa:	e9 81       	ldd	r30, Y+1	; 0x01
    12ac:	fa 81       	ldd	r31, Y+2	; 0x02
    12ae:	92 83       	std	Z+2, r25	; 0x02
    12b0:	81 83       	std	Z+1, r24	; 0x01
    12b2:	e9 81       	ldd	r30, Y+1	; 0x01
    12b4:	fa 81       	ldd	r31, Y+2	; 0x02
    12b6:	01 80       	ldd	r0, Z+1	; 0x01
    12b8:	f2 81       	ldd	r31, Z+2	; 0x02
    12ba:	e0 2d       	mov	r30, r0
    12bc:	86 81       	ldd	r24, Z+6	; 0x06
    12be:	97 81       	ldd	r25, Z+7	; 0x07
    12c0:	90 93 a1 00 	sts	0x00A1, r25
    12c4:	80 93 a0 00 	sts	0x00A0, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    12c8:	e0 91 a0 00 	lds	r30, 0x00A0
    12cc:	f0 91 a1 00 	lds	r31, 0x00A1
    12d0:	40 81       	ld	r20, Z
    12d2:	51 81       	ldd	r21, Z+1	; 0x01
    12d4:	80 91 a0 00 	lds	r24, 0x00A0
    12d8:	90 91 a1 00 	lds	r25, 0x00A1
    12dc:	e0 91 a0 00 	lds	r30, 0x00A0
    12e0:	f0 91 a1 00 	lds	r31, 0x00A1
    12e4:	27 89       	ldd	r18, Z+23	; 0x17
    12e6:	62 2f       	mov	r22, r18
    12e8:	fa 01       	movw	r30, r20
    12ea:	09 95       	icall

	return;
}
    12ec:	0f 90       	pop	r0
    12ee:	0f 90       	pop	r0
    12f0:	cf 91       	pop	r28
    12f2:	df 91       	pop	r29
    12f4:	08 95       	ret

000012f6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    12f6:	df 93       	push	r29
    12f8:	cf 93       	push	r28
    12fa:	0f 92       	push	r0
    12fc:	cd b7       	in	r28, 0x3d	; 61
    12fe:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1300:	19 82       	std	Y+1, r1	; 0x01
    1302:	13 c0       	rjmp	.+38     	; 0x132a <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1304:	89 81       	ldd	r24, Y+1	; 0x01
    1306:	28 2f       	mov	r18, r24
    1308:	30 e0       	ldi	r19, 0x00	; 0
    130a:	c9 01       	movw	r24, r18
    130c:	88 0f       	add	r24, r24
    130e:	99 1f       	adc	r25, r25
    1310:	88 0f       	add	r24, r24
    1312:	99 1f       	adc	r25, r25
    1314:	88 0f       	add	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	82 0f       	add	r24, r18
    131a:	93 1f       	adc	r25, r19
    131c:	87 55       	subi	r24, 0x57	; 87
    131e:	9f 4f       	sbci	r25, 0xFF	; 255
    1320:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1324:	89 81       	ldd	r24, Y+1	; 0x01
    1326:	8f 5f       	subi	r24, 0xFF	; 255
    1328:	89 83       	std	Y+1, r24	; 0x01
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	82 30       	cpi	r24, 0x02	; 2
    132e:	50 f3       	brcs	.-44     	; 0x1304 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1330:	8b eb       	ldi	r24, 0xBB	; 187
    1332:	90 e0       	ldi	r25, 0x00	; 0
    1334:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1338:	84 ec       	ldi	r24, 0xC4	; 196
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1340:	81 ed       	ldi	r24, 0xD1	; 209
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1348:	8b eb       	ldi	r24, 0xBB	; 187
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	90 93 ce 00 	sts	0x00CE, r25
    1350:	80 93 cd 00 	sts	0x00CD, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1354:	84 ec       	ldi	r24, 0xC4	; 196
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	90 93 d0 00 	sts	0x00D0, r25
    135c:	80 93 cf 00 	sts	0x00CF, r24
}
    1360:	0f 90       	pop	r0
    1362:	cf 91       	pop	r28
    1364:	df 91       	pop	r29
    1366:	08 95       	ret

00001368 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1368:	df 93       	push	r29
    136a:	cf 93       	push	r28
    136c:	00 d0       	rcall	.+0      	; 0x136e <xCoRoutineRemoveFromEventList+0x6>
    136e:	00 d0       	rcall	.+0      	; 0x1370 <xCoRoutineRemoveFromEventList+0x8>
    1370:	0f 92       	push	r0
    1372:	cd b7       	in	r28, 0x3d	; 61
    1374:	de b7       	in	r29, 0x3e	; 62
    1376:	9d 83       	std	Y+5, r25	; 0x05
    1378:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    137a:	ec 81       	ldd	r30, Y+4	; 0x04
    137c:	fd 81       	ldd	r31, Y+5	; 0x05
    137e:	05 80       	ldd	r0, Z+5	; 0x05
    1380:	f6 81       	ldd	r31, Z+6	; 0x06
    1382:	e0 2d       	mov	r30, r0
    1384:	86 81       	ldd	r24, Z+6	; 0x06
    1386:	97 81       	ldd	r25, Z+7	; 0x07
    1388:	9b 83       	std	Y+3, r25	; 0x03
    138a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    138c:	8a 81       	ldd	r24, Y+2	; 0x02
    138e:	9b 81       	ldd	r25, Y+3	; 0x03
    1390:	0c 96       	adiw	r24, 0x0c	; 12
    1392:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1396:	8a 81       	ldd	r24, Y+2	; 0x02
    1398:	9b 81       	ldd	r25, Y+3	; 0x03
    139a:	9c 01       	movw	r18, r24
    139c:	24 5f       	subi	r18, 0xF4	; 244
    139e:	3f 4f       	sbci	r19, 0xFF	; 255
    13a0:	81 ed       	ldi	r24, 0xD1	; 209
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	b9 01       	movw	r22, r18
    13a6:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    13aa:	ea 81       	ldd	r30, Y+2	; 0x02
    13ac:	fb 81       	ldd	r31, Y+3	; 0x03
    13ae:	96 89       	ldd	r25, Z+22	; 0x16
    13b0:	e0 91 a0 00 	lds	r30, 0x00A0
    13b4:	f0 91 a1 00 	lds	r31, 0x00A1
    13b8:	86 89       	ldd	r24, Z+22	; 0x16
    13ba:	98 17       	cp	r25, r24
    13bc:	18 f0       	brcs	.+6      	; 0x13c4 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    13be:	81 e0       	ldi	r24, 0x01	; 1
    13c0:	89 83       	std	Y+1, r24	; 0x01
    13c2:	01 c0       	rjmp	.+2      	; 0x13c6 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    13c4:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    13c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    13c8:	0f 90       	pop	r0
    13ca:	0f 90       	pop	r0
    13cc:	0f 90       	pop	r0
    13ce:	0f 90       	pop	r0
    13d0:	0f 90       	pop	r0
    13d2:	cf 91       	pop	r28
    13d4:	df 91       	pop	r29
    13d6:	08 95       	ret

000013d8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13d8:	df 93       	push	r29
    13da:	cf 93       	push	r28
    13dc:	00 d0       	rcall	.+0      	; 0x13de <pvPortMalloc+0x6>
    13de:	00 d0       	rcall	.+0      	; 0x13e0 <pvPortMalloc+0x8>
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	9c 83       	std	Y+4, r25	; 0x04
    13e6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    13e8:	1a 82       	std	Y+2, r1	; 0x02
    13ea:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    13ec:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    13f0:	80 91 da 00 	lds	r24, 0x00DA
    13f4:	90 91 db 00 	lds	r25, 0x00DB
    13f8:	2b 81       	ldd	r18, Y+3	; 0x03
    13fa:	3c 81       	ldd	r19, Y+4	; 0x04
    13fc:	82 0f       	add	r24, r18
    13fe:	93 1f       	adc	r25, r19
    1400:	22 e0       	ldi	r18, 0x02	; 2
    1402:	88 35       	cpi	r24, 0x58	; 88
    1404:	92 07       	cpc	r25, r18
    1406:	18 f5       	brcc	.+70     	; 0x144e <pvPortMalloc+0x76>
    1408:	20 91 da 00 	lds	r18, 0x00DA
    140c:	30 91 db 00 	lds	r19, 0x00DB
    1410:	8b 81       	ldd	r24, Y+3	; 0x03
    1412:	9c 81       	ldd	r25, Y+4	; 0x04
    1414:	28 0f       	add	r18, r24
    1416:	39 1f       	adc	r19, r25
    1418:	80 91 da 00 	lds	r24, 0x00DA
    141c:	90 91 db 00 	lds	r25, 0x00DB
    1420:	82 17       	cp	r24, r18
    1422:	93 07       	cpc	r25, r19
    1424:	a0 f4       	brcc	.+40     	; 0x144e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    1426:	80 91 da 00 	lds	r24, 0x00DA
    142a:	90 91 db 00 	lds	r25, 0x00DB
    142e:	84 52       	subi	r24, 0x24	; 36
    1430:	9f 4f       	sbci	r25, 0xFF	; 255
    1432:	9a 83       	std	Y+2, r25	; 0x02
    1434:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    1436:	20 91 da 00 	lds	r18, 0x00DA
    143a:	30 91 db 00 	lds	r19, 0x00DB
    143e:	8b 81       	ldd	r24, Y+3	; 0x03
    1440:	9c 81       	ldd	r25, Y+4	; 0x04
    1442:	82 0f       	add	r24, r18
    1444:	93 1f       	adc	r25, r19
    1446:	90 93 db 00 	sts	0x00DB, r25
    144a:	80 93 da 00 	sts	0x00DA, r24
		}	
	}
	xTaskResumeAll();
    144e:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1452:	89 81       	ldd	r24, Y+1	; 0x01
    1454:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1456:	0f 90       	pop	r0
    1458:	0f 90       	pop	r0
    145a:	0f 90       	pop	r0
    145c:	0f 90       	pop	r0
    145e:	cf 91       	pop	r28
    1460:	df 91       	pop	r29
    1462:	08 95       	ret

00001464 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1464:	df 93       	push	r29
    1466:	cf 93       	push	r28
    1468:	00 d0       	rcall	.+0      	; 0x146a <vPortFree+0x6>
    146a:	cd b7       	in	r28, 0x3d	; 61
    146c:	de b7       	in	r29, 0x3e	; 62
    146e:	9a 83       	std	Y+2, r25	; 0x02
    1470:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1472:	0f 90       	pop	r0
    1474:	0f 90       	pop	r0
    1476:	cf 91       	pop	r28
    1478:	df 91       	pop	r29
    147a:	08 95       	ret

0000147c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    147c:	df 93       	push	r29
    147e:	cf 93       	push	r28
    1480:	cd b7       	in	r28, 0x3d	; 61
    1482:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1484:	10 92 db 00 	sts	0x00DB, r1
    1488:	10 92 da 00 	sts	0x00DA, r1
}
    148c:	cf 91       	pop	r28
    148e:	df 91       	pop	r29
    1490:	08 95       	ret

00001492 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1492:	df 93       	push	r29
    1494:	cf 93       	push	r28
    1496:	cd b7       	in	r28, 0x3d	; 61
    1498:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    149a:	20 91 da 00 	lds	r18, 0x00DA
    149e:	30 91 db 00 	lds	r19, 0x00DB
    14a2:	88 e5       	ldi	r24, 0x58	; 88
    14a4:	92 e0       	ldi	r25, 0x02	; 2
    14a6:	82 1b       	sub	r24, r18
    14a8:	93 0b       	sbc	r25, r19
}
    14aa:	cf 91       	pop	r28
    14ac:	df 91       	pop	r29
    14ae:	08 95       	ret

000014b0 <enableTrigger>:
/////////////////////////////////////////////////////////////////////
//	lcd enable triggering function to make lcd aware about command or
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{
    14b0:	df 93       	push	r29
    14b2:	cf 93       	push	r28
    14b4:	cd b7       	in	r28, 0x3d	; 61
    14b6:	de b7       	in	r29, 0x3e	; 62
    14b8:	6c 97       	sbiw	r28, 0x1c	; 28
    14ba:	0f b6       	in	r0, 0x3f	; 63
    14bc:	f8 94       	cli
    14be:	de bf       	out	0x3e, r29	; 62
    14c0:	0f be       	out	0x3f, r0	; 63
    14c2:	cd bf       	out	0x3d, r28	; 61

	CLR_BIT(PORTB,2);
    14c4:	a8 e3       	ldi	r26, 0x38	; 56
    14c6:	b0 e0       	ldi	r27, 0x00	; 0
    14c8:	e8 e3       	ldi	r30, 0x38	; 56
    14ca:	f0 e0       	ldi	r31, 0x00	; 0
    14cc:	80 81       	ld	r24, Z
    14ce:	8b 7f       	andi	r24, 0xFB	; 251
    14d0:	8c 93       	st	X, r24
    14d2:	80 e0       	ldi	r24, 0x00	; 0
    14d4:	90 e0       	ldi	r25, 0x00	; 0
    14d6:	a0 e8       	ldi	r26, 0x80	; 128
    14d8:	bf e3       	ldi	r27, 0x3F	; 63
    14da:	89 8f       	std	Y+25, r24	; 0x19
    14dc:	9a 8f       	std	Y+26, r25	; 0x1a
    14de:	ab 8f       	std	Y+27, r26	; 0x1b
    14e0:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    14e2:	69 8d       	ldd	r22, Y+25	; 0x19
    14e4:	7a 8d       	ldd	r23, Y+26	; 0x1a
    14e6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    14e8:	9c 8d       	ldd	r25, Y+28	; 0x1c
    14ea:	20 e0       	ldi	r18, 0x00	; 0
    14ec:	30 e0       	ldi	r19, 0x00	; 0
    14ee:	4a ef       	ldi	r20, 0xFA	; 250
    14f0:	54 e4       	ldi	r21, 0x44	; 68
    14f2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    14f6:	dc 01       	movw	r26, r24
    14f8:	cb 01       	movw	r24, r22
    14fa:	8d 8b       	std	Y+21, r24	; 0x15
    14fc:	9e 8b       	std	Y+22, r25	; 0x16
    14fe:	af 8b       	std	Y+23, r26	; 0x17
    1500:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    1502:	6d 89       	ldd	r22, Y+21	; 0x15
    1504:	7e 89       	ldd	r23, Y+22	; 0x16
    1506:	8f 89       	ldd	r24, Y+23	; 0x17
    1508:	98 8d       	ldd	r25, Y+24	; 0x18
    150a:	20 e0       	ldi	r18, 0x00	; 0
    150c:	30 e0       	ldi	r19, 0x00	; 0
    150e:	40 e8       	ldi	r20, 0x80	; 128
    1510:	5f e3       	ldi	r21, 0x3F	; 63
    1512:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1516:	88 23       	and	r24, r24
    1518:	2c f4       	brge	.+10     	; 0x1524 <enableTrigger+0x74>
		__ticks = 1;
    151a:	81 e0       	ldi	r24, 0x01	; 1
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	9c 8b       	std	Y+20, r25	; 0x14
    1520:	8b 8b       	std	Y+19, r24	; 0x13
    1522:	3f c0       	rjmp	.+126    	; 0x15a2 <enableTrigger+0xf2>
	else if (__tmp > 65535)
    1524:	6d 89       	ldd	r22, Y+21	; 0x15
    1526:	7e 89       	ldd	r23, Y+22	; 0x16
    1528:	8f 89       	ldd	r24, Y+23	; 0x17
    152a:	98 8d       	ldd	r25, Y+24	; 0x18
    152c:	20 e0       	ldi	r18, 0x00	; 0
    152e:	3f ef       	ldi	r19, 0xFF	; 255
    1530:	4f e7       	ldi	r20, 0x7F	; 127
    1532:	57 e4       	ldi	r21, 0x47	; 71
    1534:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1538:	18 16       	cp	r1, r24
    153a:	4c f5       	brge	.+82     	; 0x158e <enableTrigger+0xde>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    153c:	69 8d       	ldd	r22, Y+25	; 0x19
    153e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1540:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1542:	9c 8d       	ldd	r25, Y+28	; 0x1c
    1544:	20 e0       	ldi	r18, 0x00	; 0
    1546:	30 e0       	ldi	r19, 0x00	; 0
    1548:	40 e2       	ldi	r20, 0x20	; 32
    154a:	51 e4       	ldi	r21, 0x41	; 65
    154c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1550:	dc 01       	movw	r26, r24
    1552:	cb 01       	movw	r24, r22
    1554:	bc 01       	movw	r22, r24
    1556:	cd 01       	movw	r24, r26
    1558:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    155c:	dc 01       	movw	r26, r24
    155e:	cb 01       	movw	r24, r22
    1560:	9c 8b       	std	Y+20, r25	; 0x14
    1562:	8b 8b       	std	Y+19, r24	; 0x13
    1564:	0f c0       	rjmp	.+30     	; 0x1584 <enableTrigger+0xd4>
    1566:	88 ec       	ldi	r24, 0xC8	; 200
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	9a 8b       	std	Y+18, r25	; 0x12
    156c:	89 8b       	std	Y+17, r24	; 0x11
    156e:	89 89       	ldd	r24, Y+17	; 0x11
    1570:	9a 89       	ldd	r25, Y+18	; 0x12
    1572:	01 97       	sbiw	r24, 0x01	; 1
    1574:	f1 f7       	brne	.-4      	; 0x1572 <enableTrigger+0xc2>
    1576:	9a 8b       	std	Y+18, r25	; 0x12
    1578:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    157a:	8b 89       	ldd	r24, Y+19	; 0x13
    157c:	9c 89       	ldd	r25, Y+20	; 0x14
    157e:	01 97       	sbiw	r24, 0x01	; 1
    1580:	9c 8b       	std	Y+20, r25	; 0x14
    1582:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1584:	8b 89       	ldd	r24, Y+19	; 0x13
    1586:	9c 89       	ldd	r25, Y+20	; 0x14
    1588:	00 97       	sbiw	r24, 0x00	; 0
    158a:	69 f7       	brne	.-38     	; 0x1566 <enableTrigger+0xb6>
    158c:	14 c0       	rjmp	.+40     	; 0x15b6 <enableTrigger+0x106>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    158e:	6d 89       	ldd	r22, Y+21	; 0x15
    1590:	7e 89       	ldd	r23, Y+22	; 0x16
    1592:	8f 89       	ldd	r24, Y+23	; 0x17
    1594:	98 8d       	ldd	r25, Y+24	; 0x18
    1596:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    159a:	dc 01       	movw	r26, r24
    159c:	cb 01       	movw	r24, r22
    159e:	9c 8b       	std	Y+20, r25	; 0x14
    15a0:	8b 8b       	std	Y+19, r24	; 0x13
    15a2:	8b 89       	ldd	r24, Y+19	; 0x13
    15a4:	9c 89       	ldd	r25, Y+20	; 0x14
    15a6:	98 8b       	std	Y+16, r25	; 0x10
    15a8:	8f 87       	std	Y+15, r24	; 0x0f
    15aa:	8f 85       	ldd	r24, Y+15	; 0x0f
    15ac:	98 89       	ldd	r25, Y+16	; 0x10
    15ae:	01 97       	sbiw	r24, 0x01	; 1
    15b0:	f1 f7       	brne	.-4      	; 0x15ae <enableTrigger+0xfe>
    15b2:	98 8b       	std	Y+16, r25	; 0x10
    15b4:	8f 87       	std	Y+15, r24	; 0x0f
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
    15b6:	a8 e3       	ldi	r26, 0x38	; 56
    15b8:	b0 e0       	ldi	r27, 0x00	; 0
    15ba:	e8 e3       	ldi	r30, 0x38	; 56
    15bc:	f0 e0       	ldi	r31, 0x00	; 0
    15be:	80 81       	ld	r24, Z
    15c0:	84 60       	ori	r24, 0x04	; 4
    15c2:	8c 93       	st	X, r24
    15c4:	80 e0       	ldi	r24, 0x00	; 0
    15c6:	90 e0       	ldi	r25, 0x00	; 0
    15c8:	a0 ec       	ldi	r26, 0xC0	; 192
    15ca:	b0 e4       	ldi	r27, 0x40	; 64
    15cc:	8b 87       	std	Y+11, r24	; 0x0b
    15ce:	9c 87       	std	Y+12, r25	; 0x0c
    15d0:	ad 87       	std	Y+13, r26	; 0x0d
    15d2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    15d4:	6b 85       	ldd	r22, Y+11	; 0x0b
    15d6:	7c 85       	ldd	r23, Y+12	; 0x0c
    15d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    15da:	9e 85       	ldd	r25, Y+14	; 0x0e
    15dc:	20 e0       	ldi	r18, 0x00	; 0
    15de:	30 e0       	ldi	r19, 0x00	; 0
    15e0:	4a ef       	ldi	r20, 0xFA	; 250
    15e2:	54 e4       	ldi	r21, 0x44	; 68
    15e4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    15e8:	dc 01       	movw	r26, r24
    15ea:	cb 01       	movw	r24, r22
    15ec:	8f 83       	std	Y+7, r24	; 0x07
    15ee:	98 87       	std	Y+8, r25	; 0x08
    15f0:	a9 87       	std	Y+9, r26	; 0x09
    15f2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    15f4:	6f 81       	ldd	r22, Y+7	; 0x07
    15f6:	78 85       	ldd	r23, Y+8	; 0x08
    15f8:	89 85       	ldd	r24, Y+9	; 0x09
    15fa:	9a 85       	ldd	r25, Y+10	; 0x0a
    15fc:	20 e0       	ldi	r18, 0x00	; 0
    15fe:	30 e0       	ldi	r19, 0x00	; 0
    1600:	40 e8       	ldi	r20, 0x80	; 128
    1602:	5f e3       	ldi	r21, 0x3F	; 63
    1604:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1608:	88 23       	and	r24, r24
    160a:	2c f4       	brge	.+10     	; 0x1616 <enableTrigger+0x166>
		__ticks = 1;
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	9e 83       	std	Y+6, r25	; 0x06
    1612:	8d 83       	std	Y+5, r24	; 0x05
    1614:	3f c0       	rjmp	.+126    	; 0x1694 <enableTrigger+0x1e4>
	else if (__tmp > 65535)
    1616:	6f 81       	ldd	r22, Y+7	; 0x07
    1618:	78 85       	ldd	r23, Y+8	; 0x08
    161a:	89 85       	ldd	r24, Y+9	; 0x09
    161c:	9a 85       	ldd	r25, Y+10	; 0x0a
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	3f ef       	ldi	r19, 0xFF	; 255
    1622:	4f e7       	ldi	r20, 0x7F	; 127
    1624:	57 e4       	ldi	r21, 0x47	; 71
    1626:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    162a:	18 16       	cp	r1, r24
    162c:	4c f5       	brge	.+82     	; 0x1680 <enableTrigger+0x1d0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    162e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1630:	7c 85       	ldd	r23, Y+12	; 0x0c
    1632:	8d 85       	ldd	r24, Y+13	; 0x0d
    1634:	9e 85       	ldd	r25, Y+14	; 0x0e
    1636:	20 e0       	ldi	r18, 0x00	; 0
    1638:	30 e0       	ldi	r19, 0x00	; 0
    163a:	40 e2       	ldi	r20, 0x20	; 32
    163c:	51 e4       	ldi	r21, 0x41	; 65
    163e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1642:	dc 01       	movw	r26, r24
    1644:	cb 01       	movw	r24, r22
    1646:	bc 01       	movw	r22, r24
    1648:	cd 01       	movw	r24, r26
    164a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    164e:	dc 01       	movw	r26, r24
    1650:	cb 01       	movw	r24, r22
    1652:	9e 83       	std	Y+6, r25	; 0x06
    1654:	8d 83       	std	Y+5, r24	; 0x05
    1656:	0f c0       	rjmp	.+30     	; 0x1676 <enableTrigger+0x1c6>
    1658:	88 ec       	ldi	r24, 0xC8	; 200
    165a:	90 e0       	ldi	r25, 0x00	; 0
    165c:	9c 83       	std	Y+4, r25	; 0x04
    165e:	8b 83       	std	Y+3, r24	; 0x03
    1660:	8b 81       	ldd	r24, Y+3	; 0x03
    1662:	9c 81       	ldd	r25, Y+4	; 0x04
    1664:	01 97       	sbiw	r24, 0x01	; 1
    1666:	f1 f7       	brne	.-4      	; 0x1664 <enableTrigger+0x1b4>
    1668:	9c 83       	std	Y+4, r25	; 0x04
    166a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    166c:	8d 81       	ldd	r24, Y+5	; 0x05
    166e:	9e 81       	ldd	r25, Y+6	; 0x06
    1670:	01 97       	sbiw	r24, 0x01	; 1
    1672:	9e 83       	std	Y+6, r25	; 0x06
    1674:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1676:	8d 81       	ldd	r24, Y+5	; 0x05
    1678:	9e 81       	ldd	r25, Y+6	; 0x06
    167a:	00 97       	sbiw	r24, 0x00	; 0
    167c:	69 f7       	brne	.-38     	; 0x1658 <enableTrigger+0x1a8>
    167e:	14 c0       	rjmp	.+40     	; 0x16a8 <enableTrigger+0x1f8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1680:	6f 81       	ldd	r22, Y+7	; 0x07
    1682:	78 85       	ldd	r23, Y+8	; 0x08
    1684:	89 85       	ldd	r24, Y+9	; 0x09
    1686:	9a 85       	ldd	r25, Y+10	; 0x0a
    1688:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    168c:	dc 01       	movw	r26, r24
    168e:	cb 01       	movw	r24, r22
    1690:	9e 83       	std	Y+6, r25	; 0x06
    1692:	8d 83       	std	Y+5, r24	; 0x05
    1694:	8d 81       	ldd	r24, Y+5	; 0x05
    1696:	9e 81       	ldd	r25, Y+6	; 0x06
    1698:	9a 83       	std	Y+2, r25	; 0x02
    169a:	89 83       	std	Y+1, r24	; 0x01
    169c:	89 81       	ldd	r24, Y+1	; 0x01
    169e:	9a 81       	ldd	r25, Y+2	; 0x02
    16a0:	01 97       	sbiw	r24, 0x01	; 1
    16a2:	f1 f7       	brne	.-4      	; 0x16a0 <enableTrigger+0x1f0>
    16a4:	9a 83       	std	Y+2, r25	; 0x02
    16a6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(6);


}
    16a8:	6c 96       	adiw	r28, 0x1c	; 28
    16aa:	0f b6       	in	r0, 0x3f	; 63
    16ac:	f8 94       	cli
    16ae:	de bf       	out	0x3e, r29	; 62
    16b0:	0f be       	out	0x3f, r0	; 63
    16b2:	cd bf       	out	0x3d, r28	; 61
    16b4:	cf 91       	pop	r28
    16b6:	df 91       	pop	r29
    16b8:	08 95       	ret

000016ba <lcd_init>:
///////////////////////////////////////////////////////////////////////////////////////
// LCD initialization API : set portB from pinB.4 to pinB.7 as o/p for data and commands 
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{
    16ba:	df 93       	push	r29
    16bc:	cf 93       	push	r28
    16be:	cd b7       	in	r28, 0x3d	; 61
    16c0:	de b7       	in	r29, 0x3e	; 62

	DDRB=0xff; // init port B as O/P port 
    16c2:	e7 e3       	ldi	r30, 0x37	; 55
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	8f ef       	ldi	r24, 0xFF	; 255
    16c8:	80 83       	st	Z, r24
	PORTB=0x04; // activate LCD enable 
    16ca:	e8 e3       	ldi	r30, 0x38	; 56
    16cc:	f0 e0       	ldi	r31, 0x00	; 0
    16ce:	84 e0       	ldi	r24, 0x04	; 4
    16d0:	80 83       	st	Z, r24

	lcd_sendCommand(0x33); // 4-bit mode 
    16d2:	83 e3       	ldi	r24, 0x33	; 51
    16d4:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>
	lcd_sendCommand (0x32);
    16d8:	82 e3       	ldi	r24, 0x32	; 50
    16da:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>
	lcd_sendCommand (0x28);
    16de:	88 e2       	ldi	r24, 0x28	; 40
    16e0:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
    16e4:	8c e0       	ldi	r24, 0x0C	; 12
    16e6:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>

		
}
    16ea:	cf 91       	pop	r28
    16ec:	df 91       	pop	r29
    16ee:	08 95       	ret

000016f0 <lcd_sendCommand>:


void lcd_sendCommand(unsigned char cmd)
{
    16f0:	df 93       	push	r29
    16f2:	cf 93       	push	r28
    16f4:	00 d0       	rcall	.+0      	; 0x16f6 <lcd_sendCommand+0x6>
    16f6:	0f 92       	push	r0
    16f8:	cd b7       	in	r28, 0x3d	; 61
    16fa:	de b7       	in	r29, 0x3e	; 62
    16fc:	8b 83       	std	Y+3, r24	; 0x03

	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
    16fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1700:	80 7f       	andi	r24, 0xF0	; 240
    1702:	8a 83       	std	Y+2, r24	; 0x02
	LOW_NIBBLE(low_nibble,cmd);
    1704:	8b 81       	ldd	r24, Y+3	; 0x03
    1706:	82 95       	swap	r24
    1708:	80 7f       	andi	r24, 0xF0	; 240
    170a:	89 83       	std	Y+1, r24	; 0x01

	CLR_BIT(PORTB,0); // to enable command mode 
    170c:	a8 e3       	ldi	r26, 0x38	; 56
    170e:	b0 e0       	ldi	r27, 0x00	; 0
    1710:	e8 e3       	ldi	r30, 0x38	; 56
    1712:	f0 e0       	ldi	r31, 0x00	; 0
    1714:	80 81       	ld	r24, Z
    1716:	8e 7f       	andi	r24, 0xFE	; 254
    1718:	8c 93       	st	X, r24
	CLR_BIT(PORTB,1); // write signal to lcd 
    171a:	a8 e3       	ldi	r26, 0x38	; 56
    171c:	b0 e0       	ldi	r27, 0x00	; 0
    171e:	e8 e3       	ldi	r30, 0x38	; 56
    1720:	f0 e0       	ldi	r31, 0x00	; 0
    1722:	80 81       	ld	r24, Z
    1724:	8d 7f       	andi	r24, 0xFD	; 253
    1726:	8c 93       	st	X, r24

	PORTB &=0x0f;
    1728:	a8 e3       	ldi	r26, 0x38	; 56
    172a:	b0 e0       	ldi	r27, 0x00	; 0
    172c:	e8 e3       	ldi	r30, 0x38	; 56
    172e:	f0 e0       	ldi	r31, 0x00	; 0
    1730:	80 81       	ld	r24, Z
    1732:	8f 70       	andi	r24, 0x0F	; 15
    1734:	8c 93       	st	X, r24
	PORTB |=high_nibble;// to send high nibble command  
    1736:	a8 e3       	ldi	r26, 0x38	; 56
    1738:	b0 e0       	ldi	r27, 0x00	; 0
    173a:	e8 e3       	ldi	r30, 0x38	; 56
    173c:	f0 e0       	ldi	r31, 0x00	; 0
    173e:	90 81       	ld	r25, Z
    1740:	8a 81       	ldd	r24, Y+2	; 0x02
    1742:	89 2b       	or	r24, r25
    1744:	8c 93       	st	X, r24
	enableTrigger(); // triggre lcd enable 
    1746:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <enableTrigger>

	PORTB &=0x0f;
    174a:	a8 e3       	ldi	r26, 0x38	; 56
    174c:	b0 e0       	ldi	r27, 0x00	; 0
    174e:	e8 e3       	ldi	r30, 0x38	; 56
    1750:	f0 e0       	ldi	r31, 0x00	; 0
    1752:	80 81       	ld	r24, Z
    1754:	8f 70       	andi	r24, 0x0F	; 15
    1756:	8c 93       	st	X, r24
	PORTB |=low_nibble; // to send low nibble command 
    1758:	a8 e3       	ldi	r26, 0x38	; 56
    175a:	b0 e0       	ldi	r27, 0x00	; 0
    175c:	e8 e3       	ldi	r30, 0x38	; 56
    175e:	f0 e0       	ldi	r31, 0x00	; 0
    1760:	90 81       	ld	r25, Z
    1762:	89 81       	ldd	r24, Y+1	; 0x01
    1764:	89 2b       	or	r24, r25
    1766:	8c 93       	st	X, r24
	enableTrigger();
    1768:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <enableTrigger>

}
    176c:	0f 90       	pop	r0
    176e:	0f 90       	pop	r0
    1770:	0f 90       	pop	r0
    1772:	cf 91       	pop	r28
    1774:	df 91       	pop	r29
    1776:	08 95       	ret

00001778 <lcd_displayChar>:

void lcd_displayChar (unsigned char data)
{
    1778:	df 93       	push	r29
    177a:	cf 93       	push	r28
    177c:	00 d0       	rcall	.+0      	; 0x177e <lcd_displayChar+0x6>
    177e:	0f 92       	push	r0
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
    1784:	8b 83       	std	Y+3, r24	; 0x03

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
    1786:	a8 e3       	ldi	r26, 0x38	; 56
    1788:	b0 e0       	ldi	r27, 0x00	; 0
    178a:	e8 e3       	ldi	r30, 0x38	; 56
    178c:	f0 e0       	ldi	r31, 0x00	; 0
    178e:	80 81       	ld	r24, Z
    1790:	81 60       	ori	r24, 0x01	; 1
    1792:	8c 93       	st	X, r24
	CLR_BIT(PORTB,1); // activate lcd write 
    1794:	a8 e3       	ldi	r26, 0x38	; 56
    1796:	b0 e0       	ldi	r27, 0x00	; 0
    1798:	e8 e3       	ldi	r30, 0x38	; 56
    179a:	f0 e0       	ldi	r31, 0x00	; 0
    179c:	80 81       	ld	r24, Z
    179e:	8d 7f       	andi	r24, 0xFD	; 253
    17a0:	8c 93       	st	X, r24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
    17a2:	8b 81       	ldd	r24, Y+3	; 0x03
    17a4:	80 7f       	andi	r24, 0xF0	; 240
    17a6:	8a 83       	std	Y+2, r24	; 0x02
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
    17a8:	8b 81       	ldd	r24, Y+3	; 0x03
    17aa:	82 95       	swap	r24
    17ac:	80 7f       	andi	r24, 0xF0	; 240
    17ae:	89 83       	std	Y+1, r24	; 0x01
	
	PORTB &= 0x0f;
    17b0:	a8 e3       	ldi	r26, 0x38	; 56
    17b2:	b0 e0       	ldi	r27, 0x00	; 0
    17b4:	e8 e3       	ldi	r30, 0x38	; 56
    17b6:	f0 e0       	ldi	r31, 0x00	; 0
    17b8:	80 81       	ld	r24, Z
    17ba:	8f 70       	andi	r24, 0x0F	; 15
    17bc:	8c 93       	st	X, r24
	PORTB |=high_nibble;// to send high nibble data  
    17be:	a8 e3       	ldi	r26, 0x38	; 56
    17c0:	b0 e0       	ldi	r27, 0x00	; 0
    17c2:	e8 e3       	ldi	r30, 0x38	; 56
    17c4:	f0 e0       	ldi	r31, 0x00	; 0
    17c6:	90 81       	ld	r25, Z
    17c8:	8a 81       	ldd	r24, Y+2	; 0x02
    17ca:	89 2b       	or	r24, r25
    17cc:	8c 93       	st	X, r24
	enableTrigger(); // triggre lcd enable 
    17ce:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <enableTrigger>
	
	PORTB &=0x0f;
    17d2:	a8 e3       	ldi	r26, 0x38	; 56
    17d4:	b0 e0       	ldi	r27, 0x00	; 0
    17d6:	e8 e3       	ldi	r30, 0x38	; 56
    17d8:	f0 e0       	ldi	r31, 0x00	; 0
    17da:	80 81       	ld	r24, Z
    17dc:	8f 70       	andi	r24, 0x0F	; 15
    17de:	8c 93       	st	X, r24
	PORTB |=low_nibble; // to send low nibble data 
    17e0:	a8 e3       	ldi	r26, 0x38	; 56
    17e2:	b0 e0       	ldi	r27, 0x00	; 0
    17e4:	e8 e3       	ldi	r30, 0x38	; 56
    17e6:	f0 e0       	ldi	r31, 0x00	; 0
    17e8:	90 81       	ld	r25, Z
    17ea:	89 81       	ldd	r24, Y+1	; 0x01
    17ec:	89 2b       	or	r24, r25
    17ee:	8c 93       	st	X, r24
	enableTrigger();
    17f0:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <enableTrigger>
	

}
    17f4:	0f 90       	pop	r0
    17f6:	0f 90       	pop	r0
    17f8:	0f 90       	pop	r0
    17fa:	cf 91       	pop	r28
    17fc:	df 91       	pop	r29
    17fe:	08 95       	ret

00001800 <lcd_gotoxy>:


void lcd_gotoxy(unsigned char y , unsigned char x )
{
    1800:	df 93       	push	r29
    1802:	cf 93       	push	r28
    1804:	00 d0       	rcall	.+0      	; 0x1806 <lcd_gotoxy+0x6>
    1806:	00 d0       	rcall	.+0      	; 0x1808 <lcd_gotoxy+0x8>
    1808:	0f 92       	push	r0
    180a:	cd b7       	in	r28, 0x3d	; 61
    180c:	de b7       	in	r29, 0x3e	; 62
    180e:	8a 83       	std	Y+2, r24	; 0x02
    1810:	6b 83       	std	Y+3, r22	; 0x03
	unsigned char position = 0x80;
    1812:	80 e8       	ldi	r24, 0x80	; 128
    1814:	89 83       	std	Y+1, r24	; 0x01
	 
	switch(y)
    1816:	8a 81       	ldd	r24, Y+2	; 0x02
    1818:	28 2f       	mov	r18, r24
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	3d 83       	std	Y+5, r19	; 0x05
    181e:	2c 83       	std	Y+4, r18	; 0x04
    1820:	8c 81       	ldd	r24, Y+4	; 0x04
    1822:	9d 81       	ldd	r25, Y+5	; 0x05
    1824:	81 30       	cpi	r24, 0x01	; 1
    1826:	91 05       	cpc	r25, r1
    1828:	d1 f0       	breq	.+52     	; 0x185e <lcd_gotoxy+0x5e>
    182a:	2c 81       	ldd	r18, Y+4	; 0x04
    182c:	3d 81       	ldd	r19, Y+5	; 0x05
    182e:	22 30       	cpi	r18, 0x02	; 2
    1830:	31 05       	cpc	r19, r1
    1832:	2c f4       	brge	.+10     	; 0x183e <lcd_gotoxy+0x3e>
    1834:	8c 81       	ldd	r24, Y+4	; 0x04
    1836:	9d 81       	ldd	r25, Y+5	; 0x05
    1838:	00 97       	sbiw	r24, 0x00	; 0
    183a:	61 f0       	breq	.+24     	; 0x1854 <lcd_gotoxy+0x54>
    183c:	20 c0       	rjmp	.+64     	; 0x187e <lcd_gotoxy+0x7e>
    183e:	2c 81       	ldd	r18, Y+4	; 0x04
    1840:	3d 81       	ldd	r19, Y+5	; 0x05
    1842:	22 30       	cpi	r18, 0x02	; 2
    1844:	31 05       	cpc	r19, r1
    1846:	91 f0       	breq	.+36     	; 0x186c <lcd_gotoxy+0x6c>
    1848:	8c 81       	ldd	r24, Y+4	; 0x04
    184a:	9d 81       	ldd	r25, Y+5	; 0x05
    184c:	83 30       	cpi	r24, 0x03	; 3
    184e:	91 05       	cpc	r25, r1
    1850:	91 f0       	breq	.+36     	; 0x1876 <lcd_gotoxy+0x76>
    1852:	15 c0       	rjmp	.+42     	; 0x187e <lcd_gotoxy+0x7e>
	{
		case 0:

			position=position+x;
    1854:	89 81       	ldd	r24, Y+1	; 0x01
    1856:	9b 81       	ldd	r25, Y+3	; 0x03
    1858:	89 0f       	add	r24, r25
    185a:	89 83       	std	Y+1, r24	; 0x01
    185c:	10 c0       	rjmp	.+32     	; 0x187e <lcd_gotoxy+0x7e>
					
		break;

		case 1:

			position=0xc0;
    185e:	80 ec       	ldi	r24, 0xC0	; 192
    1860:	89 83       	std	Y+1, r24	; 0x01
			position=position+x;
    1862:	99 81       	ldd	r25, Y+1	; 0x01
    1864:	8b 81       	ldd	r24, Y+3	; 0x03
    1866:	89 0f       	add	r24, r25
    1868:	89 83       	std	Y+1, r24	; 0x01
    186a:	09 c0       	rjmp	.+18     	; 0x187e <lcd_gotoxy+0x7e>

		break;

		case 2:

			position=position+x;
    186c:	89 81       	ldd	r24, Y+1	; 0x01
    186e:	9b 81       	ldd	r25, Y+3	; 0x03
    1870:	89 0f       	add	r24, r25
    1872:	89 83       	std	Y+1, r24	; 0x01
    1874:	04 c0       	rjmp	.+8      	; 0x187e <lcd_gotoxy+0x7e>

		break;

		case 3:
			position=position+x;
    1876:	89 81       	ldd	r24, Y+1	; 0x01
    1878:	9b 81       	ldd	r25, Y+3	; 0x03
    187a:	89 0f       	add	r24, r25
    187c:	89 83       	std	Y+1, r24	; 0x01
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
    187e:	89 81       	ldd	r24, Y+1	; 0x01
    1880:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>


}
    1884:	0f 90       	pop	r0
    1886:	0f 90       	pop	r0
    1888:	0f 90       	pop	r0
    188a:	0f 90       	pop	r0
    188c:	0f 90       	pop	r0
    188e:	cf 91       	pop	r28
    1890:	df 91       	pop	r29
    1892:	08 95       	ret

00001894 <lcd_clrScreen>:


void lcd_clrScreen(void)
{
    1894:	df 93       	push	r29
    1896:	cf 93       	push	r28
    1898:	cd b7       	in	r28, 0x3d	; 61
    189a:	de b7       	in	r29, 0x3e	; 62

	lcd_sendCommand(0x01);
    189c:	81 e0       	ldi	r24, 0x01	; 1
    189e:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <lcd_sendCommand>


}
    18a2:	cf 91       	pop	r28
    18a4:	df 91       	pop	r29
    18a6:	08 95       	ret

000018a8 <lcd_dispString>:


void lcd_dispString(char * ptr)
{
    18a8:	df 93       	push	r29
    18aa:	cf 93       	push	r28
    18ac:	00 d0       	rcall	.+0      	; 0x18ae <lcd_dispString+0x6>
    18ae:	cd b7       	in	r28, 0x3d	; 61
    18b0:	de b7       	in	r29, 0x3e	; 62
    18b2:	9a 83       	std	Y+2, r25	; 0x02
    18b4:	89 83       	std	Y+1, r24	; 0x01
    18b6:	0a c0       	rjmp	.+20     	; 0x18cc <lcd_dispString+0x24>

	while(* ptr!= '\0')
	{
		lcd_displayChar(* ptr);
    18b8:	e9 81       	ldd	r30, Y+1	; 0x01
    18ba:	fa 81       	ldd	r31, Y+2	; 0x02
    18bc:	80 81       	ld	r24, Z
    18be:	0e 94 bc 0b 	call	0x1778	; 0x1778 <lcd_displayChar>
		ptr++;
    18c2:	89 81       	ldd	r24, Y+1	; 0x01
    18c4:	9a 81       	ldd	r25, Y+2	; 0x02
    18c6:	01 96       	adiw	r24, 0x01	; 1
    18c8:	9a 83       	std	Y+2, r25	; 0x02
    18ca:	89 83       	std	Y+1, r24	; 0x01


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
    18cc:	e9 81       	ldd	r30, Y+1	; 0x01
    18ce:	fa 81       	ldd	r31, Y+2	; 0x02
    18d0:	80 81       	ld	r24, Z
    18d2:	88 23       	and	r24, r24
    18d4:	89 f7       	brne	.-30     	; 0x18b8 <lcd_dispString+0x10>
	
	}



}
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	cf 91       	pop	r28
    18dc:	df 91       	pop	r29
    18de:	08 95       	ret

000018e0 <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
    18e0:	df 93       	push	r29
    18e2:	cf 93       	push	r28
    18e4:	00 d0       	rcall	.+0      	; 0x18e6 <lcd_disp_string_xy+0x6>
    18e6:	00 d0       	rcall	.+0      	; 0x18e8 <lcd_disp_string_xy+0x8>
    18e8:	00 d0       	rcall	.+0      	; 0x18ea <lcd_disp_string_xy+0xa>
    18ea:	cd b7       	in	r28, 0x3d	; 61
    18ec:	de b7       	in	r29, 0x3e	; 62
    18ee:	9a 83       	std	Y+2, r25	; 0x02
    18f0:	89 83       	std	Y+1, r24	; 0x01
    18f2:	7c 83       	std	Y+4, r23	; 0x04
    18f4:	6b 83       	std	Y+3, r22	; 0x03
    18f6:	5e 83       	std	Y+6, r21	; 0x06
    18f8:	4d 83       	std	Y+5, r20	; 0x05

	lcd_gotoxy(y,x);
    18fa:	8b 81       	ldd	r24, Y+3	; 0x03
    18fc:	9d 81       	ldd	r25, Y+5	; 0x05
    18fe:	69 2f       	mov	r22, r25
    1900:	0e 94 00 0c 	call	0x1800	; 0x1800 <lcd_gotoxy>
	lcd_dispString(ptr);
    1904:	89 81       	ldd	r24, Y+1	; 0x01
    1906:	9a 81       	ldd	r25, Y+2	; 0x02
    1908:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <lcd_dispString>

	


}
    190c:	26 96       	adiw	r28, 0x06	; 6
    190e:	0f b6       	in	r0, 0x3f	; 63
    1910:	f8 94       	cli
    1912:	de bf       	out	0x3e, r29	; 62
    1914:	0f be       	out	0x3f, r0	; 63
    1916:	cd bf       	out	0x3d, r28	; 61
    1918:	cf 91       	pop	r28
    191a:	df 91       	pop	r29
    191c:	08 95       	ret

0000191e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    191e:	df 93       	push	r29
    1920:	cf 93       	push	r28
    1922:	00 d0       	rcall	.+0      	; 0x1924 <vListInitialise+0x6>
    1924:	cd b7       	in	r28, 0x3d	; 61
    1926:	de b7       	in	r29, 0x3e	; 62
    1928:	9a 83       	std	Y+2, r25	; 0x02
    192a:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    192c:	89 81       	ldd	r24, Y+1	; 0x01
    192e:	9a 81       	ldd	r25, Y+2	; 0x02
    1930:	03 96       	adiw	r24, 0x03	; 3
    1932:	e9 81       	ldd	r30, Y+1	; 0x01
    1934:	fa 81       	ldd	r31, Y+2	; 0x02
    1936:	92 83       	std	Z+2, r25	; 0x02
    1938:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    193a:	e9 81       	ldd	r30, Y+1	; 0x01
    193c:	fa 81       	ldd	r31, Y+2	; 0x02
    193e:	8f ef       	ldi	r24, 0xFF	; 255
    1940:	9f ef       	ldi	r25, 0xFF	; 255
    1942:	94 83       	std	Z+4, r25	; 0x04
    1944:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1946:	89 81       	ldd	r24, Y+1	; 0x01
    1948:	9a 81       	ldd	r25, Y+2	; 0x02
    194a:	03 96       	adiw	r24, 0x03	; 3
    194c:	e9 81       	ldd	r30, Y+1	; 0x01
    194e:	fa 81       	ldd	r31, Y+2	; 0x02
    1950:	96 83       	std	Z+6, r25	; 0x06
    1952:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1954:	89 81       	ldd	r24, Y+1	; 0x01
    1956:	9a 81       	ldd	r25, Y+2	; 0x02
    1958:	03 96       	adiw	r24, 0x03	; 3
    195a:	e9 81       	ldd	r30, Y+1	; 0x01
    195c:	fa 81       	ldd	r31, Y+2	; 0x02
    195e:	90 87       	std	Z+8, r25	; 0x08
    1960:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1962:	e9 81       	ldd	r30, Y+1	; 0x01
    1964:	fa 81       	ldd	r31, Y+2	; 0x02
    1966:	10 82       	st	Z, r1
}
    1968:	0f 90       	pop	r0
    196a:	0f 90       	pop	r0
    196c:	cf 91       	pop	r28
    196e:	df 91       	pop	r29
    1970:	08 95       	ret

00001972 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    1972:	df 93       	push	r29
    1974:	cf 93       	push	r28
    1976:	00 d0       	rcall	.+0      	; 0x1978 <vListInitialiseItem+0x6>
    1978:	cd b7       	in	r28, 0x3d	; 61
    197a:	de b7       	in	r29, 0x3e	; 62
    197c:	9a 83       	std	Y+2, r25	; 0x02
    197e:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1980:	e9 81       	ldd	r30, Y+1	; 0x01
    1982:	fa 81       	ldd	r31, Y+2	; 0x02
    1984:	11 86       	std	Z+9, r1	; 0x09
    1986:	10 86       	std	Z+8, r1	; 0x08
}
    1988:	0f 90       	pop	r0
    198a:	0f 90       	pop	r0
    198c:	cf 91       	pop	r28
    198e:	df 91       	pop	r29
    1990:	08 95       	ret

00001992 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1992:	df 93       	push	r29
    1994:	cf 93       	push	r28
    1996:	00 d0       	rcall	.+0      	; 0x1998 <vListInsertEnd+0x6>
    1998:	00 d0       	rcall	.+0      	; 0x199a <vListInsertEnd+0x8>
    199a:	00 d0       	rcall	.+0      	; 0x199c <vListInsertEnd+0xa>
    199c:	cd b7       	in	r28, 0x3d	; 61
    199e:	de b7       	in	r29, 0x3e	; 62
    19a0:	9c 83       	std	Y+4, r25	; 0x04
    19a2:	8b 83       	std	Y+3, r24	; 0x03
    19a4:	7e 83       	std	Y+6, r23	; 0x06
    19a6:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    19a8:	eb 81       	ldd	r30, Y+3	; 0x03
    19aa:	fc 81       	ldd	r31, Y+4	; 0x04
    19ac:	81 81       	ldd	r24, Z+1	; 0x01
    19ae:	92 81       	ldd	r25, Z+2	; 0x02
    19b0:	9a 83       	std	Y+2, r25	; 0x02
    19b2:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    19b4:	e9 81       	ldd	r30, Y+1	; 0x01
    19b6:	fa 81       	ldd	r31, Y+2	; 0x02
    19b8:	82 81       	ldd	r24, Z+2	; 0x02
    19ba:	93 81       	ldd	r25, Z+3	; 0x03
    19bc:	ed 81       	ldd	r30, Y+5	; 0x05
    19be:	fe 81       	ldd	r31, Y+6	; 0x06
    19c0:	93 83       	std	Z+3, r25	; 0x03
    19c2:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    19c4:	eb 81       	ldd	r30, Y+3	; 0x03
    19c6:	fc 81       	ldd	r31, Y+4	; 0x04
    19c8:	81 81       	ldd	r24, Z+1	; 0x01
    19ca:	92 81       	ldd	r25, Z+2	; 0x02
    19cc:	ed 81       	ldd	r30, Y+5	; 0x05
    19ce:	fe 81       	ldd	r31, Y+6	; 0x06
    19d0:	95 83       	std	Z+5, r25	; 0x05
    19d2:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    19d4:	e9 81       	ldd	r30, Y+1	; 0x01
    19d6:	fa 81       	ldd	r31, Y+2	; 0x02
    19d8:	02 80       	ldd	r0, Z+2	; 0x02
    19da:	f3 81       	ldd	r31, Z+3	; 0x03
    19dc:	e0 2d       	mov	r30, r0
    19de:	8d 81       	ldd	r24, Y+5	; 0x05
    19e0:	9e 81       	ldd	r25, Y+6	; 0x06
    19e2:	95 83       	std	Z+5, r25	; 0x05
    19e4:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    19e6:	8d 81       	ldd	r24, Y+5	; 0x05
    19e8:	9e 81       	ldd	r25, Y+6	; 0x06
    19ea:	e9 81       	ldd	r30, Y+1	; 0x01
    19ec:	fa 81       	ldd	r31, Y+2	; 0x02
    19ee:	93 83       	std	Z+3, r25	; 0x03
    19f0:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    19f2:	8d 81       	ldd	r24, Y+5	; 0x05
    19f4:	9e 81       	ldd	r25, Y+6	; 0x06
    19f6:	eb 81       	ldd	r30, Y+3	; 0x03
    19f8:	fc 81       	ldd	r31, Y+4	; 0x04
    19fa:	92 83       	std	Z+2, r25	; 0x02
    19fc:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19fe:	ed 81       	ldd	r30, Y+5	; 0x05
    1a00:	fe 81       	ldd	r31, Y+6	; 0x06
    1a02:	8b 81       	ldd	r24, Y+3	; 0x03
    1a04:	9c 81       	ldd	r25, Y+4	; 0x04
    1a06:	91 87       	std	Z+9, r25	; 0x09
    1a08:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0e:	80 81       	ld	r24, Z
    1a10:	8f 5f       	subi	r24, 0xFF	; 255
    1a12:	eb 81       	ldd	r30, Y+3	; 0x03
    1a14:	fc 81       	ldd	r31, Y+4	; 0x04
    1a16:	80 83       	st	Z, r24
}
    1a18:	26 96       	adiw	r28, 0x06	; 6
    1a1a:	0f b6       	in	r0, 0x3f	; 63
    1a1c:	f8 94       	cli
    1a1e:	de bf       	out	0x3e, r29	; 62
    1a20:	0f be       	out	0x3f, r0	; 63
    1a22:	cd bf       	out	0x3d, r28	; 61
    1a24:	cf 91       	pop	r28
    1a26:	df 91       	pop	r29
    1a28:	08 95       	ret

00001a2a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1a2a:	df 93       	push	r29
    1a2c:	cf 93       	push	r28
    1a2e:	cd b7       	in	r28, 0x3d	; 61
    1a30:	de b7       	in	r29, 0x3e	; 62
    1a32:	28 97       	sbiw	r28, 0x08	; 8
    1a34:	0f b6       	in	r0, 0x3f	; 63
    1a36:	f8 94       	cli
    1a38:	de bf       	out	0x3e, r29	; 62
    1a3a:	0f be       	out	0x3f, r0	; 63
    1a3c:	cd bf       	out	0x3d, r28	; 61
    1a3e:	9e 83       	std	Y+6, r25	; 0x06
    1a40:	8d 83       	std	Y+5, r24	; 0x05
    1a42:	78 87       	std	Y+8, r23	; 0x08
    1a44:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1a46:	ef 81       	ldd	r30, Y+7	; 0x07
    1a48:	f8 85       	ldd	r31, Y+8	; 0x08
    1a4a:	80 81       	ld	r24, Z
    1a4c:	91 81       	ldd	r25, Z+1	; 0x01
    1a4e:	9a 83       	std	Y+2, r25	; 0x02
    1a50:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1a52:	89 81       	ldd	r24, Y+1	; 0x01
    1a54:	9a 81       	ldd	r25, Y+2	; 0x02
    1a56:	2f ef       	ldi	r18, 0xFF	; 255
    1a58:	8f 3f       	cpi	r24, 0xFF	; 255
    1a5a:	92 07       	cpc	r25, r18
    1a5c:	39 f4       	brne	.+14     	; 0x1a6c <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1a5e:	ed 81       	ldd	r30, Y+5	; 0x05
    1a60:	fe 81       	ldd	r31, Y+6	; 0x06
    1a62:	87 81       	ldd	r24, Z+7	; 0x07
    1a64:	90 85       	ldd	r25, Z+8	; 0x08
    1a66:	9c 83       	std	Y+4, r25	; 0x04
    1a68:	8b 83       	std	Y+3, r24	; 0x03
    1a6a:	18 c0       	rjmp	.+48     	; 0x1a9c <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    1a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    1a70:	03 96       	adiw	r24, 0x03	; 3
    1a72:	9c 83       	std	Y+4, r25	; 0x04
    1a74:	8b 83       	std	Y+3, r24	; 0x03
    1a76:	06 c0       	rjmp	.+12     	; 0x1a84 <vListInsert+0x5a>
    1a78:	eb 81       	ldd	r30, Y+3	; 0x03
    1a7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1a7c:	82 81       	ldd	r24, Z+2	; 0x02
    1a7e:	93 81       	ldd	r25, Z+3	; 0x03
    1a80:	9c 83       	std	Y+4, r25	; 0x04
    1a82:	8b 83       	std	Y+3, r24	; 0x03
    1a84:	eb 81       	ldd	r30, Y+3	; 0x03
    1a86:	fc 81       	ldd	r31, Y+4	; 0x04
    1a88:	02 80       	ldd	r0, Z+2	; 0x02
    1a8a:	f3 81       	ldd	r31, Z+3	; 0x03
    1a8c:	e0 2d       	mov	r30, r0
    1a8e:	20 81       	ld	r18, Z
    1a90:	31 81       	ldd	r19, Z+1	; 0x01
    1a92:	89 81       	ldd	r24, Y+1	; 0x01
    1a94:	9a 81       	ldd	r25, Y+2	; 0x02
    1a96:	82 17       	cp	r24, r18
    1a98:	93 07       	cpc	r25, r19
    1a9a:	70 f7       	brcc	.-36     	; 0x1a78 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1a9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1aa0:	82 81       	ldd	r24, Z+2	; 0x02
    1aa2:	93 81       	ldd	r25, Z+3	; 0x03
    1aa4:	ef 81       	ldd	r30, Y+7	; 0x07
    1aa6:	f8 85       	ldd	r31, Y+8	; 0x08
    1aa8:	93 83       	std	Z+3, r25	; 0x03
    1aaa:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1aac:	ef 81       	ldd	r30, Y+7	; 0x07
    1aae:	f8 85       	ldd	r31, Y+8	; 0x08
    1ab0:	02 80       	ldd	r0, Z+2	; 0x02
    1ab2:	f3 81       	ldd	r31, Z+3	; 0x03
    1ab4:	e0 2d       	mov	r30, r0
    1ab6:	8f 81       	ldd	r24, Y+7	; 0x07
    1ab8:	98 85       	ldd	r25, Y+8	; 0x08
    1aba:	95 83       	std	Z+5, r25	; 0x05
    1abc:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1abe:	ef 81       	ldd	r30, Y+7	; 0x07
    1ac0:	f8 85       	ldd	r31, Y+8	; 0x08
    1ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac4:	9c 81       	ldd	r25, Y+4	; 0x04
    1ac6:	95 83       	std	Z+5, r25	; 0x05
    1ac8:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1aca:	8f 81       	ldd	r24, Y+7	; 0x07
    1acc:	98 85       	ldd	r25, Y+8	; 0x08
    1ace:	eb 81       	ldd	r30, Y+3	; 0x03
    1ad0:	fc 81       	ldd	r31, Y+4	; 0x04
    1ad2:	93 83       	std	Z+3, r25	; 0x03
    1ad4:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ad6:	ef 81       	ldd	r30, Y+7	; 0x07
    1ad8:	f8 85       	ldd	r31, Y+8	; 0x08
    1ada:	8d 81       	ldd	r24, Y+5	; 0x05
    1adc:	9e 81       	ldd	r25, Y+6	; 0x06
    1ade:	91 87       	std	Z+9, r25	; 0x09
    1ae0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1ae2:	ed 81       	ldd	r30, Y+5	; 0x05
    1ae4:	fe 81       	ldd	r31, Y+6	; 0x06
    1ae6:	80 81       	ld	r24, Z
    1ae8:	8f 5f       	subi	r24, 0xFF	; 255
    1aea:	ed 81       	ldd	r30, Y+5	; 0x05
    1aec:	fe 81       	ldd	r31, Y+6	; 0x06
    1aee:	80 83       	st	Z, r24
}
    1af0:	28 96       	adiw	r28, 0x08	; 8
    1af2:	0f b6       	in	r0, 0x3f	; 63
    1af4:	f8 94       	cli
    1af6:	de bf       	out	0x3e, r29	; 62
    1af8:	0f be       	out	0x3f, r0	; 63
    1afa:	cd bf       	out	0x3d, r28	; 61
    1afc:	cf 91       	pop	r28
    1afe:	df 91       	pop	r29
    1b00:	08 95       	ret

00001b02 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    1b02:	df 93       	push	r29
    1b04:	cf 93       	push	r28
    1b06:	00 d0       	rcall	.+0      	; 0x1b08 <vListRemove+0x6>
    1b08:	00 d0       	rcall	.+0      	; 0x1b0a <vListRemove+0x8>
    1b0a:	cd b7       	in	r28, 0x3d	; 61
    1b0c:	de b7       	in	r29, 0x3e	; 62
    1b0e:	9c 83       	std	Y+4, r25	; 0x04
    1b10:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1b12:	eb 81       	ldd	r30, Y+3	; 0x03
    1b14:	fc 81       	ldd	r31, Y+4	; 0x04
    1b16:	a2 81       	ldd	r26, Z+2	; 0x02
    1b18:	b3 81       	ldd	r27, Z+3	; 0x03
    1b1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b1e:	84 81       	ldd	r24, Z+4	; 0x04
    1b20:	95 81       	ldd	r25, Z+5	; 0x05
    1b22:	15 96       	adiw	r26, 0x05	; 5
    1b24:	9c 93       	st	X, r25
    1b26:	8e 93       	st	-X, r24
    1b28:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1b2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1b2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1b2e:	a4 81       	ldd	r26, Z+4	; 0x04
    1b30:	b5 81       	ldd	r27, Z+5	; 0x05
    1b32:	eb 81       	ldd	r30, Y+3	; 0x03
    1b34:	fc 81       	ldd	r31, Y+4	; 0x04
    1b36:	82 81       	ldd	r24, Z+2	; 0x02
    1b38:	93 81       	ldd	r25, Z+3	; 0x03
    1b3a:	13 96       	adiw	r26, 0x03	; 3
    1b3c:	9c 93       	st	X, r25
    1b3e:	8e 93       	st	-X, r24
    1b40:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    1b42:	eb 81       	ldd	r30, Y+3	; 0x03
    1b44:	fc 81       	ldd	r31, Y+4	; 0x04
    1b46:	80 85       	ldd	r24, Z+8	; 0x08
    1b48:	91 85       	ldd	r25, Z+9	; 0x09
    1b4a:	9a 83       	std	Y+2, r25	; 0x02
    1b4c:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1b4e:	e9 81       	ldd	r30, Y+1	; 0x01
    1b50:	fa 81       	ldd	r31, Y+2	; 0x02
    1b52:	21 81       	ldd	r18, Z+1	; 0x01
    1b54:	32 81       	ldd	r19, Z+2	; 0x02
    1b56:	8b 81       	ldd	r24, Y+3	; 0x03
    1b58:	9c 81       	ldd	r25, Y+4	; 0x04
    1b5a:	28 17       	cp	r18, r24
    1b5c:	39 07       	cpc	r19, r25
    1b5e:	41 f4       	brne	.+16     	; 0x1b70 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1b60:	eb 81       	ldd	r30, Y+3	; 0x03
    1b62:	fc 81       	ldd	r31, Y+4	; 0x04
    1b64:	84 81       	ldd	r24, Z+4	; 0x04
    1b66:	95 81       	ldd	r25, Z+5	; 0x05
    1b68:	e9 81       	ldd	r30, Y+1	; 0x01
    1b6a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b6c:	92 83       	std	Z+2, r25	; 0x02
    1b6e:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1b70:	eb 81       	ldd	r30, Y+3	; 0x03
    1b72:	fc 81       	ldd	r31, Y+4	; 0x04
    1b74:	11 86       	std	Z+9, r1	; 0x09
    1b76:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1b78:	e9 81       	ldd	r30, Y+1	; 0x01
    1b7a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b7c:	80 81       	ld	r24, Z
    1b7e:	81 50       	subi	r24, 0x01	; 1
    1b80:	e9 81       	ldd	r30, Y+1	; 0x01
    1b82:	fa 81       	ldd	r31, Y+2	; 0x02
    1b84:	80 83       	st	Z, r24
}
    1b86:	0f 90       	pop	r0
    1b88:	0f 90       	pop	r0
    1b8a:	0f 90       	pop	r0
    1b8c:	0f 90       	pop	r0
    1b8e:	cf 91       	pop	r28
    1b90:	df 91       	pop	r29
    1b92:	08 95       	ret

00001b94 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1b94:	df 93       	push	r29
    1b96:	cf 93       	push	r28
    1b98:	cd b7       	in	r28, 0x3d	; 61
    1b9a:	de b7       	in	r29, 0x3e	; 62
    1b9c:	28 97       	sbiw	r28, 0x08	; 8
    1b9e:	0f b6       	in	r0, 0x3f	; 63
    1ba0:	f8 94       	cli
    1ba2:	de bf       	out	0x3e, r29	; 62
    1ba4:	0f be       	out	0x3f, r0	; 63
    1ba6:	cd bf       	out	0x3d, r28	; 61
    1ba8:	9c 83       	std	Y+4, r25	; 0x04
    1baa:	8b 83       	std	Y+3, r24	; 0x03
    1bac:	7e 83       	std	Y+6, r23	; 0x06
    1bae:	6d 83       	std	Y+5, r22	; 0x05
    1bb0:	58 87       	std	Y+8, r21	; 0x08
    1bb2:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1bb4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bb6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bb8:	81 e1       	ldi	r24, 0x11	; 17
    1bba:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bbc:	8b 81       	ldd	r24, Y+3	; 0x03
    1bbe:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc0:	01 97       	sbiw	r24, 0x01	; 1
    1bc2:	9c 83       	std	Y+4, r25	; 0x04
    1bc4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1bc6:	eb 81       	ldd	r30, Y+3	; 0x03
    1bc8:	fc 81       	ldd	r31, Y+4	; 0x04
    1bca:	82 e2       	ldi	r24, 0x22	; 34
    1bcc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bce:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bd2:	01 97       	sbiw	r24, 0x01	; 1
    1bd4:	9c 83       	std	Y+4, r25	; 0x04
    1bd6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1bd8:	eb 81       	ldd	r30, Y+3	; 0x03
    1bda:	fc 81       	ldd	r31, Y+4	; 0x04
    1bdc:	83 e3       	ldi	r24, 0x33	; 51
    1bde:	80 83       	st	Z, r24
	pxTopOfStack--;
    1be0:	8b 81       	ldd	r24, Y+3	; 0x03
    1be2:	9c 81       	ldd	r25, Y+4	; 0x04
    1be4:	01 97       	sbiw	r24, 0x01	; 1
    1be6:	9c 83       	std	Y+4, r25	; 0x04
    1be8:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1bea:	8d 81       	ldd	r24, Y+5	; 0x05
    1bec:	9e 81       	ldd	r25, Y+6	; 0x06
    1bee:	9a 83       	std	Y+2, r25	; 0x02
    1bf0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1bf2:	89 81       	ldd	r24, Y+1	; 0x01
    1bf4:	eb 81       	ldd	r30, Y+3	; 0x03
    1bf6:	fc 81       	ldd	r31, Y+4	; 0x04
    1bf8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1bfa:	8b 81       	ldd	r24, Y+3	; 0x03
    1bfc:	9c 81       	ldd	r25, Y+4	; 0x04
    1bfe:	01 97       	sbiw	r24, 0x01	; 1
    1c00:	9c 83       	std	Y+4, r25	; 0x04
    1c02:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1c04:	89 81       	ldd	r24, Y+1	; 0x01
    1c06:	9a 81       	ldd	r25, Y+2	; 0x02
    1c08:	89 2f       	mov	r24, r25
    1c0a:	99 27       	eor	r25, r25
    1c0c:	9a 83       	std	Y+2, r25	; 0x02
    1c0e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1c10:	89 81       	ldd	r24, Y+1	; 0x01
    1c12:	eb 81       	ldd	r30, Y+3	; 0x03
    1c14:	fc 81       	ldd	r31, Y+4	; 0x04
    1c16:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c18:	8b 81       	ldd	r24, Y+3	; 0x03
    1c1a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c1c:	01 97       	sbiw	r24, 0x01	; 1
    1c1e:	9c 83       	std	Y+4, r25	; 0x04
    1c20:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1c22:	eb 81       	ldd	r30, Y+3	; 0x03
    1c24:	fc 81       	ldd	r31, Y+4	; 0x04
    1c26:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c28:	8b 81       	ldd	r24, Y+3	; 0x03
    1c2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c2c:	01 97       	sbiw	r24, 0x01	; 1
    1c2e:	9c 83       	std	Y+4, r25	; 0x04
    1c30:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1c32:	eb 81       	ldd	r30, Y+3	; 0x03
    1c34:	fc 81       	ldd	r31, Y+4	; 0x04
    1c36:	80 e8       	ldi	r24, 0x80	; 128
    1c38:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c3a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c3c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c3e:	01 97       	sbiw	r24, 0x01	; 1
    1c40:	9c 83       	std	Y+4, r25	; 0x04
    1c42:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1c44:	eb 81       	ldd	r30, Y+3	; 0x03
    1c46:	fc 81       	ldd	r31, Y+4	; 0x04
    1c48:	10 82       	st	Z, r1
	pxTopOfStack--;
    1c4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4e:	01 97       	sbiw	r24, 0x01	; 1
    1c50:	9c 83       	std	Y+4, r25	; 0x04
    1c52:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1c54:	eb 81       	ldd	r30, Y+3	; 0x03
    1c56:	fc 81       	ldd	r31, Y+4	; 0x04
    1c58:	82 e0       	ldi	r24, 0x02	; 2
    1c5a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1c60:	01 97       	sbiw	r24, 0x01	; 1
    1c62:	9c 83       	std	Y+4, r25	; 0x04
    1c64:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1c66:	eb 81       	ldd	r30, Y+3	; 0x03
    1c68:	fc 81       	ldd	r31, Y+4	; 0x04
    1c6a:	83 e0       	ldi	r24, 0x03	; 3
    1c6c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c70:	9c 81       	ldd	r25, Y+4	; 0x04
    1c72:	01 97       	sbiw	r24, 0x01	; 1
    1c74:	9c 83       	std	Y+4, r25	; 0x04
    1c76:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1c78:	eb 81       	ldd	r30, Y+3	; 0x03
    1c7a:	fc 81       	ldd	r31, Y+4	; 0x04
    1c7c:	84 e0       	ldi	r24, 0x04	; 4
    1c7e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c80:	8b 81       	ldd	r24, Y+3	; 0x03
    1c82:	9c 81       	ldd	r25, Y+4	; 0x04
    1c84:	01 97       	sbiw	r24, 0x01	; 1
    1c86:	9c 83       	std	Y+4, r25	; 0x04
    1c88:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1c8a:	eb 81       	ldd	r30, Y+3	; 0x03
    1c8c:	fc 81       	ldd	r31, Y+4	; 0x04
    1c8e:	85 e0       	ldi	r24, 0x05	; 5
    1c90:	80 83       	st	Z, r24
	pxTopOfStack--;
    1c92:	8b 81       	ldd	r24, Y+3	; 0x03
    1c94:	9c 81       	ldd	r25, Y+4	; 0x04
    1c96:	01 97       	sbiw	r24, 0x01	; 1
    1c98:	9c 83       	std	Y+4, r25	; 0x04
    1c9a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1c9c:	eb 81       	ldd	r30, Y+3	; 0x03
    1c9e:	fc 81       	ldd	r31, Y+4	; 0x04
    1ca0:	86 e0       	ldi	r24, 0x06	; 6
    1ca2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1ca4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ca6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ca8:	01 97       	sbiw	r24, 0x01	; 1
    1caa:	9c 83       	std	Y+4, r25	; 0x04
    1cac:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1cae:	eb 81       	ldd	r30, Y+3	; 0x03
    1cb0:	fc 81       	ldd	r31, Y+4	; 0x04
    1cb2:	87 e0       	ldi	r24, 0x07	; 7
    1cb4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cb6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cb8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cba:	01 97       	sbiw	r24, 0x01	; 1
    1cbc:	9c 83       	std	Y+4, r25	; 0x04
    1cbe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1cc0:	eb 81       	ldd	r30, Y+3	; 0x03
    1cc2:	fc 81       	ldd	r31, Y+4	; 0x04
    1cc4:	88 e0       	ldi	r24, 0x08	; 8
    1cc6:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cc8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cca:	9c 81       	ldd	r25, Y+4	; 0x04
    1ccc:	01 97       	sbiw	r24, 0x01	; 1
    1cce:	9c 83       	std	Y+4, r25	; 0x04
    1cd0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1cd2:	eb 81       	ldd	r30, Y+3	; 0x03
    1cd4:	fc 81       	ldd	r31, Y+4	; 0x04
    1cd6:	89 e0       	ldi	r24, 0x09	; 9
    1cd8:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cda:	8b 81       	ldd	r24, Y+3	; 0x03
    1cdc:	9c 81       	ldd	r25, Y+4	; 0x04
    1cde:	01 97       	sbiw	r24, 0x01	; 1
    1ce0:	9c 83       	std	Y+4, r25	; 0x04
    1ce2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1ce4:	eb 81       	ldd	r30, Y+3	; 0x03
    1ce6:	fc 81       	ldd	r31, Y+4	; 0x04
    1ce8:	80 e1       	ldi	r24, 0x10	; 16
    1cea:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cec:	8b 81       	ldd	r24, Y+3	; 0x03
    1cee:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf0:	01 97       	sbiw	r24, 0x01	; 1
    1cf2:	9c 83       	std	Y+4, r25	; 0x04
    1cf4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1cf6:	eb 81       	ldd	r30, Y+3	; 0x03
    1cf8:	fc 81       	ldd	r31, Y+4	; 0x04
    1cfa:	81 e1       	ldi	r24, 0x11	; 17
    1cfc:	80 83       	st	Z, r24
	pxTopOfStack--;
    1cfe:	8b 81       	ldd	r24, Y+3	; 0x03
    1d00:	9c 81       	ldd	r25, Y+4	; 0x04
    1d02:	01 97       	sbiw	r24, 0x01	; 1
    1d04:	9c 83       	std	Y+4, r25	; 0x04
    1d06:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1d08:	eb 81       	ldd	r30, Y+3	; 0x03
    1d0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d0c:	82 e1       	ldi	r24, 0x12	; 18
    1d0e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d10:	8b 81       	ldd	r24, Y+3	; 0x03
    1d12:	9c 81       	ldd	r25, Y+4	; 0x04
    1d14:	01 97       	sbiw	r24, 0x01	; 1
    1d16:	9c 83       	std	Y+4, r25	; 0x04
    1d18:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1d1a:	eb 81       	ldd	r30, Y+3	; 0x03
    1d1c:	fc 81       	ldd	r31, Y+4	; 0x04
    1d1e:	83 e1       	ldi	r24, 0x13	; 19
    1d20:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d22:	8b 81       	ldd	r24, Y+3	; 0x03
    1d24:	9c 81       	ldd	r25, Y+4	; 0x04
    1d26:	01 97       	sbiw	r24, 0x01	; 1
    1d28:	9c 83       	std	Y+4, r25	; 0x04
    1d2a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1d2c:	eb 81       	ldd	r30, Y+3	; 0x03
    1d2e:	fc 81       	ldd	r31, Y+4	; 0x04
    1d30:	84 e1       	ldi	r24, 0x14	; 20
    1d32:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d34:	8b 81       	ldd	r24, Y+3	; 0x03
    1d36:	9c 81       	ldd	r25, Y+4	; 0x04
    1d38:	01 97       	sbiw	r24, 0x01	; 1
    1d3a:	9c 83       	std	Y+4, r25	; 0x04
    1d3c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1d3e:	eb 81       	ldd	r30, Y+3	; 0x03
    1d40:	fc 81       	ldd	r31, Y+4	; 0x04
    1d42:	85 e1       	ldi	r24, 0x15	; 21
    1d44:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d46:	8b 81       	ldd	r24, Y+3	; 0x03
    1d48:	9c 81       	ldd	r25, Y+4	; 0x04
    1d4a:	01 97       	sbiw	r24, 0x01	; 1
    1d4c:	9c 83       	std	Y+4, r25	; 0x04
    1d4e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1d50:	eb 81       	ldd	r30, Y+3	; 0x03
    1d52:	fc 81       	ldd	r31, Y+4	; 0x04
    1d54:	86 e1       	ldi	r24, 0x16	; 22
    1d56:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d58:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    1d5c:	01 97       	sbiw	r24, 0x01	; 1
    1d5e:	9c 83       	std	Y+4, r25	; 0x04
    1d60:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1d62:	eb 81       	ldd	r30, Y+3	; 0x03
    1d64:	fc 81       	ldd	r31, Y+4	; 0x04
    1d66:	87 e1       	ldi	r24, 0x17	; 23
    1d68:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d6e:	01 97       	sbiw	r24, 0x01	; 1
    1d70:	9c 83       	std	Y+4, r25	; 0x04
    1d72:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1d74:	eb 81       	ldd	r30, Y+3	; 0x03
    1d76:	fc 81       	ldd	r31, Y+4	; 0x04
    1d78:	88 e1       	ldi	r24, 0x18	; 24
    1d7a:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d80:	01 97       	sbiw	r24, 0x01	; 1
    1d82:	9c 83       	std	Y+4, r25	; 0x04
    1d84:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1d86:	eb 81       	ldd	r30, Y+3	; 0x03
    1d88:	fc 81       	ldd	r31, Y+4	; 0x04
    1d8a:	89 e1       	ldi	r24, 0x19	; 25
    1d8c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1d8e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d90:	9c 81       	ldd	r25, Y+4	; 0x04
    1d92:	01 97       	sbiw	r24, 0x01	; 1
    1d94:	9c 83       	std	Y+4, r25	; 0x04
    1d96:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1d98:	eb 81       	ldd	r30, Y+3	; 0x03
    1d9a:	fc 81       	ldd	r31, Y+4	; 0x04
    1d9c:	80 e2       	ldi	r24, 0x20	; 32
    1d9e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1da0:	8b 81       	ldd	r24, Y+3	; 0x03
    1da2:	9c 81       	ldd	r25, Y+4	; 0x04
    1da4:	01 97       	sbiw	r24, 0x01	; 1
    1da6:	9c 83       	std	Y+4, r25	; 0x04
    1da8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1daa:	eb 81       	ldd	r30, Y+3	; 0x03
    1dac:	fc 81       	ldd	r31, Y+4	; 0x04
    1dae:	81 e2       	ldi	r24, 0x21	; 33
    1db0:	80 83       	st	Z, r24
	pxTopOfStack--;
    1db2:	8b 81       	ldd	r24, Y+3	; 0x03
    1db4:	9c 81       	ldd	r25, Y+4	; 0x04
    1db6:	01 97       	sbiw	r24, 0x01	; 1
    1db8:	9c 83       	std	Y+4, r25	; 0x04
    1dba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1dbc:	eb 81       	ldd	r30, Y+3	; 0x03
    1dbe:	fc 81       	ldd	r31, Y+4	; 0x04
    1dc0:	82 e2       	ldi	r24, 0x22	; 34
    1dc2:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1dc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1dc8:	01 97       	sbiw	r24, 0x01	; 1
    1dca:	9c 83       	std	Y+4, r25	; 0x04
    1dcc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1dce:	eb 81       	ldd	r30, Y+3	; 0x03
    1dd0:	fc 81       	ldd	r31, Y+4	; 0x04
    1dd2:	83 e2       	ldi	r24, 0x23	; 35
    1dd4:	80 83       	st	Z, r24
	pxTopOfStack--;
    1dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    1dda:	01 97       	sbiw	r24, 0x01	; 1
    1ddc:	9c 83       	std	Y+4, r25	; 0x04
    1dde:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1de0:	8f 81       	ldd	r24, Y+7	; 0x07
    1de2:	98 85       	ldd	r25, Y+8	; 0x08
    1de4:	9a 83       	std	Y+2, r25	; 0x02
    1de6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1de8:	89 81       	ldd	r24, Y+1	; 0x01
    1dea:	eb 81       	ldd	r30, Y+3	; 0x03
    1dec:	fc 81       	ldd	r31, Y+4	; 0x04
    1dee:	80 83       	st	Z, r24
	pxTopOfStack--;
    1df0:	8b 81       	ldd	r24, Y+3	; 0x03
    1df2:	9c 81       	ldd	r25, Y+4	; 0x04
    1df4:	01 97       	sbiw	r24, 0x01	; 1
    1df6:	9c 83       	std	Y+4, r25	; 0x04
    1df8:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dfe:	89 2f       	mov	r24, r25
    1e00:	99 27       	eor	r25, r25
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1e06:	89 81       	ldd	r24, Y+1	; 0x01
    1e08:	eb 81       	ldd	r30, Y+3	; 0x03
    1e0a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e0c:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1e10:	9c 81       	ldd	r25, Y+4	; 0x04
    1e12:	01 97       	sbiw	r24, 0x01	; 1
    1e14:	9c 83       	std	Y+4, r25	; 0x04
    1e16:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1e18:	eb 81       	ldd	r30, Y+3	; 0x03
    1e1a:	fc 81       	ldd	r31, Y+4	; 0x04
    1e1c:	86 e2       	ldi	r24, 0x26	; 38
    1e1e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e20:	8b 81       	ldd	r24, Y+3	; 0x03
    1e22:	9c 81       	ldd	r25, Y+4	; 0x04
    1e24:	01 97       	sbiw	r24, 0x01	; 1
    1e26:	9c 83       	std	Y+4, r25	; 0x04
    1e28:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1e2a:	eb 81       	ldd	r30, Y+3	; 0x03
    1e2c:	fc 81       	ldd	r31, Y+4	; 0x04
    1e2e:	87 e2       	ldi	r24, 0x27	; 39
    1e30:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e32:	8b 81       	ldd	r24, Y+3	; 0x03
    1e34:	9c 81       	ldd	r25, Y+4	; 0x04
    1e36:	01 97       	sbiw	r24, 0x01	; 1
    1e38:	9c 83       	std	Y+4, r25	; 0x04
    1e3a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1e3c:	eb 81       	ldd	r30, Y+3	; 0x03
    1e3e:	fc 81       	ldd	r31, Y+4	; 0x04
    1e40:	88 e2       	ldi	r24, 0x28	; 40
    1e42:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e44:	8b 81       	ldd	r24, Y+3	; 0x03
    1e46:	9c 81       	ldd	r25, Y+4	; 0x04
    1e48:	01 97       	sbiw	r24, 0x01	; 1
    1e4a:	9c 83       	std	Y+4, r25	; 0x04
    1e4c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1e4e:	eb 81       	ldd	r30, Y+3	; 0x03
    1e50:	fc 81       	ldd	r31, Y+4	; 0x04
    1e52:	89 e2       	ldi	r24, 0x29	; 41
    1e54:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e56:	8b 81       	ldd	r24, Y+3	; 0x03
    1e58:	9c 81       	ldd	r25, Y+4	; 0x04
    1e5a:	01 97       	sbiw	r24, 0x01	; 1
    1e5c:	9c 83       	std	Y+4, r25	; 0x04
    1e5e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1e60:	eb 81       	ldd	r30, Y+3	; 0x03
    1e62:	fc 81       	ldd	r31, Y+4	; 0x04
    1e64:	80 e3       	ldi	r24, 0x30	; 48
    1e66:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e68:	8b 81       	ldd	r24, Y+3	; 0x03
    1e6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1e6c:	01 97       	sbiw	r24, 0x01	; 1
    1e6e:	9c 83       	std	Y+4, r25	; 0x04
    1e70:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1e72:	eb 81       	ldd	r30, Y+3	; 0x03
    1e74:	fc 81       	ldd	r31, Y+4	; 0x04
    1e76:	81 e3       	ldi	r24, 0x31	; 49
    1e78:	80 83       	st	Z, r24
	pxTopOfStack--;
    1e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1e7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7e:	01 97       	sbiw	r24, 0x01	; 1
    1e80:	9c 83       	std	Y+4, r25	; 0x04
    1e82:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1e84:	8b 81       	ldd	r24, Y+3	; 0x03
    1e86:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1e88:	28 96       	adiw	r28, 0x08	; 8
    1e8a:	0f b6       	in	r0, 0x3f	; 63
    1e8c:	f8 94       	cli
    1e8e:	de bf       	out	0x3e, r29	; 62
    1e90:	0f be       	out	0x3f, r0	; 63
    1e92:	cd bf       	out	0x3d, r28	; 61
    1e94:	cf 91       	pop	r28
    1e96:	df 91       	pop	r29
    1e98:	08 95       	ret

00001e9a <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1e9a:	df 93       	push	r29
    1e9c:	cf 93       	push	r28
    1e9e:	cd b7       	in	r28, 0x3d	; 61
    1ea0:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1ea2:	0e 94 3d 10 	call	0x207a	; 0x207a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1ea6:	a0 91 34 03 	lds	r26, 0x0334
    1eaa:	b0 91 35 03 	lds	r27, 0x0335
    1eae:	cd 91       	ld	r28, X+
    1eb0:	cd bf       	out	0x3d, r28	; 61
    1eb2:	dd 91       	ld	r29, X+
    1eb4:	de bf       	out	0x3e, r29	; 62
    1eb6:	ff 91       	pop	r31
    1eb8:	ef 91       	pop	r30
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	bf 91       	pop	r27
    1ec0:	af 91       	pop	r26
    1ec2:	9f 91       	pop	r25
    1ec4:	8f 91       	pop	r24
    1ec6:	7f 91       	pop	r23
    1ec8:	6f 91       	pop	r22
    1eca:	5f 91       	pop	r21
    1ecc:	4f 91       	pop	r20
    1ece:	3f 91       	pop	r19
    1ed0:	2f 91       	pop	r18
    1ed2:	1f 91       	pop	r17
    1ed4:	0f 91       	pop	r16
    1ed6:	ff 90       	pop	r15
    1ed8:	ef 90       	pop	r14
    1eda:	df 90       	pop	r13
    1edc:	cf 90       	pop	r12
    1ede:	bf 90       	pop	r11
    1ee0:	af 90       	pop	r10
    1ee2:	9f 90       	pop	r9
    1ee4:	8f 90       	pop	r8
    1ee6:	7f 90       	pop	r7
    1ee8:	6f 90       	pop	r6
    1eea:	5f 90       	pop	r5
    1eec:	4f 90       	pop	r4
    1eee:	3f 90       	pop	r3
    1ef0:	2f 90       	pop	r2
    1ef2:	1f 90       	pop	r1
    1ef4:	0f 90       	pop	r0
    1ef6:	0f be       	out	0x3f, r0	; 63
    1ef8:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1efa:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1efc:	81 e0       	ldi	r24, 0x01	; 1
}
    1efe:	cf 91       	pop	r28
    1f00:	df 91       	pop	r29
    1f02:	08 95       	ret

00001f04 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1f04:	df 93       	push	r29
    1f06:	cf 93       	push	r28
    1f08:	cd b7       	in	r28, 0x3d	; 61
    1f0a:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1f0c:	cf 91       	pop	r28
    1f0e:	df 91       	pop	r29
    1f10:	08 95       	ret

00001f12 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1f12:	0f 92       	push	r0
    1f14:	0f b6       	in	r0, 0x3f	; 63
    1f16:	f8 94       	cli
    1f18:	0f 92       	push	r0
    1f1a:	1f 92       	push	r1
    1f1c:	11 24       	eor	r1, r1
    1f1e:	2f 92       	push	r2
    1f20:	3f 92       	push	r3
    1f22:	4f 92       	push	r4
    1f24:	5f 92       	push	r5
    1f26:	6f 92       	push	r6
    1f28:	7f 92       	push	r7
    1f2a:	8f 92       	push	r8
    1f2c:	9f 92       	push	r9
    1f2e:	af 92       	push	r10
    1f30:	bf 92       	push	r11
    1f32:	cf 92       	push	r12
    1f34:	df 92       	push	r13
    1f36:	ef 92       	push	r14
    1f38:	ff 92       	push	r15
    1f3a:	0f 93       	push	r16
    1f3c:	1f 93       	push	r17
    1f3e:	2f 93       	push	r18
    1f40:	3f 93       	push	r19
    1f42:	4f 93       	push	r20
    1f44:	5f 93       	push	r21
    1f46:	6f 93       	push	r22
    1f48:	7f 93       	push	r23
    1f4a:	8f 93       	push	r24
    1f4c:	9f 93       	push	r25
    1f4e:	af 93       	push	r26
    1f50:	bf 93       	push	r27
    1f52:	cf 93       	push	r28
    1f54:	df 93       	push	r29
    1f56:	ef 93       	push	r30
    1f58:	ff 93       	push	r31
    1f5a:	a0 91 34 03 	lds	r26, 0x0334
    1f5e:	b0 91 35 03 	lds	r27, 0x0335
    1f62:	0d b6       	in	r0, 0x3d	; 61
    1f64:	0d 92       	st	X+, r0
    1f66:	0e b6       	in	r0, 0x3e	; 62
    1f68:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f6a:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1f6e:	a0 91 34 03 	lds	r26, 0x0334
    1f72:	b0 91 35 03 	lds	r27, 0x0335
    1f76:	cd 91       	ld	r28, X+
    1f78:	cd bf       	out	0x3d, r28	; 61
    1f7a:	dd 91       	ld	r29, X+
    1f7c:	de bf       	out	0x3e, r29	; 62
    1f7e:	ff 91       	pop	r31
    1f80:	ef 91       	pop	r30
    1f82:	df 91       	pop	r29
    1f84:	cf 91       	pop	r28
    1f86:	bf 91       	pop	r27
    1f88:	af 91       	pop	r26
    1f8a:	9f 91       	pop	r25
    1f8c:	8f 91       	pop	r24
    1f8e:	7f 91       	pop	r23
    1f90:	6f 91       	pop	r22
    1f92:	5f 91       	pop	r21
    1f94:	4f 91       	pop	r20
    1f96:	3f 91       	pop	r19
    1f98:	2f 91       	pop	r18
    1f9a:	1f 91       	pop	r17
    1f9c:	0f 91       	pop	r16
    1f9e:	ff 90       	pop	r15
    1fa0:	ef 90       	pop	r14
    1fa2:	df 90       	pop	r13
    1fa4:	cf 90       	pop	r12
    1fa6:	bf 90       	pop	r11
    1fa8:	af 90       	pop	r10
    1faa:	9f 90       	pop	r9
    1fac:	8f 90       	pop	r8
    1fae:	7f 90       	pop	r7
    1fb0:	6f 90       	pop	r6
    1fb2:	5f 90       	pop	r5
    1fb4:	4f 90       	pop	r4
    1fb6:	3f 90       	pop	r3
    1fb8:	2f 90       	pop	r2
    1fba:	1f 90       	pop	r1
    1fbc:	0f 90       	pop	r0
    1fbe:	0f be       	out	0x3f, r0	; 63
    1fc0:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1fc2:	08 95       	ret

00001fc4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1fc4:	0f 92       	push	r0
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	f8 94       	cli
    1fca:	0f 92       	push	r0
    1fcc:	1f 92       	push	r1
    1fce:	11 24       	eor	r1, r1
    1fd0:	2f 92       	push	r2
    1fd2:	3f 92       	push	r3
    1fd4:	4f 92       	push	r4
    1fd6:	5f 92       	push	r5
    1fd8:	6f 92       	push	r6
    1fda:	7f 92       	push	r7
    1fdc:	8f 92       	push	r8
    1fde:	9f 92       	push	r9
    1fe0:	af 92       	push	r10
    1fe2:	bf 92       	push	r11
    1fe4:	cf 92       	push	r12
    1fe6:	df 92       	push	r13
    1fe8:	ef 92       	push	r14
    1fea:	ff 92       	push	r15
    1fec:	0f 93       	push	r16
    1fee:	1f 93       	push	r17
    1ff0:	2f 93       	push	r18
    1ff2:	3f 93       	push	r19
    1ff4:	4f 93       	push	r20
    1ff6:	5f 93       	push	r21
    1ff8:	6f 93       	push	r22
    1ffa:	7f 93       	push	r23
    1ffc:	8f 93       	push	r24
    1ffe:	9f 93       	push	r25
    2000:	af 93       	push	r26
    2002:	bf 93       	push	r27
    2004:	cf 93       	push	r28
    2006:	df 93       	push	r29
    2008:	ef 93       	push	r30
    200a:	ff 93       	push	r31
    200c:	a0 91 34 03 	lds	r26, 0x0334
    2010:	b0 91 35 03 	lds	r27, 0x0335
    2014:	0d b6       	in	r0, 0x3d	; 61
    2016:	0d 92       	st	X+, r0
    2018:	0e b6       	in	r0, 0x3e	; 62
    201a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    201c:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskIncrementTick>
	vTaskSwitchContext();
    2020:	0e 94 f9 18 	call	0x31f2	; 0x31f2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2024:	a0 91 34 03 	lds	r26, 0x0334
    2028:	b0 91 35 03 	lds	r27, 0x0335
    202c:	cd 91       	ld	r28, X+
    202e:	cd bf       	out	0x3d, r28	; 61
    2030:	dd 91       	ld	r29, X+
    2032:	de bf       	out	0x3e, r29	; 62
    2034:	ff 91       	pop	r31
    2036:	ef 91       	pop	r30
    2038:	df 91       	pop	r29
    203a:	cf 91       	pop	r28
    203c:	bf 91       	pop	r27
    203e:	af 91       	pop	r26
    2040:	9f 91       	pop	r25
    2042:	8f 91       	pop	r24
    2044:	7f 91       	pop	r23
    2046:	6f 91       	pop	r22
    2048:	5f 91       	pop	r21
    204a:	4f 91       	pop	r20
    204c:	3f 91       	pop	r19
    204e:	2f 91       	pop	r18
    2050:	1f 91       	pop	r17
    2052:	0f 91       	pop	r16
    2054:	ff 90       	pop	r15
    2056:	ef 90       	pop	r14
    2058:	df 90       	pop	r13
    205a:	cf 90       	pop	r12
    205c:	bf 90       	pop	r11
    205e:	af 90       	pop	r10
    2060:	9f 90       	pop	r9
    2062:	8f 90       	pop	r8
    2064:	7f 90       	pop	r7
    2066:	6f 90       	pop	r6
    2068:	5f 90       	pop	r5
    206a:	4f 90       	pop	r4
    206c:	3f 90       	pop	r3
    206e:	2f 90       	pop	r2
    2070:	1f 90       	pop	r1
    2072:	0f 90       	pop	r0
    2074:	0f be       	out	0x3f, r0	; 63
    2076:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2078:	08 95       	ret

0000207a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    207a:	df 93       	push	r29
    207c:	cf 93       	push	r28
    207e:	00 d0       	rcall	.+0      	; 0x2080 <prvSetupTimerInterrupt+0x6>
    2080:	00 d0       	rcall	.+0      	; 0x2082 <prvSetupTimerInterrupt+0x8>
    2082:	00 d0       	rcall	.+0      	; 0x2084 <prvSetupTimerInterrupt+0xa>
    2084:	cd b7       	in	r28, 0x3d	; 61
    2086:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    2088:	80 e4       	ldi	r24, 0x40	; 64
    208a:	9f e1       	ldi	r25, 0x1F	; 31
    208c:	a0 e0       	ldi	r26, 0x00	; 0
    208e:	b0 e0       	ldi	r27, 0x00	; 0
    2090:	8b 83       	std	Y+3, r24	; 0x03
    2092:	9c 83       	std	Y+4, r25	; 0x04
    2094:	ad 83       	std	Y+5, r26	; 0x05
    2096:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    2098:	8b 81       	ldd	r24, Y+3	; 0x03
    209a:	9c 81       	ldd	r25, Y+4	; 0x04
    209c:	ad 81       	ldd	r26, Y+5	; 0x05
    209e:	be 81       	ldd	r27, Y+6	; 0x06
    20a0:	68 94       	set
    20a2:	15 f8       	bld	r1, 5
    20a4:	b6 95       	lsr	r27
    20a6:	a7 95       	ror	r26
    20a8:	97 95       	ror	r25
    20aa:	87 95       	ror	r24
    20ac:	16 94       	lsr	r1
    20ae:	d1 f7       	brne	.-12     	; 0x20a4 <prvSetupTimerInterrupt+0x2a>
    20b0:	8b 83       	std	Y+3, r24	; 0x03
    20b2:	9c 83       	std	Y+4, r25	; 0x04
    20b4:	ad 83       	std	Y+5, r26	; 0x05
    20b6:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    20b8:	8b 81       	ldd	r24, Y+3	; 0x03
    20ba:	9c 81       	ldd	r25, Y+4	; 0x04
    20bc:	ad 81       	ldd	r26, Y+5	; 0x05
    20be:	be 81       	ldd	r27, Y+6	; 0x06
    20c0:	01 97       	sbiw	r24, 0x01	; 1
    20c2:	a1 09       	sbc	r26, r1
    20c4:	b1 09       	sbc	r27, r1
    20c6:	8b 83       	std	Y+3, r24	; 0x03
    20c8:	9c 83       	std	Y+4, r25	; 0x04
    20ca:	ad 83       	std	Y+5, r26	; 0x05
    20cc:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    20ce:	8b 81       	ldd	r24, Y+3	; 0x03
    20d0:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    20d2:	8b 81       	ldd	r24, Y+3	; 0x03
    20d4:	9c 81       	ldd	r25, Y+4	; 0x04
    20d6:	ad 81       	ldd	r26, Y+5	; 0x05
    20d8:	be 81       	ldd	r27, Y+6	; 0x06
    20da:	89 2f       	mov	r24, r25
    20dc:	9a 2f       	mov	r25, r26
    20de:	ab 2f       	mov	r26, r27
    20e0:	bb 27       	eor	r27, r27
    20e2:	8b 83       	std	Y+3, r24	; 0x03
    20e4:	9c 83       	std	Y+4, r25	; 0x04
    20e6:	ad 83       	std	Y+5, r26	; 0x05
    20e8:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    20ea:	8b 81       	ldd	r24, Y+3	; 0x03
    20ec:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    20ee:	eb e4       	ldi	r30, 0x4B	; 75
    20f0:	f0 e0       	ldi	r31, 0x00	; 0
    20f2:	8a 81       	ldd	r24, Y+2	; 0x02
    20f4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    20f6:	ea e4       	ldi	r30, 0x4A	; 74
    20f8:	f0 e0       	ldi	r31, 0x00	; 0
    20fa:	89 81       	ldd	r24, Y+1	; 0x01
    20fc:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    20fe:	8b e0       	ldi	r24, 0x0B	; 11
    2100:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    2102:	ee e4       	ldi	r30, 0x4E	; 78
    2104:	f0 e0       	ldi	r31, 0x00	; 0
    2106:	89 81       	ldd	r24, Y+1	; 0x01
    2108:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    210a:	e9 e5       	ldi	r30, 0x59	; 89
    210c:	f0 e0       	ldi	r31, 0x00	; 0
    210e:	80 81       	ld	r24, Z
    2110:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    2112:	89 81       	ldd	r24, Y+1	; 0x01
    2114:	80 61       	ori	r24, 0x10	; 16
    2116:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    2118:	e9 e5       	ldi	r30, 0x59	; 89
    211a:	f0 e0       	ldi	r31, 0x00	; 0
    211c:	89 81       	ldd	r24, Y+1	; 0x01
    211e:	80 83       	st	Z, r24
}
    2120:	26 96       	adiw	r28, 0x06	; 6
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	de bf       	out	0x3e, r29	; 62
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	cd bf       	out	0x3d, r28	; 61
    212c:	cf 91       	pop	r28
    212e:	df 91       	pop	r29
    2130:	08 95       	ret

00002132 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    2132:	0e 94 e2 0f 	call	0x1fc4	; 0x1fc4 <vPortYieldFromTick>
		asm volatile ( "reti" );
    2136:	18 95       	reti

00002138 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    2138:	df 93       	push	r29
    213a:	cf 93       	push	r28
    213c:	cd b7       	in	r28, 0x3d	; 61
    213e:	de b7       	in	r29, 0x3e	; 62
    2140:	28 97       	sbiw	r28, 0x08	; 8
    2142:	0f b6       	in	r0, 0x3f	; 63
    2144:	f8 94       	cli
    2146:	de bf       	out	0x3e, r29	; 62
    2148:	0f be       	out	0x3f, r0	; 63
    214a:	cd bf       	out	0x3d, r28	; 61
    214c:	8f 83       	std	Y+7, r24	; 0x07
    214e:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    2150:	1a 82       	std	Y+2, r1	; 0x02
    2152:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2154:	8f 81       	ldd	r24, Y+7	; 0x07
    2156:	88 23       	and	r24, r24
    2158:	09 f4       	brne	.+2      	; 0x215c <xQueueCreate+0x24>
    215a:	8c c0       	rjmp	.+280    	; 0x2274 <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    215c:	8f e1       	ldi	r24, 0x1F	; 31
    215e:	90 e0       	ldi	r25, 0x00	; 0
    2160:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <pvPortMalloc>
    2164:	9e 83       	std	Y+6, r25	; 0x06
    2166:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    2168:	8d 81       	ldd	r24, Y+5	; 0x05
    216a:	9e 81       	ldd	r25, Y+6	; 0x06
    216c:	00 97       	sbiw	r24, 0x00	; 0
    216e:	09 f4       	brne	.+2      	; 0x2172 <xQueueCreate+0x3a>
    2170:	81 c0       	rjmp	.+258    	; 0x2274 <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2172:	8f 81       	ldd	r24, Y+7	; 0x07
    2174:	28 2f       	mov	r18, r24
    2176:	30 e0       	ldi	r19, 0x00	; 0
    2178:	88 85       	ldd	r24, Y+8	; 0x08
    217a:	88 2f       	mov	r24, r24
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	ac 01       	movw	r20, r24
    2180:	24 9f       	mul	r18, r20
    2182:	c0 01       	movw	r24, r0
    2184:	25 9f       	mul	r18, r21
    2186:	90 0d       	add	r25, r0
    2188:	34 9f       	mul	r19, r20
    218a:	90 0d       	add	r25, r0
    218c:	11 24       	eor	r1, r1
    218e:	01 96       	adiw	r24, 0x01	; 1
    2190:	9c 83       	std	Y+4, r25	; 0x04
    2192:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2194:	8b 81       	ldd	r24, Y+3	; 0x03
    2196:	9c 81       	ldd	r25, Y+4	; 0x04
    2198:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <pvPortMalloc>
    219c:	ed 81       	ldd	r30, Y+5	; 0x05
    219e:	fe 81       	ldd	r31, Y+6	; 0x06
    21a0:	91 83       	std	Z+1, r25	; 0x01
    21a2:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    21a4:	ed 81       	ldd	r30, Y+5	; 0x05
    21a6:	fe 81       	ldd	r31, Y+6	; 0x06
    21a8:	80 81       	ld	r24, Z
    21aa:	91 81       	ldd	r25, Z+1	; 0x01
    21ac:	00 97       	sbiw	r24, 0x00	; 0
    21ae:	09 f4       	brne	.+2      	; 0x21b2 <xQueueCreate+0x7a>
    21b0:	5d c0       	rjmp	.+186    	; 0x226c <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    21b2:	ed 81       	ldd	r30, Y+5	; 0x05
    21b4:	fe 81       	ldd	r31, Y+6	; 0x06
    21b6:	40 81       	ld	r20, Z
    21b8:	51 81       	ldd	r21, Z+1	; 0x01
    21ba:	8f 81       	ldd	r24, Y+7	; 0x07
    21bc:	28 2f       	mov	r18, r24
    21be:	30 e0       	ldi	r19, 0x00	; 0
    21c0:	88 85       	ldd	r24, Y+8	; 0x08
    21c2:	88 2f       	mov	r24, r24
    21c4:	90 e0       	ldi	r25, 0x00	; 0
    21c6:	bc 01       	movw	r22, r24
    21c8:	26 9f       	mul	r18, r22
    21ca:	c0 01       	movw	r24, r0
    21cc:	27 9f       	mul	r18, r23
    21ce:	90 0d       	add	r25, r0
    21d0:	36 9f       	mul	r19, r22
    21d2:	90 0d       	add	r25, r0
    21d4:	11 24       	eor	r1, r1
    21d6:	84 0f       	add	r24, r20
    21d8:	95 1f       	adc	r25, r21
    21da:	ed 81       	ldd	r30, Y+5	; 0x05
    21dc:	fe 81       	ldd	r31, Y+6	; 0x06
    21de:	93 83       	std	Z+3, r25	; 0x03
    21e0:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    21e2:	ed 81       	ldd	r30, Y+5	; 0x05
    21e4:	fe 81       	ldd	r31, Y+6	; 0x06
    21e6:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    21e8:	ed 81       	ldd	r30, Y+5	; 0x05
    21ea:	fe 81       	ldd	r31, Y+6	; 0x06
    21ec:	80 81       	ld	r24, Z
    21ee:	91 81       	ldd	r25, Z+1	; 0x01
    21f0:	ed 81       	ldd	r30, Y+5	; 0x05
    21f2:	fe 81       	ldd	r31, Y+6	; 0x06
    21f4:	95 83       	std	Z+5, r25	; 0x05
    21f6:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    21f8:	ed 81       	ldd	r30, Y+5	; 0x05
    21fa:	fe 81       	ldd	r31, Y+6	; 0x06
    21fc:	40 81       	ld	r20, Z
    21fe:	51 81       	ldd	r21, Z+1	; 0x01
    2200:	8f 81       	ldd	r24, Y+7	; 0x07
    2202:	88 2f       	mov	r24, r24
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	9c 01       	movw	r18, r24
    2208:	21 50       	subi	r18, 0x01	; 1
    220a:	30 40       	sbci	r19, 0x00	; 0
    220c:	88 85       	ldd	r24, Y+8	; 0x08
    220e:	88 2f       	mov	r24, r24
    2210:	90 e0       	ldi	r25, 0x00	; 0
    2212:	bc 01       	movw	r22, r24
    2214:	26 9f       	mul	r18, r22
    2216:	c0 01       	movw	r24, r0
    2218:	27 9f       	mul	r18, r23
    221a:	90 0d       	add	r25, r0
    221c:	36 9f       	mul	r19, r22
    221e:	90 0d       	add	r25, r0
    2220:	11 24       	eor	r1, r1
    2222:	84 0f       	add	r24, r20
    2224:	95 1f       	adc	r25, r21
    2226:	ed 81       	ldd	r30, Y+5	; 0x05
    2228:	fe 81       	ldd	r31, Y+6	; 0x06
    222a:	97 83       	std	Z+7, r25	; 0x07
    222c:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    222e:	ed 81       	ldd	r30, Y+5	; 0x05
    2230:	fe 81       	ldd	r31, Y+6	; 0x06
    2232:	8f 81       	ldd	r24, Y+7	; 0x07
    2234:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2236:	ed 81       	ldd	r30, Y+5	; 0x05
    2238:	fe 81       	ldd	r31, Y+6	; 0x06
    223a:	88 85       	ldd	r24, Y+8	; 0x08
    223c:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    223e:	ed 81       	ldd	r30, Y+5	; 0x05
    2240:	fe 81       	ldd	r31, Y+6	; 0x06
    2242:	8f ef       	ldi	r24, 0xFF	; 255
    2244:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    2246:	ed 81       	ldd	r30, Y+5	; 0x05
    2248:	fe 81       	ldd	r31, Y+6	; 0x06
    224a:	8f ef       	ldi	r24, 0xFF	; 255
    224c:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    224e:	8d 81       	ldd	r24, Y+5	; 0x05
    2250:	9e 81       	ldd	r25, Y+6	; 0x06
    2252:	08 96       	adiw	r24, 0x08	; 8
    2254:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    2258:	8d 81       	ldd	r24, Y+5	; 0x05
    225a:	9e 81       	ldd	r25, Y+6	; 0x06
    225c:	41 96       	adiw	r24, 0x11	; 17
    225e:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2262:	8d 81       	ldd	r24, Y+5	; 0x05
    2264:	9e 81       	ldd	r25, Y+6	; 0x06
    2266:	9a 83       	std	Y+2, r25	; 0x02
    2268:	89 83       	std	Y+1, r24	; 0x01
    226a:	04 c0       	rjmp	.+8      	; 0x2274 <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    226c:	8d 81       	ldd	r24, Y+5	; 0x05
    226e:	9e 81       	ldd	r25, Y+6	; 0x06
    2270:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    2274:	89 81       	ldd	r24, Y+1	; 0x01
    2276:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2278:	28 96       	adiw	r28, 0x08	; 8
    227a:	0f b6       	in	r0, 0x3f	; 63
    227c:	f8 94       	cli
    227e:	de bf       	out	0x3e, r29	; 62
    2280:	0f be       	out	0x3f, r0	; 63
    2282:	cd bf       	out	0x3d, r28	; 61
    2284:	cf 91       	pop	r28
    2286:	df 91       	pop	r29
    2288:	08 95       	ret

0000228a <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    228a:	df 93       	push	r29
    228c:	cf 93       	push	r28
    228e:	cd b7       	in	r28, 0x3d	; 61
    2290:	de b7       	in	r29, 0x3e	; 62
    2292:	2c 97       	sbiw	r28, 0x0c	; 12
    2294:	0f b6       	in	r0, 0x3f	; 63
    2296:	f8 94       	cli
    2298:	de bf       	out	0x3e, r29	; 62
    229a:	0f be       	out	0x3f, r0	; 63
    229c:	cd bf       	out	0x3d, r28	; 61
    229e:	9e 83       	std	Y+6, r25	; 0x06
    22a0:	8d 83       	std	Y+5, r24	; 0x05
    22a2:	78 87       	std	Y+8, r23	; 0x08
    22a4:	6f 83       	std	Y+7, r22	; 0x07
    22a6:	5a 87       	std	Y+10, r21	; 0x0a
    22a8:	49 87       	std	Y+9, r20	; 0x09
    22aa:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    22ac:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    22ae:	0f b6       	in	r0, 0x3f	; 63
    22b0:	f8 94       	cli
    22b2:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    22b4:	ed 81       	ldd	r30, Y+5	; 0x05
    22b6:	fe 81       	ldd	r31, Y+6	; 0x06
    22b8:	92 8d       	ldd	r25, Z+26	; 0x1a
    22ba:	ed 81       	ldd	r30, Y+5	; 0x05
    22bc:	fe 81       	ldd	r31, Y+6	; 0x06
    22be:	83 8d       	ldd	r24, Z+27	; 0x1b
    22c0:	98 17       	cp	r25, r24
    22c2:	d8 f4       	brcc	.+54     	; 0x22fa <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    22c4:	8d 81       	ldd	r24, Y+5	; 0x05
    22c6:	9e 81       	ldd	r25, Y+6	; 0x06
    22c8:	2f 81       	ldd	r18, Y+7	; 0x07
    22ca:	38 85       	ldd	r19, Y+8	; 0x08
    22cc:	b9 01       	movw	r22, r18
    22ce:	4b 85       	ldd	r20, Y+11	; 0x0b
    22d0:	0e 94 80 13 	call	0x2700	; 0x2700 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    22d4:	ed 81       	ldd	r30, Y+5	; 0x05
    22d6:	fe 81       	ldd	r31, Y+6	; 0x06
    22d8:	81 89       	ldd	r24, Z+17	; 0x11
    22da:	88 23       	and	r24, r24
    22dc:	49 f0       	breq	.+18     	; 0x22f0 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    22de:	8d 81       	ldd	r24, Y+5	; 0x05
    22e0:	9e 81       	ldd	r25, Y+6	; 0x06
    22e2:	41 96       	adiw	r24, 0x11	; 17
    22e4:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    22e8:	81 30       	cpi	r24, 0x01	; 1
    22ea:	11 f4       	brne	.+4      	; 0x22f0 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    22ec:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    22f0:	0f 90       	pop	r0
    22f2:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	8c 87       	std	Y+12, r24	; 0x0c
    22f8:	5c c0       	rjmp	.+184    	; 0x23b2 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    22fa:	89 85       	ldd	r24, Y+9	; 0x09
    22fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    22fe:	00 97       	sbiw	r24, 0x00	; 0
    2300:	21 f4       	brne	.+8      	; 0x230a <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    2306:	1c 86       	std	Y+12, r1	; 0x0c
    2308:	54 c0       	rjmp	.+168    	; 0x23b2 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    230a:	89 81       	ldd	r24, Y+1	; 0x01
    230c:	88 23       	and	r24, r24
    230e:	31 f4       	brne	.+12     	; 0x231c <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2310:	ce 01       	movw	r24, r28
    2312:	02 96       	adiw	r24, 0x02	; 2
    2314:	0e 94 fd 19 	call	0x33fa	; 0x33fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2318:	81 e0       	ldi	r24, 0x01	; 1
    231a:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    231c:	0f 90       	pop	r0
    231e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2320:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2324:	0f b6       	in	r0, 0x3f	; 63
    2326:	f8 94       	cli
    2328:	0f 92       	push	r0
    232a:	ed 81       	ldd	r30, Y+5	; 0x05
    232c:	fe 81       	ldd	r31, Y+6	; 0x06
    232e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2330:	8f 3f       	cpi	r24, 0xFF	; 255
    2332:	19 f4       	brne	.+6      	; 0x233a <xQueueGenericSend+0xb0>
    2334:	ed 81       	ldd	r30, Y+5	; 0x05
    2336:	fe 81       	ldd	r31, Y+6	; 0x06
    2338:	15 8e       	std	Z+29, r1	; 0x1d
    233a:	ed 81       	ldd	r30, Y+5	; 0x05
    233c:	fe 81       	ldd	r31, Y+6	; 0x06
    233e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2340:	8f 3f       	cpi	r24, 0xFF	; 255
    2342:	19 f4       	brne	.+6      	; 0x234a <xQueueGenericSend+0xc0>
    2344:	ed 81       	ldd	r30, Y+5	; 0x05
    2346:	fe 81       	ldd	r31, Y+6	; 0x06
    2348:	16 8e       	std	Z+30, r1	; 0x1e
    234a:	0f 90       	pop	r0
    234c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    234e:	ce 01       	movw	r24, r28
    2350:	02 96       	adiw	r24, 0x02	; 2
    2352:	9e 01       	movw	r18, r28
    2354:	27 5f       	subi	r18, 0xF7	; 247
    2356:	3f 4f       	sbci	r19, 0xFF	; 255
    2358:	b9 01       	movw	r22, r18
    235a:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskCheckForTimeOut>
    235e:	88 23       	and	r24, r24
    2360:	09 f5       	brne	.+66     	; 0x23a4 <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2362:	8d 81       	ldd	r24, Y+5	; 0x05
    2364:	9e 81       	ldd	r25, Y+6	; 0x06
    2366:	0e 94 e4 14 	call	0x29c8	; 0x29c8 <prvIsQueueFull>
    236a:	88 23       	and	r24, r24
    236c:	a1 f0       	breq	.+40     	; 0x2396 <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    236e:	8d 81       	ldd	r24, Y+5	; 0x05
    2370:	9e 81       	ldd	r25, Y+6	; 0x06
    2372:	08 96       	adiw	r24, 0x08	; 8
    2374:	29 85       	ldd	r18, Y+9	; 0x09
    2376:	3a 85       	ldd	r19, Y+10	; 0x0a
    2378:	b9 01       	movw	r22, r18
    237a:	0e 94 5f 19 	call	0x32be	; 0x32be <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    237e:	8d 81       	ldd	r24, Y+5	; 0x05
    2380:	9e 81       	ldd	r25, Y+6	; 0x06
    2382:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2386:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    238a:	88 23       	and	r24, r24
    238c:	09 f0       	breq	.+2      	; 0x2390 <xQueueGenericSend+0x106>
    238e:	8f cf       	rjmp	.-226    	; 0x22ae <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    2390:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
    2394:	8c cf       	rjmp	.-232    	; 0x22ae <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2396:	8d 81       	ldd	r24, Y+5	; 0x05
    2398:	9e 81       	ldd	r25, Y+6	; 0x06
    239a:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    239e:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    23a2:	85 cf       	rjmp	.-246    	; 0x22ae <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    23a4:	8d 81       	ldd	r24, Y+5	; 0x05
    23a6:	9e 81       	ldd	r25, Y+6	; 0x06
    23a8:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    23ac:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    23b0:	1c 86       	std	Y+12, r1	; 0x0c
    23b2:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    23b4:	2c 96       	adiw	r28, 0x0c	; 12
    23b6:	0f b6       	in	r0, 0x3f	; 63
    23b8:	f8 94       	cli
    23ba:	de bf       	out	0x3e, r29	; 62
    23bc:	0f be       	out	0x3f, r0	; 63
    23be:	cd bf       	out	0x3d, r28	; 61
    23c0:	cf 91       	pop	r28
    23c2:	df 91       	pop	r29
    23c4:	08 95       	ret

000023c6 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    23c6:	df 93       	push	r29
    23c8:	cf 93       	push	r28
    23ca:	cd b7       	in	r28, 0x3d	; 61
    23cc:	de b7       	in	r29, 0x3e	; 62
    23ce:	29 97       	sbiw	r28, 0x09	; 9
    23d0:	0f b6       	in	r0, 0x3f	; 63
    23d2:	f8 94       	cli
    23d4:	de bf       	out	0x3e, r29	; 62
    23d6:	0f be       	out	0x3f, r0	; 63
    23d8:	cd bf       	out	0x3d, r28	; 61
    23da:	9c 83       	std	Y+4, r25	; 0x04
    23dc:	8b 83       	std	Y+3, r24	; 0x03
    23de:	7e 83       	std	Y+6, r23	; 0x06
    23e0:	6d 83       	std	Y+5, r22	; 0x05
    23e2:	58 87       	std	Y+8, r21	; 0x08
    23e4:	4f 83       	std	Y+7, r20	; 0x07
    23e6:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    23e8:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    23ea:	eb 81       	ldd	r30, Y+3	; 0x03
    23ec:	fc 81       	ldd	r31, Y+4	; 0x04
    23ee:	92 8d       	ldd	r25, Z+26	; 0x1a
    23f0:	eb 81       	ldd	r30, Y+3	; 0x03
    23f2:	fc 81       	ldd	r31, Y+4	; 0x04
    23f4:	83 8d       	ldd	r24, Z+27	; 0x1b
    23f6:	98 17       	cp	r25, r24
    23f8:	40 f5       	brcc	.+80     	; 0x244a <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    23fa:	8b 81       	ldd	r24, Y+3	; 0x03
    23fc:	9c 81       	ldd	r25, Y+4	; 0x04
    23fe:	2d 81       	ldd	r18, Y+5	; 0x05
    2400:	3e 81       	ldd	r19, Y+6	; 0x06
    2402:	b9 01       	movw	r22, r18
    2404:	49 85       	ldd	r20, Y+9	; 0x09
    2406:	0e 94 80 13 	call	0x2700	; 0x2700 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    240a:	eb 81       	ldd	r30, Y+3	; 0x03
    240c:	fc 81       	ldd	r31, Y+4	; 0x04
    240e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2410:	8f 3f       	cpi	r24, 0xFF	; 255
    2412:	89 f4       	brne	.+34     	; 0x2436 <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2414:	eb 81       	ldd	r30, Y+3	; 0x03
    2416:	fc 81       	ldd	r31, Y+4	; 0x04
    2418:	81 89       	ldd	r24, Z+17	; 0x11
    241a:	88 23       	and	r24, r24
    241c:	99 f0       	breq	.+38     	; 0x2444 <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    241e:	8b 81       	ldd	r24, Y+3	; 0x03
    2420:	9c 81       	ldd	r25, Y+4	; 0x04
    2422:	41 96       	adiw	r24, 0x11	; 17
    2424:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    2428:	88 23       	and	r24, r24
    242a:	61 f0       	breq	.+24     	; 0x2444 <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    242c:	ef 81       	ldd	r30, Y+7	; 0x07
    242e:	f8 85       	ldd	r31, Y+8	; 0x08
    2430:	81 e0       	ldi	r24, 0x01	; 1
    2432:	80 83       	st	Z, r24
    2434:	07 c0       	rjmp	.+14     	; 0x2444 <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2436:	eb 81       	ldd	r30, Y+3	; 0x03
    2438:	fc 81       	ldd	r31, Y+4	; 0x04
    243a:	86 8d       	ldd	r24, Z+30	; 0x1e
    243c:	8f 5f       	subi	r24, 0xFF	; 255
    243e:	eb 81       	ldd	r30, Y+3	; 0x03
    2440:	fc 81       	ldd	r31, Y+4	; 0x04
    2442:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2444:	81 e0       	ldi	r24, 0x01	; 1
    2446:	8a 83       	std	Y+2, r24	; 0x02
    2448:	01 c0       	rjmp	.+2      	; 0x244c <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    244a:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    244c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    244e:	29 96       	adiw	r28, 0x09	; 9
    2450:	0f b6       	in	r0, 0x3f	; 63
    2452:	f8 94       	cli
    2454:	de bf       	out	0x3e, r29	; 62
    2456:	0f be       	out	0x3f, r0	; 63
    2458:	cd bf       	out	0x3d, r28	; 61
    245a:	cf 91       	pop	r28
    245c:	df 91       	pop	r29
    245e:	08 95       	ret

00002460 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2460:	df 93       	push	r29
    2462:	cf 93       	push	r28
    2464:	cd b7       	in	r28, 0x3d	; 61
    2466:	de b7       	in	r29, 0x3e	; 62
    2468:	2e 97       	sbiw	r28, 0x0e	; 14
    246a:	0f b6       	in	r0, 0x3f	; 63
    246c:	f8 94       	cli
    246e:	de bf       	out	0x3e, r29	; 62
    2470:	0f be       	out	0x3f, r0	; 63
    2472:	cd bf       	out	0x3d, r28	; 61
    2474:	98 87       	std	Y+8, r25	; 0x08
    2476:	8f 83       	std	Y+7, r24	; 0x07
    2478:	7a 87       	std	Y+10, r23	; 0x0a
    247a:	69 87       	std	Y+9, r22	; 0x09
    247c:	5c 87       	std	Y+12, r21	; 0x0c
    247e:	4b 87       	std	Y+11, r20	; 0x0b
    2480:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2482:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    248a:	ef 81       	ldd	r30, Y+7	; 0x07
    248c:	f8 85       	ldd	r31, Y+8	; 0x08
    248e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2490:	88 23       	and	r24, r24
    2492:	09 f4       	brne	.+2      	; 0x2496 <xQueueGenericReceive+0x36>
    2494:	3f c0       	rjmp	.+126    	; 0x2514 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    2496:	ef 81       	ldd	r30, Y+7	; 0x07
    2498:	f8 85       	ldd	r31, Y+8	; 0x08
    249a:	86 81       	ldd	r24, Z+6	; 0x06
    249c:	97 81       	ldd	r25, Z+7	; 0x07
    249e:	9a 83       	std	Y+2, r25	; 0x02
    24a0:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    24a2:	8f 81       	ldd	r24, Y+7	; 0x07
    24a4:	98 85       	ldd	r25, Y+8	; 0x08
    24a6:	29 85       	ldd	r18, Y+9	; 0x09
    24a8:	3a 85       	ldd	r19, Y+10	; 0x0a
    24aa:	b9 01       	movw	r22, r18
    24ac:	0e 94 15 14 	call	0x282a	; 0x282a <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    24b0:	8d 85       	ldd	r24, Y+13	; 0x0d
    24b2:	88 23       	and	r24, r24
    24b4:	b1 f4       	brne	.+44     	; 0x24e2 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    24b6:	ef 81       	ldd	r30, Y+7	; 0x07
    24b8:	f8 85       	ldd	r31, Y+8	; 0x08
    24ba:	82 8d       	ldd	r24, Z+26	; 0x1a
    24bc:	81 50       	subi	r24, 0x01	; 1
    24be:	ef 81       	ldd	r30, Y+7	; 0x07
    24c0:	f8 85       	ldd	r31, Y+8	; 0x08
    24c2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24c4:	ef 81       	ldd	r30, Y+7	; 0x07
    24c6:	f8 85       	ldd	r31, Y+8	; 0x08
    24c8:	80 85       	ldd	r24, Z+8	; 0x08
    24ca:	88 23       	and	r24, r24
    24cc:	f1 f0       	breq	.+60     	; 0x250a <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    24ce:	8f 81       	ldd	r24, Y+7	; 0x07
    24d0:	98 85       	ldd	r25, Y+8	; 0x08
    24d2:	08 96       	adiw	r24, 0x08	; 8
    24d4:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    24d8:	81 30       	cpi	r24, 0x01	; 1
    24da:	b9 f4       	brne	.+46     	; 0x250a <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    24dc:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
    24e0:	14 c0       	rjmp	.+40     	; 0x250a <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    24e2:	ef 81       	ldd	r30, Y+7	; 0x07
    24e4:	f8 85       	ldd	r31, Y+8	; 0x08
    24e6:	89 81       	ldd	r24, Y+1	; 0x01
    24e8:	9a 81       	ldd	r25, Y+2	; 0x02
    24ea:	97 83       	std	Z+7, r25	; 0x07
    24ec:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24ee:	ef 81       	ldd	r30, Y+7	; 0x07
    24f0:	f8 85       	ldd	r31, Y+8	; 0x08
    24f2:	81 89       	ldd	r24, Z+17	; 0x11
    24f4:	88 23       	and	r24, r24
    24f6:	49 f0       	breq	.+18     	; 0x250a <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24f8:	8f 81       	ldd	r24, Y+7	; 0x07
    24fa:	98 85       	ldd	r25, Y+8	; 0x08
    24fc:	41 96       	adiw	r24, 0x11	; 17
    24fe:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    2502:	88 23       	and	r24, r24
    2504:	11 f0       	breq	.+4      	; 0x250a <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    2506:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    250a:	0f 90       	pop	r0
    250c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    250e:	81 e0       	ldi	r24, 0x01	; 1
    2510:	8e 87       	std	Y+14, r24	; 0x0e
    2512:	5c c0       	rjmp	.+184    	; 0x25cc <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2514:	8b 85       	ldd	r24, Y+11	; 0x0b
    2516:	9c 85       	ldd	r25, Y+12	; 0x0c
    2518:	00 97       	sbiw	r24, 0x00	; 0
    251a:	21 f4       	brne	.+8      	; 0x2524 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    251c:	0f 90       	pop	r0
    251e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2520:	1e 86       	std	Y+14, r1	; 0x0e
    2522:	54 c0       	rjmp	.+168    	; 0x25cc <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    2524:	8b 81       	ldd	r24, Y+3	; 0x03
    2526:	88 23       	and	r24, r24
    2528:	31 f4       	brne	.+12     	; 0x2536 <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    252a:	ce 01       	movw	r24, r28
    252c:	04 96       	adiw	r24, 0x04	; 4
    252e:	0e 94 fd 19 	call	0x33fa	; 0x33fa <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    2536:	0f 90       	pop	r0
    2538:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    253a:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    253e:	0f b6       	in	r0, 0x3f	; 63
    2540:	f8 94       	cli
    2542:	0f 92       	push	r0
    2544:	ef 81       	ldd	r30, Y+7	; 0x07
    2546:	f8 85       	ldd	r31, Y+8	; 0x08
    2548:	85 8d       	ldd	r24, Z+29	; 0x1d
    254a:	8f 3f       	cpi	r24, 0xFF	; 255
    254c:	19 f4       	brne	.+6      	; 0x2554 <xQueueGenericReceive+0xf4>
    254e:	ef 81       	ldd	r30, Y+7	; 0x07
    2550:	f8 85       	ldd	r31, Y+8	; 0x08
    2552:	15 8e       	std	Z+29, r1	; 0x1d
    2554:	ef 81       	ldd	r30, Y+7	; 0x07
    2556:	f8 85       	ldd	r31, Y+8	; 0x08
    2558:	86 8d       	ldd	r24, Z+30	; 0x1e
    255a:	8f 3f       	cpi	r24, 0xFF	; 255
    255c:	19 f4       	brne	.+6      	; 0x2564 <xQueueGenericReceive+0x104>
    255e:	ef 81       	ldd	r30, Y+7	; 0x07
    2560:	f8 85       	ldd	r31, Y+8	; 0x08
    2562:	16 8e       	std	Z+30, r1	; 0x1e
    2564:	0f 90       	pop	r0
    2566:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2568:	ce 01       	movw	r24, r28
    256a:	04 96       	adiw	r24, 0x04	; 4
    256c:	9e 01       	movw	r18, r28
    256e:	25 5f       	subi	r18, 0xF5	; 245
    2570:	3f 4f       	sbci	r19, 0xFF	; 255
    2572:	b9 01       	movw	r22, r18
    2574:	0e 94 16 1a 	call	0x342c	; 0x342c <xTaskCheckForTimeOut>
    2578:	88 23       	and	r24, r24
    257a:	09 f5       	brne	.+66     	; 0x25be <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    257c:	8f 81       	ldd	r24, Y+7	; 0x07
    257e:	98 85       	ldd	r25, Y+8	; 0x08
    2580:	0e 94 b1 14 	call	0x2962	; 0x2962 <prvIsQueueEmpty>
    2584:	88 23       	and	r24, r24
    2586:	a1 f0       	breq	.+40     	; 0x25b0 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2588:	8f 81       	ldd	r24, Y+7	; 0x07
    258a:	98 85       	ldd	r25, Y+8	; 0x08
    258c:	41 96       	adiw	r24, 0x11	; 17
    258e:	2b 85       	ldd	r18, Y+11	; 0x0b
    2590:	3c 85       	ldd	r19, Y+12	; 0x0c
    2592:	b9 01       	movw	r22, r18
    2594:	0e 94 5f 19 	call	0x32be	; 0x32be <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2598:	8f 81       	ldd	r24, Y+7	; 0x07
    259a:	98 85       	ldd	r25, Y+8	; 0x08
    259c:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    25a0:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    25a4:	88 23       	and	r24, r24
    25a6:	09 f0       	breq	.+2      	; 0x25aa <xQueueGenericReceive+0x14a>
    25a8:	6d cf       	rjmp	.-294    	; 0x2484 <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    25aa:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
    25ae:	6a cf       	rjmp	.-300    	; 0x2484 <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    25b0:	8f 81       	ldd	r24, Y+7	; 0x07
    25b2:	98 85       	ldd	r25, Y+8	; 0x08
    25b4:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
				( void ) xTaskResumeAll();
    25b8:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    25bc:	63 cf       	rjmp	.-314    	; 0x2484 <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    25be:	8f 81       	ldd	r24, Y+7	; 0x07
    25c0:	98 85       	ldd	r25, Y+8	; 0x08
    25c2:	0e 94 5d 14 	call	0x28ba	; 0x28ba <prvUnlockQueue>
			( void ) xTaskResumeAll();
    25c6:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    25ca:	1e 86       	std	Y+14, r1	; 0x0e
    25cc:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    25ce:	2e 96       	adiw	r28, 0x0e	; 14
    25d0:	0f b6       	in	r0, 0x3f	; 63
    25d2:	f8 94       	cli
    25d4:	de bf       	out	0x3e, r29	; 62
    25d6:	0f be       	out	0x3f, r0	; 63
    25d8:	cd bf       	out	0x3d, r28	; 61
    25da:	cf 91       	pop	r28
    25dc:	df 91       	pop	r29
    25de:	08 95       	ret

000025e0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    25e0:	df 93       	push	r29
    25e2:	cf 93       	push	r28
    25e4:	cd b7       	in	r28, 0x3d	; 61
    25e6:	de b7       	in	r29, 0x3e	; 62
    25e8:	28 97       	sbiw	r28, 0x08	; 8
    25ea:	0f b6       	in	r0, 0x3f	; 63
    25ec:	f8 94       	cli
    25ee:	de bf       	out	0x3e, r29	; 62
    25f0:	0f be       	out	0x3f, r0	; 63
    25f2:	cd bf       	out	0x3d, r28	; 61
    25f4:	9c 83       	std	Y+4, r25	; 0x04
    25f6:	8b 83       	std	Y+3, r24	; 0x03
    25f8:	7e 83       	std	Y+6, r23	; 0x06
    25fa:	6d 83       	std	Y+5, r22	; 0x05
    25fc:	58 87       	std	Y+8, r21	; 0x08
    25fe:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2600:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2602:	eb 81       	ldd	r30, Y+3	; 0x03
    2604:	fc 81       	ldd	r31, Y+4	; 0x04
    2606:	82 8d       	ldd	r24, Z+26	; 0x1a
    2608:	88 23       	and	r24, r24
    260a:	71 f1       	breq	.+92     	; 0x2668 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    260c:	8b 81       	ldd	r24, Y+3	; 0x03
    260e:	9c 81       	ldd	r25, Y+4	; 0x04
    2610:	2d 81       	ldd	r18, Y+5	; 0x05
    2612:	3e 81       	ldd	r19, Y+6	; 0x06
    2614:	b9 01       	movw	r22, r18
    2616:	0e 94 15 14 	call	0x282a	; 0x282a <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    261a:	eb 81       	ldd	r30, Y+3	; 0x03
    261c:	fc 81       	ldd	r31, Y+4	; 0x04
    261e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2620:	81 50       	subi	r24, 0x01	; 1
    2622:	eb 81       	ldd	r30, Y+3	; 0x03
    2624:	fc 81       	ldd	r31, Y+4	; 0x04
    2626:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2628:	eb 81       	ldd	r30, Y+3	; 0x03
    262a:	fc 81       	ldd	r31, Y+4	; 0x04
    262c:	85 8d       	ldd	r24, Z+29	; 0x1d
    262e:	8f 3f       	cpi	r24, 0xFF	; 255
    2630:	89 f4       	brne	.+34     	; 0x2654 <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2632:	eb 81       	ldd	r30, Y+3	; 0x03
    2634:	fc 81       	ldd	r31, Y+4	; 0x04
    2636:	80 85       	ldd	r24, Z+8	; 0x08
    2638:	88 23       	and	r24, r24
    263a:	99 f0       	breq	.+38     	; 0x2662 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    263c:	8b 81       	ldd	r24, Y+3	; 0x03
    263e:	9c 81       	ldd	r25, Y+4	; 0x04
    2640:	08 96       	adiw	r24, 0x08	; 8
    2642:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    2646:	88 23       	and	r24, r24
    2648:	61 f0       	breq	.+24     	; 0x2662 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    264a:	ef 81       	ldd	r30, Y+7	; 0x07
    264c:	f8 85       	ldd	r31, Y+8	; 0x08
    264e:	81 e0       	ldi	r24, 0x01	; 1
    2650:	80 83       	st	Z, r24
    2652:	07 c0       	rjmp	.+14     	; 0x2662 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2654:	eb 81       	ldd	r30, Y+3	; 0x03
    2656:	fc 81       	ldd	r31, Y+4	; 0x04
    2658:	85 8d       	ldd	r24, Z+29	; 0x1d
    265a:	8f 5f       	subi	r24, 0xFF	; 255
    265c:	eb 81       	ldd	r30, Y+3	; 0x03
    265e:	fc 81       	ldd	r31, Y+4	; 0x04
    2660:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2662:	81 e0       	ldi	r24, 0x01	; 1
    2664:	8a 83       	std	Y+2, r24	; 0x02
    2666:	01 c0       	rjmp	.+2      	; 0x266a <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    2668:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    266a:	8a 81       	ldd	r24, Y+2	; 0x02
}
    266c:	28 96       	adiw	r28, 0x08	; 8
    266e:	0f b6       	in	r0, 0x3f	; 63
    2670:	f8 94       	cli
    2672:	de bf       	out	0x3e, r29	; 62
    2674:	0f be       	out	0x3f, r0	; 63
    2676:	cd bf       	out	0x3d, r28	; 61
    2678:	cf 91       	pop	r28
    267a:	df 91       	pop	r29
    267c:	08 95       	ret

0000267e <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    267e:	df 93       	push	r29
    2680:	cf 93       	push	r28
    2682:	00 d0       	rcall	.+0      	; 0x2684 <uxQueueMessagesWaiting+0x6>
    2684:	0f 92       	push	r0
    2686:	cd b7       	in	r28, 0x3d	; 61
    2688:	de b7       	in	r29, 0x3e	; 62
    268a:	9b 83       	std	Y+3, r25	; 0x03
    268c:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    268e:	0f b6       	in	r0, 0x3f	; 63
    2690:	f8 94       	cli
    2692:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2694:	ea 81       	ldd	r30, Y+2	; 0x02
    2696:	fb 81       	ldd	r31, Y+3	; 0x03
    2698:	82 8d       	ldd	r24, Z+26	; 0x1a
    269a:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    269c:	0f 90       	pop	r0
    269e:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    26a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    26a2:	0f 90       	pop	r0
    26a4:	0f 90       	pop	r0
    26a6:	0f 90       	pop	r0
    26a8:	cf 91       	pop	r28
    26aa:	df 91       	pop	r29
    26ac:	08 95       	ret

000026ae <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    26ae:	df 93       	push	r29
    26b0:	cf 93       	push	r28
    26b2:	00 d0       	rcall	.+0      	; 0x26b4 <uxQueueMessagesWaitingFromISR+0x6>
    26b4:	0f 92       	push	r0
    26b6:	cd b7       	in	r28, 0x3d	; 61
    26b8:	de b7       	in	r29, 0x3e	; 62
    26ba:	9b 83       	std	Y+3, r25	; 0x03
    26bc:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    26be:	ea 81       	ldd	r30, Y+2	; 0x02
    26c0:	fb 81       	ldd	r31, Y+3	; 0x03
    26c2:	82 8d       	ldd	r24, Z+26	; 0x1a
    26c4:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    26c6:	89 81       	ldd	r24, Y+1	; 0x01
}
    26c8:	0f 90       	pop	r0
    26ca:	0f 90       	pop	r0
    26cc:	0f 90       	pop	r0
    26ce:	cf 91       	pop	r28
    26d0:	df 91       	pop	r29
    26d2:	08 95       	ret

000026d4 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    26d4:	df 93       	push	r29
    26d6:	cf 93       	push	r28
    26d8:	00 d0       	rcall	.+0      	; 0x26da <vQueueDelete+0x6>
    26da:	cd b7       	in	r28, 0x3d	; 61
    26dc:	de b7       	in	r29, 0x3e	; 62
    26de:	9a 83       	std	Y+2, r25	; 0x02
    26e0:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    26e2:	e9 81       	ldd	r30, Y+1	; 0x01
    26e4:	fa 81       	ldd	r31, Y+2	; 0x02
    26e6:	80 81       	ld	r24, Z
    26e8:	91 81       	ldd	r25, Z+1	; 0x01
    26ea:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
	vPortFree( pxQueue );
    26ee:	89 81       	ldd	r24, Y+1	; 0x01
    26f0:	9a 81       	ldd	r25, Y+2	; 0x02
    26f2:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
}
    26f6:	0f 90       	pop	r0
    26f8:	0f 90       	pop	r0
    26fa:	cf 91       	pop	r28
    26fc:	df 91       	pop	r29
    26fe:	08 95       	ret

00002700 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    2700:	df 93       	push	r29
    2702:	cf 93       	push	r28
    2704:	00 d0       	rcall	.+0      	; 0x2706 <prvCopyDataToQueue+0x6>
    2706:	00 d0       	rcall	.+0      	; 0x2708 <prvCopyDataToQueue+0x8>
    2708:	0f 92       	push	r0
    270a:	cd b7       	in	r28, 0x3d	; 61
    270c:	de b7       	in	r29, 0x3e	; 62
    270e:	9a 83       	std	Y+2, r25	; 0x02
    2710:	89 83       	std	Y+1, r24	; 0x01
    2712:	7c 83       	std	Y+4, r23	; 0x04
    2714:	6b 83       	std	Y+3, r22	; 0x03
    2716:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    2718:	e9 81       	ldd	r30, Y+1	; 0x01
    271a:	fa 81       	ldd	r31, Y+2	; 0x02
    271c:	84 8d       	ldd	r24, Z+28	; 0x1c
    271e:	88 23       	and	r24, r24
    2720:	09 f4       	brne	.+2      	; 0x2724 <prvCopyDataToQueue+0x24>
    2722:	74 c0       	rjmp	.+232    	; 0x280c <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    2724:	8d 81       	ldd	r24, Y+5	; 0x05
    2726:	88 23       	and	r24, r24
    2728:	99 f5       	brne	.+102    	; 0x2790 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    272a:	e9 81       	ldd	r30, Y+1	; 0x01
    272c:	fa 81       	ldd	r31, Y+2	; 0x02
    272e:	64 81       	ldd	r22, Z+4	; 0x04
    2730:	75 81       	ldd	r23, Z+5	; 0x05
    2732:	e9 81       	ldd	r30, Y+1	; 0x01
    2734:	fa 81       	ldd	r31, Y+2	; 0x02
    2736:	84 8d       	ldd	r24, Z+28	; 0x1c
    2738:	48 2f       	mov	r20, r24
    273a:	50 e0       	ldi	r21, 0x00	; 0
    273c:	2b 81       	ldd	r18, Y+3	; 0x03
    273e:	3c 81       	ldd	r19, Y+4	; 0x04
    2740:	cb 01       	movw	r24, r22
    2742:	b9 01       	movw	r22, r18
    2744:	0e 94 66 1c 	call	0x38cc	; 0x38cc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2748:	e9 81       	ldd	r30, Y+1	; 0x01
    274a:	fa 81       	ldd	r31, Y+2	; 0x02
    274c:	24 81       	ldd	r18, Z+4	; 0x04
    274e:	35 81       	ldd	r19, Z+5	; 0x05
    2750:	e9 81       	ldd	r30, Y+1	; 0x01
    2752:	fa 81       	ldd	r31, Y+2	; 0x02
    2754:	84 8d       	ldd	r24, Z+28	; 0x1c
    2756:	88 2f       	mov	r24, r24
    2758:	90 e0       	ldi	r25, 0x00	; 0
    275a:	82 0f       	add	r24, r18
    275c:	93 1f       	adc	r25, r19
    275e:	e9 81       	ldd	r30, Y+1	; 0x01
    2760:	fa 81       	ldd	r31, Y+2	; 0x02
    2762:	95 83       	std	Z+5, r25	; 0x05
    2764:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2766:	e9 81       	ldd	r30, Y+1	; 0x01
    2768:	fa 81       	ldd	r31, Y+2	; 0x02
    276a:	24 81       	ldd	r18, Z+4	; 0x04
    276c:	35 81       	ldd	r19, Z+5	; 0x05
    276e:	e9 81       	ldd	r30, Y+1	; 0x01
    2770:	fa 81       	ldd	r31, Y+2	; 0x02
    2772:	82 81       	ldd	r24, Z+2	; 0x02
    2774:	93 81       	ldd	r25, Z+3	; 0x03
    2776:	28 17       	cp	r18, r24
    2778:	39 07       	cpc	r19, r25
    277a:	08 f4       	brcc	.+2      	; 0x277e <prvCopyDataToQueue+0x7e>
    277c:	47 c0       	rjmp	.+142    	; 0x280c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    277e:	e9 81       	ldd	r30, Y+1	; 0x01
    2780:	fa 81       	ldd	r31, Y+2	; 0x02
    2782:	80 81       	ld	r24, Z
    2784:	91 81       	ldd	r25, Z+1	; 0x01
    2786:	e9 81       	ldd	r30, Y+1	; 0x01
    2788:	fa 81       	ldd	r31, Y+2	; 0x02
    278a:	95 83       	std	Z+5, r25	; 0x05
    278c:	84 83       	std	Z+4, r24	; 0x04
    278e:	3e c0       	rjmp	.+124    	; 0x280c <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2790:	e9 81       	ldd	r30, Y+1	; 0x01
    2792:	fa 81       	ldd	r31, Y+2	; 0x02
    2794:	66 81       	ldd	r22, Z+6	; 0x06
    2796:	77 81       	ldd	r23, Z+7	; 0x07
    2798:	e9 81       	ldd	r30, Y+1	; 0x01
    279a:	fa 81       	ldd	r31, Y+2	; 0x02
    279c:	84 8d       	ldd	r24, Z+28	; 0x1c
    279e:	48 2f       	mov	r20, r24
    27a0:	50 e0       	ldi	r21, 0x00	; 0
    27a2:	2b 81       	ldd	r18, Y+3	; 0x03
    27a4:	3c 81       	ldd	r19, Y+4	; 0x04
    27a6:	cb 01       	movw	r24, r22
    27a8:	b9 01       	movw	r22, r18
    27aa:	0e 94 66 1c 	call	0x38cc	; 0x38cc <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    27ae:	e9 81       	ldd	r30, Y+1	; 0x01
    27b0:	fa 81       	ldd	r31, Y+2	; 0x02
    27b2:	26 81       	ldd	r18, Z+6	; 0x06
    27b4:	37 81       	ldd	r19, Z+7	; 0x07
    27b6:	e9 81       	ldd	r30, Y+1	; 0x01
    27b8:	fa 81       	ldd	r31, Y+2	; 0x02
    27ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    27bc:	88 2f       	mov	r24, r24
    27be:	90 e0       	ldi	r25, 0x00	; 0
    27c0:	90 95       	com	r25
    27c2:	81 95       	neg	r24
    27c4:	9f 4f       	sbci	r25, 0xFF	; 255
    27c6:	82 0f       	add	r24, r18
    27c8:	93 1f       	adc	r25, r19
    27ca:	e9 81       	ldd	r30, Y+1	; 0x01
    27cc:	fa 81       	ldd	r31, Y+2	; 0x02
    27ce:	97 83       	std	Z+7, r25	; 0x07
    27d0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    27d2:	e9 81       	ldd	r30, Y+1	; 0x01
    27d4:	fa 81       	ldd	r31, Y+2	; 0x02
    27d6:	26 81       	ldd	r18, Z+6	; 0x06
    27d8:	37 81       	ldd	r19, Z+7	; 0x07
    27da:	e9 81       	ldd	r30, Y+1	; 0x01
    27dc:	fa 81       	ldd	r31, Y+2	; 0x02
    27de:	80 81       	ld	r24, Z
    27e0:	91 81       	ldd	r25, Z+1	; 0x01
    27e2:	28 17       	cp	r18, r24
    27e4:	39 07       	cpc	r19, r25
    27e6:	90 f4       	brcc	.+36     	; 0x280c <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    27e8:	e9 81       	ldd	r30, Y+1	; 0x01
    27ea:	fa 81       	ldd	r31, Y+2	; 0x02
    27ec:	22 81       	ldd	r18, Z+2	; 0x02
    27ee:	33 81       	ldd	r19, Z+3	; 0x03
    27f0:	e9 81       	ldd	r30, Y+1	; 0x01
    27f2:	fa 81       	ldd	r31, Y+2	; 0x02
    27f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    27f6:	88 2f       	mov	r24, r24
    27f8:	90 e0       	ldi	r25, 0x00	; 0
    27fa:	90 95       	com	r25
    27fc:	81 95       	neg	r24
    27fe:	9f 4f       	sbci	r25, 0xFF	; 255
    2800:	82 0f       	add	r24, r18
    2802:	93 1f       	adc	r25, r19
    2804:	e9 81       	ldd	r30, Y+1	; 0x01
    2806:	fa 81       	ldd	r31, Y+2	; 0x02
    2808:	97 83       	std	Z+7, r25	; 0x07
    280a:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    280c:	e9 81       	ldd	r30, Y+1	; 0x01
    280e:	fa 81       	ldd	r31, Y+2	; 0x02
    2810:	82 8d       	ldd	r24, Z+26	; 0x1a
    2812:	8f 5f       	subi	r24, 0xFF	; 255
    2814:	e9 81       	ldd	r30, Y+1	; 0x01
    2816:	fa 81       	ldd	r31, Y+2	; 0x02
    2818:	82 8f       	std	Z+26, r24	; 0x1a
}
    281a:	0f 90       	pop	r0
    281c:	0f 90       	pop	r0
    281e:	0f 90       	pop	r0
    2820:	0f 90       	pop	r0
    2822:	0f 90       	pop	r0
    2824:	cf 91       	pop	r28
    2826:	df 91       	pop	r29
    2828:	08 95       	ret

0000282a <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    282a:	df 93       	push	r29
    282c:	cf 93       	push	r28
    282e:	00 d0       	rcall	.+0      	; 0x2830 <prvCopyDataFromQueue+0x6>
    2830:	00 d0       	rcall	.+0      	; 0x2832 <prvCopyDataFromQueue+0x8>
    2832:	cd b7       	in	r28, 0x3d	; 61
    2834:	de b7       	in	r29, 0x3e	; 62
    2836:	9a 83       	std	Y+2, r25	; 0x02
    2838:	89 83       	std	Y+1, r24	; 0x01
    283a:	7c 83       	std	Y+4, r23	; 0x04
    283c:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    283e:	e9 81       	ldd	r30, Y+1	; 0x01
    2840:	fa 81       	ldd	r31, Y+2	; 0x02
    2842:	80 81       	ld	r24, Z
    2844:	91 81       	ldd	r25, Z+1	; 0x01
    2846:	00 97       	sbiw	r24, 0x00	; 0
    2848:	89 f1       	breq	.+98     	; 0x28ac <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    284a:	e9 81       	ldd	r30, Y+1	; 0x01
    284c:	fa 81       	ldd	r31, Y+2	; 0x02
    284e:	26 81       	ldd	r18, Z+6	; 0x06
    2850:	37 81       	ldd	r19, Z+7	; 0x07
    2852:	e9 81       	ldd	r30, Y+1	; 0x01
    2854:	fa 81       	ldd	r31, Y+2	; 0x02
    2856:	84 8d       	ldd	r24, Z+28	; 0x1c
    2858:	88 2f       	mov	r24, r24
    285a:	90 e0       	ldi	r25, 0x00	; 0
    285c:	82 0f       	add	r24, r18
    285e:	93 1f       	adc	r25, r19
    2860:	e9 81       	ldd	r30, Y+1	; 0x01
    2862:	fa 81       	ldd	r31, Y+2	; 0x02
    2864:	97 83       	std	Z+7, r25	; 0x07
    2866:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2868:	e9 81       	ldd	r30, Y+1	; 0x01
    286a:	fa 81       	ldd	r31, Y+2	; 0x02
    286c:	26 81       	ldd	r18, Z+6	; 0x06
    286e:	37 81       	ldd	r19, Z+7	; 0x07
    2870:	e9 81       	ldd	r30, Y+1	; 0x01
    2872:	fa 81       	ldd	r31, Y+2	; 0x02
    2874:	82 81       	ldd	r24, Z+2	; 0x02
    2876:	93 81       	ldd	r25, Z+3	; 0x03
    2878:	28 17       	cp	r18, r24
    287a:	39 07       	cpc	r19, r25
    287c:	40 f0       	brcs	.+16     	; 0x288e <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    287e:	e9 81       	ldd	r30, Y+1	; 0x01
    2880:	fa 81       	ldd	r31, Y+2	; 0x02
    2882:	80 81       	ld	r24, Z
    2884:	91 81       	ldd	r25, Z+1	; 0x01
    2886:	e9 81       	ldd	r30, Y+1	; 0x01
    2888:	fa 81       	ldd	r31, Y+2	; 0x02
    288a:	97 83       	std	Z+7, r25	; 0x07
    288c:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    288e:	e9 81       	ldd	r30, Y+1	; 0x01
    2890:	fa 81       	ldd	r31, Y+2	; 0x02
    2892:	46 81       	ldd	r20, Z+6	; 0x06
    2894:	57 81       	ldd	r21, Z+7	; 0x07
    2896:	e9 81       	ldd	r30, Y+1	; 0x01
    2898:	fa 81       	ldd	r31, Y+2	; 0x02
    289a:	84 8d       	ldd	r24, Z+28	; 0x1c
    289c:	28 2f       	mov	r18, r24
    289e:	30 e0       	ldi	r19, 0x00	; 0
    28a0:	8b 81       	ldd	r24, Y+3	; 0x03
    28a2:	9c 81       	ldd	r25, Y+4	; 0x04
    28a4:	ba 01       	movw	r22, r20
    28a6:	a9 01       	movw	r20, r18
    28a8:	0e 94 66 1c 	call	0x38cc	; 0x38cc <memcpy>
	}
}
    28ac:	0f 90       	pop	r0
    28ae:	0f 90       	pop	r0
    28b0:	0f 90       	pop	r0
    28b2:	0f 90       	pop	r0
    28b4:	cf 91       	pop	r28
    28b6:	df 91       	pop	r29
    28b8:	08 95       	ret

000028ba <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    28ba:	df 93       	push	r29
    28bc:	cf 93       	push	r28
    28be:	00 d0       	rcall	.+0      	; 0x28c0 <prvUnlockQueue+0x6>
    28c0:	cd b7       	in	r28, 0x3d	; 61
    28c2:	de b7       	in	r29, 0x3e	; 62
    28c4:	9a 83       	std	Y+2, r25	; 0x02
    28c6:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    28c8:	0f b6       	in	r0, 0x3f	; 63
    28ca:	f8 94       	cli
    28cc:	0f 92       	push	r0
    28ce:	15 c0       	rjmp	.+42     	; 0x28fa <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28d0:	e9 81       	ldd	r30, Y+1	; 0x01
    28d2:	fa 81       	ldd	r31, Y+2	; 0x02
    28d4:	81 89       	ldd	r24, Z+17	; 0x11
    28d6:	88 23       	and	r24, r24
    28d8:	a9 f0       	breq	.+42     	; 0x2904 <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	9a 81       	ldd	r25, Y+2	; 0x02
    28de:	41 96       	adiw	r24, 0x11	; 17
    28e0:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    28e4:	88 23       	and	r24, r24
    28e6:	11 f0       	breq	.+4      	; 0x28ec <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    28e8:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    28ec:	e9 81       	ldd	r30, Y+1	; 0x01
    28ee:	fa 81       	ldd	r31, Y+2	; 0x02
    28f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    28f2:	81 50       	subi	r24, 0x01	; 1
    28f4:	e9 81       	ldd	r30, Y+1	; 0x01
    28f6:	fa 81       	ldd	r31, Y+2	; 0x02
    28f8:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    28fa:	e9 81       	ldd	r30, Y+1	; 0x01
    28fc:	fa 81       	ldd	r31, Y+2	; 0x02
    28fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    2900:	18 16       	cp	r1, r24
    2902:	34 f3       	brlt	.-52     	; 0x28d0 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2904:	e9 81       	ldd	r30, Y+1	; 0x01
    2906:	fa 81       	ldd	r31, Y+2	; 0x02
    2908:	8f ef       	ldi	r24, 0xFF	; 255
    290a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    290c:	0f 90       	pop	r0
    290e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	0f 92       	push	r0
    2916:	15 c0       	rjmp	.+42     	; 0x2942 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2918:	e9 81       	ldd	r30, Y+1	; 0x01
    291a:	fa 81       	ldd	r31, Y+2	; 0x02
    291c:	80 85       	ldd	r24, Z+8	; 0x08
    291e:	88 23       	and	r24, r24
    2920:	a9 f0       	breq	.+42     	; 0x294c <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2922:	89 81       	ldd	r24, Y+1	; 0x01
    2924:	9a 81       	ldd	r25, Y+2	; 0x02
    2926:	08 96       	adiw	r24, 0x08	; 8
    2928:	0e 94 95 19 	call	0x332a	; 0x332a <xTaskRemoveFromEventList>
    292c:	88 23       	and	r24, r24
    292e:	11 f0       	breq	.+4      	; 0x2934 <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2930:	0e 94 73 1a 	call	0x34e6	; 0x34e6 <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    2934:	e9 81       	ldd	r30, Y+1	; 0x01
    2936:	fa 81       	ldd	r31, Y+2	; 0x02
    2938:	85 8d       	ldd	r24, Z+29	; 0x1d
    293a:	81 50       	subi	r24, 0x01	; 1
    293c:	e9 81       	ldd	r30, Y+1	; 0x01
    293e:	fa 81       	ldd	r31, Y+2	; 0x02
    2940:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2942:	e9 81       	ldd	r30, Y+1	; 0x01
    2944:	fa 81       	ldd	r31, Y+2	; 0x02
    2946:	85 8d       	ldd	r24, Z+29	; 0x1d
    2948:	18 16       	cp	r1, r24
    294a:	34 f3       	brlt	.-52     	; 0x2918 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    294c:	e9 81       	ldd	r30, Y+1	; 0x01
    294e:	fa 81       	ldd	r31, Y+2	; 0x02
    2950:	8f ef       	ldi	r24, 0xFF	; 255
    2952:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2954:	0f 90       	pop	r0
    2956:	0f be       	out	0x3f, r0	; 63
}
    2958:	0f 90       	pop	r0
    295a:	0f 90       	pop	r0
    295c:	cf 91       	pop	r28
    295e:	df 91       	pop	r29
    2960:	08 95       	ret

00002962 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2962:	df 93       	push	r29
    2964:	cf 93       	push	r28
    2966:	00 d0       	rcall	.+0      	; 0x2968 <prvIsQueueEmpty+0x6>
    2968:	0f 92       	push	r0
    296a:	cd b7       	in	r28, 0x3d	; 61
    296c:	de b7       	in	r29, 0x3e	; 62
    296e:	9b 83       	std	Y+3, r25	; 0x03
    2970:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2972:	0f b6       	in	r0, 0x3f	; 63
    2974:	f8 94       	cli
    2976:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2978:	ea 81       	ldd	r30, Y+2	; 0x02
    297a:	fb 81       	ldd	r31, Y+3	; 0x03
    297c:	82 8d       	ldd	r24, Z+26	; 0x1a
    297e:	19 82       	std	Y+1, r1	; 0x01
    2980:	88 23       	and	r24, r24
    2982:	11 f4       	brne	.+4      	; 0x2988 <prvIsQueueEmpty+0x26>
    2984:	81 e0       	ldi	r24, 0x01	; 1
    2986:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2988:	0f 90       	pop	r0
    298a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    298c:	89 81       	ldd	r24, Y+1	; 0x01
}
    298e:	0f 90       	pop	r0
    2990:	0f 90       	pop	r0
    2992:	0f 90       	pop	r0
    2994:	cf 91       	pop	r28
    2996:	df 91       	pop	r29
    2998:	08 95       	ret

0000299a <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    299a:	df 93       	push	r29
    299c:	cf 93       	push	r28
    299e:	00 d0       	rcall	.+0      	; 0x29a0 <xQueueIsQueueEmptyFromISR+0x6>
    29a0:	0f 92       	push	r0
    29a2:	cd b7       	in	r28, 0x3d	; 61
    29a4:	de b7       	in	r29, 0x3e	; 62
    29a6:	9b 83       	std	Y+3, r25	; 0x03
    29a8:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    29aa:	ea 81       	ldd	r30, Y+2	; 0x02
    29ac:	fb 81       	ldd	r31, Y+3	; 0x03
    29ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    29b0:	19 82       	std	Y+1, r1	; 0x01
    29b2:	88 23       	and	r24, r24
    29b4:	11 f4       	brne	.+4      	; 0x29ba <xQueueIsQueueEmptyFromISR+0x20>
    29b6:	81 e0       	ldi	r24, 0x01	; 1
    29b8:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    29ba:	89 81       	ldd	r24, Y+1	; 0x01
}
    29bc:	0f 90       	pop	r0
    29be:	0f 90       	pop	r0
    29c0:	0f 90       	pop	r0
    29c2:	cf 91       	pop	r28
    29c4:	df 91       	pop	r29
    29c6:	08 95       	ret

000029c8 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    29c8:	df 93       	push	r29
    29ca:	cf 93       	push	r28
    29cc:	00 d0       	rcall	.+0      	; 0x29ce <prvIsQueueFull+0x6>
    29ce:	0f 92       	push	r0
    29d0:	cd b7       	in	r28, 0x3d	; 61
    29d2:	de b7       	in	r29, 0x3e	; 62
    29d4:	9b 83       	std	Y+3, r25	; 0x03
    29d6:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    29d8:	0f b6       	in	r0, 0x3f	; 63
    29da:	f8 94       	cli
    29dc:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    29de:	ea 81       	ldd	r30, Y+2	; 0x02
    29e0:	fb 81       	ldd	r31, Y+3	; 0x03
    29e2:	92 8d       	ldd	r25, Z+26	; 0x1a
    29e4:	ea 81       	ldd	r30, Y+2	; 0x02
    29e6:	fb 81       	ldd	r31, Y+3	; 0x03
    29e8:	83 8d       	ldd	r24, Z+27	; 0x1b
    29ea:	19 82       	std	Y+1, r1	; 0x01
    29ec:	98 17       	cp	r25, r24
    29ee:	11 f4       	brne	.+4      	; 0x29f4 <prvIsQueueFull+0x2c>
    29f0:	81 e0       	ldi	r24, 0x01	; 1
    29f2:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    29f4:	0f 90       	pop	r0
    29f6:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    29f8:	89 81       	ldd	r24, Y+1	; 0x01
}
    29fa:	0f 90       	pop	r0
    29fc:	0f 90       	pop	r0
    29fe:	0f 90       	pop	r0
    2a00:	cf 91       	pop	r28
    2a02:	df 91       	pop	r29
    2a04:	08 95       	ret

00002a06 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2a06:	df 93       	push	r29
    2a08:	cf 93       	push	r28
    2a0a:	00 d0       	rcall	.+0      	; 0x2a0c <xQueueIsQueueFullFromISR+0x6>
    2a0c:	0f 92       	push	r0
    2a0e:	cd b7       	in	r28, 0x3d	; 61
    2a10:	de b7       	in	r29, 0x3e	; 62
    2a12:	9b 83       	std	Y+3, r25	; 0x03
    2a14:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2a16:	ea 81       	ldd	r30, Y+2	; 0x02
    2a18:	fb 81       	ldd	r31, Y+3	; 0x03
    2a1a:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a1c:	ea 81       	ldd	r30, Y+2	; 0x02
    2a1e:	fb 81       	ldd	r31, Y+3	; 0x03
    2a20:	83 8d       	ldd	r24, Z+27	; 0x1b
    2a22:	19 82       	std	Y+1, r1	; 0x01
    2a24:	98 17       	cp	r25, r24
    2a26:	11 f4       	brne	.+4      	; 0x2a2c <xQueueIsQueueFullFromISR+0x26>
    2a28:	81 e0       	ldi	r24, 0x01	; 1
    2a2a:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2a2c:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a2e:	0f 90       	pop	r0
    2a30:	0f 90       	pop	r0
    2a32:	0f 90       	pop	r0
    2a34:	cf 91       	pop	r28
    2a36:	df 91       	pop	r29
    2a38:	08 95       	ret

00002a3a <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2a3a:	af 92       	push	r10
    2a3c:	bf 92       	push	r11
    2a3e:	cf 92       	push	r12
    2a40:	df 92       	push	r13
    2a42:	ef 92       	push	r14
    2a44:	ff 92       	push	r15
    2a46:	0f 93       	push	r16
    2a48:	1f 93       	push	r17
    2a4a:	df 93       	push	r29
    2a4c:	cf 93       	push	r28
    2a4e:	cd b7       	in	r28, 0x3d	; 61
    2a50:	de b7       	in	r29, 0x3e	; 62
    2a52:	64 97       	sbiw	r28, 0x14	; 20
    2a54:	0f b6       	in	r0, 0x3f	; 63
    2a56:	f8 94       	cli
    2a58:	de bf       	out	0x3e, r29	; 62
    2a5a:	0f be       	out	0x3f, r0	; 63
    2a5c:	cd bf       	out	0x3d, r28	; 61
    2a5e:	9f 83       	std	Y+7, r25	; 0x07
    2a60:	8e 83       	std	Y+6, r24	; 0x06
    2a62:	79 87       	std	Y+9, r23	; 0x09
    2a64:	68 87       	std	Y+8, r22	; 0x08
    2a66:	5b 87       	std	Y+11, r21	; 0x0b
    2a68:	4a 87       	std	Y+10, r20	; 0x0a
    2a6a:	3d 87       	std	Y+13, r19	; 0x0d
    2a6c:	2c 87       	std	Y+12, r18	; 0x0c
    2a6e:	0e 87       	std	Y+14, r16	; 0x0e
    2a70:	f8 8a       	std	Y+16, r15	; 0x10
    2a72:	ef 86       	std	Y+15, r14	; 0x0f
    2a74:	da 8a       	std	Y+18, r13	; 0x12
    2a76:	c9 8a       	std	Y+17, r12	; 0x11
    2a78:	bc 8a       	std	Y+20, r11	; 0x14
    2a7a:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    2a7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a80:	29 89       	ldd	r18, Y+17	; 0x11
    2a82:	3a 89       	ldd	r19, Y+18	; 0x12
    2a84:	b9 01       	movw	r22, r18
    2a86:	0e 94 a2 1b 	call	0x3744	; 0x3744 <prvAllocateTCBAndStack>
    2a8a:	9c 83       	std	Y+4, r25	; 0x04
    2a8c:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    2a8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2a90:	9c 81       	ldd	r25, Y+4	; 0x04
    2a92:	00 97       	sbiw	r24, 0x00	; 0
    2a94:	09 f4       	brne	.+2      	; 0x2a98 <xTaskGenericCreate+0x5e>
    2a96:	99 c0       	rjmp	.+306    	; 0x2bca <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2a98:	eb 81       	ldd	r30, Y+3	; 0x03
    2a9a:	fc 81       	ldd	r31, Y+4	; 0x04
    2a9c:	27 89       	ldd	r18, Z+23	; 0x17
    2a9e:	30 8d       	ldd	r19, Z+24	; 0x18
    2aa0:	8a 85       	ldd	r24, Y+10	; 0x0a
    2aa2:	9b 85       	ldd	r25, Y+11	; 0x0b
    2aa4:	01 97       	sbiw	r24, 0x01	; 1
    2aa6:	82 0f       	add	r24, r18
    2aa8:	93 1f       	adc	r25, r19
    2aaa:	9a 83       	std	Y+2, r25	; 0x02
    2aac:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2aae:	8b 81       	ldd	r24, Y+3	; 0x03
    2ab0:	9c 81       	ldd	r25, Y+4	; 0x04
    2ab2:	28 85       	ldd	r18, Y+8	; 0x08
    2ab4:	39 85       	ldd	r19, Y+9	; 0x09
    2ab6:	eb 89       	ldd	r30, Y+19	; 0x13
    2ab8:	fc 89       	ldd	r31, Y+20	; 0x14
    2aba:	aa 85       	ldd	r26, Y+10	; 0x0a
    2abc:	bb 85       	ldd	r27, Y+11	; 0x0b
    2abe:	b9 01       	movw	r22, r18
    2ac0:	4e 85       	ldd	r20, Y+14	; 0x0e
    2ac2:	9f 01       	movw	r18, r30
    2ac4:	8d 01       	movw	r16, r26
    2ac6:	0e 94 87 1a 	call	0x350e	; 0x350e <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2aca:	89 81       	ldd	r24, Y+1	; 0x01
    2acc:	9a 81       	ldd	r25, Y+2	; 0x02
    2ace:	2e 81       	ldd	r18, Y+6	; 0x06
    2ad0:	3f 81       	ldd	r19, Y+7	; 0x07
    2ad2:	4c 85       	ldd	r20, Y+12	; 0x0c
    2ad4:	5d 85       	ldd	r21, Y+13	; 0x0d
    2ad6:	b9 01       	movw	r22, r18
    2ad8:	0e 94 ca 0d 	call	0x1b94	; 0x1b94 <pxPortInitialiseStack>
    2adc:	eb 81       	ldd	r30, Y+3	; 0x03
    2ade:	fc 81       	ldd	r31, Y+4	; 0x04
    2ae0:	91 83       	std	Z+1, r25	; 0x01
    2ae2:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2ae4:	8f 85       	ldd	r24, Y+15	; 0x0f
    2ae6:	98 89       	ldd	r25, Y+16	; 0x10
    2ae8:	00 97       	sbiw	r24, 0x00	; 0
    2aea:	31 f0       	breq	.+12     	; 0x2af8 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2aec:	ef 85       	ldd	r30, Y+15	; 0x0f
    2aee:	f8 89       	ldd	r31, Y+16	; 0x10
    2af0:	8b 81       	ldd	r24, Y+3	; 0x03
    2af2:	9c 81       	ldd	r25, Y+4	; 0x04
    2af4:	91 83       	std	Z+1, r25	; 0x01
    2af6:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2af8:	0f b6       	in	r0, 0x3f	; 63
    2afa:	f8 94       	cli
    2afc:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2afe:	80 91 37 03 	lds	r24, 0x0337
    2b02:	8f 5f       	subi	r24, 0xFF	; 255
    2b04:	80 93 37 03 	sts	0x0337, r24
			if( pxCurrentTCB == NULL )
    2b08:	80 91 34 03 	lds	r24, 0x0334
    2b0c:	90 91 35 03 	lds	r25, 0x0335
    2b10:	00 97       	sbiw	r24, 0x00	; 0
    2b12:	69 f4       	brne	.+26     	; 0x2b2e <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2b14:	8b 81       	ldd	r24, Y+3	; 0x03
    2b16:	9c 81       	ldd	r25, Y+4	; 0x04
    2b18:	90 93 35 03 	sts	0x0335, r25
    2b1c:	80 93 34 03 	sts	0x0334, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2b20:	80 91 37 03 	lds	r24, 0x0337
    2b24:	81 30       	cpi	r24, 0x01	; 1
    2b26:	a9 f4       	brne	.+42     	; 0x2b52 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    2b28:	0e 94 de 1a 	call	0x35bc	; 0x35bc <prvInitialiseTaskLists>
    2b2c:	12 c0       	rjmp	.+36     	; 0x2b52 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2b2e:	80 91 3c 03 	lds	r24, 0x033C
    2b32:	88 23       	and	r24, r24
    2b34:	71 f4       	brne	.+28     	; 0x2b52 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2b36:	e0 91 34 03 	lds	r30, 0x0334
    2b3a:	f0 91 35 03 	lds	r31, 0x0335
    2b3e:	96 89       	ldd	r25, Z+22	; 0x16
    2b40:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b42:	89 17       	cp	r24, r25
    2b44:	30 f0       	brcs	.+12     	; 0x2b52 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    2b46:	8b 81       	ldd	r24, Y+3	; 0x03
    2b48:	9c 81       	ldd	r25, Y+4	; 0x04
    2b4a:	90 93 35 03 	sts	0x0335, r25
    2b4e:	80 93 34 03 	sts	0x0334, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2b52:	eb 81       	ldd	r30, Y+3	; 0x03
    2b54:	fc 81       	ldd	r31, Y+4	; 0x04
    2b56:	96 89       	ldd	r25, Z+22	; 0x16
    2b58:	80 91 3a 03 	lds	r24, 0x033A
    2b5c:	89 17       	cp	r24, r25
    2b5e:	28 f4       	brcc	.+10     	; 0x2b6a <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2b60:	eb 81       	ldd	r30, Y+3	; 0x03
    2b62:	fc 81       	ldd	r31, Y+4	; 0x04
    2b64:	86 89       	ldd	r24, Z+22	; 0x16
    2b66:	80 93 3a 03 	sts	0x033A, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2b6a:	80 91 41 03 	lds	r24, 0x0341
    2b6e:	8f 5f       	subi	r24, 0xFF	; 255
    2b70:	80 93 41 03 	sts	0x0341, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    2b74:	eb 81       	ldd	r30, Y+3	; 0x03
    2b76:	fc 81       	ldd	r31, Y+4	; 0x04
    2b78:	96 89       	ldd	r25, Z+22	; 0x16
    2b7a:	80 91 3b 03 	lds	r24, 0x033B
    2b7e:	89 17       	cp	r24, r25
    2b80:	28 f4       	brcc	.+10     	; 0x2b8c <xTaskGenericCreate+0x152>
    2b82:	eb 81       	ldd	r30, Y+3	; 0x03
    2b84:	fc 81       	ldd	r31, Y+4	; 0x04
    2b86:	86 89       	ldd	r24, Z+22	; 0x16
    2b88:	80 93 3b 03 	sts	0x033B, r24
    2b8c:	eb 81       	ldd	r30, Y+3	; 0x03
    2b8e:	fc 81       	ldd	r31, Y+4	; 0x04
    2b90:	86 89       	ldd	r24, Z+22	; 0x16
    2b92:	28 2f       	mov	r18, r24
    2b94:	30 e0       	ldi	r19, 0x00	; 0
    2b96:	c9 01       	movw	r24, r18
    2b98:	88 0f       	add	r24, r24
    2b9a:	99 1f       	adc	r25, r25
    2b9c:	88 0f       	add	r24, r24
    2b9e:	99 1f       	adc	r25, r25
    2ba0:	88 0f       	add	r24, r24
    2ba2:	99 1f       	adc	r25, r25
    2ba4:	82 0f       	add	r24, r18
    2ba6:	93 1f       	adc	r25, r19
    2ba8:	ac 01       	movw	r20, r24
    2baa:	4e 5b       	subi	r20, 0xBE	; 190
    2bac:	5c 4f       	sbci	r21, 0xFC	; 252
    2bae:	8b 81       	ldd	r24, Y+3	; 0x03
    2bb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2bb2:	9c 01       	movw	r18, r24
    2bb4:	2e 5f       	subi	r18, 0xFE	; 254
    2bb6:	3f 4f       	sbci	r19, 0xFF	; 255
    2bb8:	ca 01       	movw	r24, r20
    2bba:	b9 01       	movw	r22, r18
    2bbc:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>

			xReturn = pdPASS;
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
    2bc2:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2bc4:	0f 90       	pop	r0
    2bc6:	0f be       	out	0x3f, r0	; 63
    2bc8:	02 c0       	rjmp	.+4      	; 0x2bce <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2bca:	8f ef       	ldi	r24, 0xFF	; 255
    2bcc:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2bce:	8d 81       	ldd	r24, Y+5	; 0x05
    2bd0:	81 30       	cpi	r24, 0x01	; 1
    2bd2:	71 f4       	brne	.+28     	; 0x2bf0 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2bd4:	80 91 3c 03 	lds	r24, 0x033C
    2bd8:	88 23       	and	r24, r24
    2bda:	51 f0       	breq	.+20     	; 0x2bf0 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2bdc:	e0 91 34 03 	lds	r30, 0x0334
    2be0:	f0 91 35 03 	lds	r31, 0x0335
    2be4:	96 89       	ldd	r25, Z+22	; 0x16
    2be6:	8e 85       	ldd	r24, Y+14	; 0x0e
    2be8:	98 17       	cp	r25, r24
    2bea:	10 f4       	brcc	.+4      	; 0x2bf0 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2bec:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
			}
		}
	}

	return xReturn;
    2bf0:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2bf2:	64 96       	adiw	r28, 0x14	; 20
    2bf4:	0f b6       	in	r0, 0x3f	; 63
    2bf6:	f8 94       	cli
    2bf8:	de bf       	out	0x3e, r29	; 62
    2bfa:	0f be       	out	0x3f, r0	; 63
    2bfc:	cd bf       	out	0x3d, r28	; 61
    2bfe:	cf 91       	pop	r28
    2c00:	df 91       	pop	r29
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	df 90       	pop	r13
    2c0c:	cf 90       	pop	r12
    2c0e:	bf 90       	pop	r11
    2c10:	af 90       	pop	r10
    2c12:	08 95       	ret

00002c14 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    2c14:	df 93       	push	r29
    2c16:	cf 93       	push	r28
    2c18:	00 d0       	rcall	.+0      	; 0x2c1a <vTaskDelete+0x6>
    2c1a:	00 d0       	rcall	.+0      	; 0x2c1c <vTaskDelete+0x8>
    2c1c:	00 d0       	rcall	.+0      	; 0x2c1e <vTaskDelete+0xa>
    2c1e:	cd b7       	in	r28, 0x3d	; 61
    2c20:	de b7       	in	r29, 0x3e	; 62
    2c22:	9c 83       	std	Y+4, r25	; 0x04
    2c24:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2c26:	0f b6       	in	r0, 0x3f	; 63
    2c28:	f8 94       	cli
    2c2a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    2c2c:	20 91 34 03 	lds	r18, 0x0334
    2c30:	30 91 35 03 	lds	r19, 0x0335
    2c34:	8b 81       	ldd	r24, Y+3	; 0x03
    2c36:	9c 81       	ldd	r25, Y+4	; 0x04
    2c38:	82 17       	cp	r24, r18
    2c3a:	93 07       	cpc	r25, r19
    2c3c:	11 f4       	brne	.+4      	; 0x2c42 <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    2c3e:	1c 82       	std	Y+4, r1	; 0x04
    2c40:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    2c42:	8b 81       	ldd	r24, Y+3	; 0x03
    2c44:	9c 81       	ldd	r25, Y+4	; 0x04
    2c46:	00 97       	sbiw	r24, 0x00	; 0
    2c48:	39 f4       	brne	.+14     	; 0x2c58 <vTaskDelete+0x44>
    2c4a:	80 91 34 03 	lds	r24, 0x0334
    2c4e:	90 91 35 03 	lds	r25, 0x0335
    2c52:	9e 83       	std	Y+6, r25	; 0x06
    2c54:	8d 83       	std	Y+5, r24	; 0x05
    2c56:	04 c0       	rjmp	.+8      	; 0x2c60 <vTaskDelete+0x4c>
    2c58:	8b 81       	ldd	r24, Y+3	; 0x03
    2c5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2c5c:	9e 83       	std	Y+6, r25	; 0x06
    2c5e:	8d 83       	std	Y+5, r24	; 0x05
    2c60:	8d 81       	ldd	r24, Y+5	; 0x05
    2c62:	9e 81       	ldd	r25, Y+6	; 0x06
    2c64:	9a 83       	std	Y+2, r25	; 0x02
    2c66:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2c68:	89 81       	ldd	r24, Y+1	; 0x01
    2c6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6c:	02 96       	adiw	r24, 0x02	; 2
    2c6e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2c72:	e9 81       	ldd	r30, Y+1	; 0x01
    2c74:	fa 81       	ldd	r31, Y+2	; 0x02
    2c76:	84 89       	ldd	r24, Z+20	; 0x14
    2c78:	95 89       	ldd	r25, Z+21	; 0x15
    2c7a:	00 97       	sbiw	r24, 0x00	; 0
    2c7c:	29 f0       	breq	.+10     	; 0x2c88 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2c7e:	89 81       	ldd	r24, Y+1	; 0x01
    2c80:	9a 81       	ldd	r25, Y+2	; 0x02
    2c82:	0c 96       	adiw	r24, 0x0c	; 12
    2c84:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    2c88:	89 81       	ldd	r24, Y+1	; 0x01
    2c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8c:	9c 01       	movw	r18, r24
    2c8e:	2e 5f       	subi	r18, 0xFE	; 254
    2c90:	3f 4f       	sbci	r19, 0xFF	; 255
    2c92:	8c e7       	ldi	r24, 0x7C	; 124
    2c94:	93 e0       	ldi	r25, 0x03	; 3
    2c96:	b9 01       	movw	r22, r18
    2c98:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    2c9c:	80 91 36 03 	lds	r24, 0x0336
    2ca0:	8f 5f       	subi	r24, 0xFF	; 255
    2ca2:	80 93 36 03 	sts	0x0336, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    2ca6:	80 91 41 03 	lds	r24, 0x0341
    2caa:	8f 5f       	subi	r24, 0xFF	; 255
    2cac:	80 93 41 03 	sts	0x0341, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    2cb0:	0f 90       	pop	r0
    2cb2:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    2cb4:	80 91 3c 03 	lds	r24, 0x033C
    2cb8:	88 23       	and	r24, r24
    2cba:	31 f0       	breq	.+12     	; 0x2cc8 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    2cbc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cbe:	9c 81       	ldd	r25, Y+4	; 0x04
    2cc0:	00 97       	sbiw	r24, 0x00	; 0
    2cc2:	11 f4       	brne	.+4      	; 0x2cc8 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    2cc4:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
			}
		}
	}
    2cc8:	26 96       	adiw	r28, 0x06	; 6
    2cca:	0f b6       	in	r0, 0x3f	; 63
    2ccc:	f8 94       	cli
    2cce:	de bf       	out	0x3e, r29	; 62
    2cd0:	0f be       	out	0x3f, r0	; 63
    2cd2:	cd bf       	out	0x3d, r28	; 61
    2cd4:	cf 91       	pop	r28
    2cd6:	df 91       	pop	r29
    2cd8:	08 95       	ret

00002cda <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2cda:	df 93       	push	r29
    2cdc:	cf 93       	push	r28
    2cde:	cd b7       	in	r28, 0x3d	; 61
    2ce0:	de b7       	in	r29, 0x3e	; 62
    2ce2:	28 97       	sbiw	r28, 0x08	; 8
    2ce4:	0f b6       	in	r0, 0x3f	; 63
    2ce6:	f8 94       	cli
    2ce8:	de bf       	out	0x3e, r29	; 62
    2cea:	0f be       	out	0x3f, r0	; 63
    2cec:	cd bf       	out	0x3d, r28	; 61
    2cee:	9e 83       	std	Y+6, r25	; 0x06
    2cf0:	8d 83       	std	Y+5, r24	; 0x05
    2cf2:	78 87       	std	Y+8, r23	; 0x08
    2cf4:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2cf6:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2cf8:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2cfc:	ed 81       	ldd	r30, Y+5	; 0x05
    2cfe:	fe 81       	ldd	r31, Y+6	; 0x06
    2d00:	20 81       	ld	r18, Z
    2d02:	31 81       	ldd	r19, Z+1	; 0x01
    2d04:	8f 81       	ldd	r24, Y+7	; 0x07
    2d06:	98 85       	ldd	r25, Y+8	; 0x08
    2d08:	82 0f       	add	r24, r18
    2d0a:	93 1f       	adc	r25, r19
    2d0c:	9c 83       	std	Y+4, r25	; 0x04
    2d0e:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    2d10:	ed 81       	ldd	r30, Y+5	; 0x05
    2d12:	fe 81       	ldd	r31, Y+6	; 0x06
    2d14:	20 81       	ld	r18, Z
    2d16:	31 81       	ldd	r19, Z+1	; 0x01
    2d18:	80 91 38 03 	lds	r24, 0x0338
    2d1c:	90 91 39 03 	lds	r25, 0x0339
    2d20:	82 17       	cp	r24, r18
    2d22:	93 07       	cpc	r25, r19
    2d24:	a8 f4       	brcc	.+42     	; 0x2d50 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    2d26:	ed 81       	ldd	r30, Y+5	; 0x05
    2d28:	fe 81       	ldd	r31, Y+6	; 0x06
    2d2a:	20 81       	ld	r18, Z
    2d2c:	31 81       	ldd	r19, Z+1	; 0x01
    2d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d30:	9c 81       	ldd	r25, Y+4	; 0x04
    2d32:	82 17       	cp	r24, r18
    2d34:	93 07       	cpc	r25, r19
    2d36:	00 f5       	brcc	.+64     	; 0x2d78 <vTaskDelayUntil+0x9e>
    2d38:	20 91 38 03 	lds	r18, 0x0338
    2d3c:	30 91 39 03 	lds	r19, 0x0339
    2d40:	8b 81       	ldd	r24, Y+3	; 0x03
    2d42:	9c 81       	ldd	r25, Y+4	; 0x04
    2d44:	28 17       	cp	r18, r24
    2d46:	39 07       	cpc	r19, r25
    2d48:	b8 f4       	brcc	.+46     	; 0x2d78 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2d4a:	81 e0       	ldi	r24, 0x01	; 1
    2d4c:	89 83       	std	Y+1, r24	; 0x01
    2d4e:	14 c0       	rjmp	.+40     	; 0x2d78 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    2d50:	ed 81       	ldd	r30, Y+5	; 0x05
    2d52:	fe 81       	ldd	r31, Y+6	; 0x06
    2d54:	20 81       	ld	r18, Z
    2d56:	31 81       	ldd	r19, Z+1	; 0x01
    2d58:	8b 81       	ldd	r24, Y+3	; 0x03
    2d5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d5c:	82 17       	cp	r24, r18
    2d5e:	93 07       	cpc	r25, r19
    2d60:	48 f0       	brcs	.+18     	; 0x2d74 <vTaskDelayUntil+0x9a>
    2d62:	20 91 38 03 	lds	r18, 0x0338
    2d66:	30 91 39 03 	lds	r19, 0x0339
    2d6a:	8b 81       	ldd	r24, Y+3	; 0x03
    2d6c:	9c 81       	ldd	r25, Y+4	; 0x04
    2d6e:	28 17       	cp	r18, r24
    2d70:	39 07       	cpc	r19, r25
    2d72:	10 f4       	brcc	.+4      	; 0x2d78 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2d74:	81 e0       	ldi	r24, 0x01	; 1
    2d76:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2d78:	ed 81       	ldd	r30, Y+5	; 0x05
    2d7a:	fe 81       	ldd	r31, Y+6	; 0x06
    2d7c:	8b 81       	ldd	r24, Y+3	; 0x03
    2d7e:	9c 81       	ldd	r25, Y+4	; 0x04
    2d80:	91 83       	std	Z+1, r25	; 0x01
    2d82:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2d84:	89 81       	ldd	r24, Y+1	; 0x01
    2d86:	88 23       	and	r24, r24
    2d88:	59 f0       	breq	.+22     	; 0x2da0 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2d8a:	80 91 34 03 	lds	r24, 0x0334
    2d8e:	90 91 35 03 	lds	r25, 0x0335
    2d92:	02 96       	adiw	r24, 0x02	; 2
    2d94:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2d98:	8b 81       	ldd	r24, Y+3	; 0x03
    2d9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2d9c:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    2da0:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    2da4:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2da6:	8a 81       	ldd	r24, Y+2	; 0x02
    2da8:	88 23       	and	r24, r24
    2daa:	11 f4       	brne	.+4      	; 0x2db0 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    2dac:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
		}
	}
    2db0:	28 96       	adiw	r28, 0x08	; 8
    2db2:	0f b6       	in	r0, 0x3f	; 63
    2db4:	f8 94       	cli
    2db6:	de bf       	out	0x3e, r29	; 62
    2db8:	0f be       	out	0x3f, r0	; 63
    2dba:	cd bf       	out	0x3d, r28	; 61
    2dbc:	cf 91       	pop	r28
    2dbe:	df 91       	pop	r29
    2dc0:	08 95       	ret

00002dc2 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2dc2:	df 93       	push	r29
    2dc4:	cf 93       	push	r28
    2dc6:	00 d0       	rcall	.+0      	; 0x2dc8 <vTaskDelay+0x6>
    2dc8:	00 d0       	rcall	.+0      	; 0x2dca <vTaskDelay+0x8>
    2dca:	0f 92       	push	r0
    2dcc:	cd b7       	in	r28, 0x3d	; 61
    2dce:	de b7       	in	r29, 0x3e	; 62
    2dd0:	9d 83       	std	Y+5, r25	; 0x05
    2dd2:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2dd4:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2dd6:	8c 81       	ldd	r24, Y+4	; 0x04
    2dd8:	9d 81       	ldd	r25, Y+5	; 0x05
    2dda:	00 97       	sbiw	r24, 0x00	; 0
    2ddc:	d1 f0       	breq	.+52     	; 0x2e12 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    2dde:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2de2:	20 91 38 03 	lds	r18, 0x0338
    2de6:	30 91 39 03 	lds	r19, 0x0339
    2dea:	8c 81       	ldd	r24, Y+4	; 0x04
    2dec:	9d 81       	ldd	r25, Y+5	; 0x05
    2dee:	82 0f       	add	r24, r18
    2df0:	93 1f       	adc	r25, r19
    2df2:	9b 83       	std	Y+3, r25	; 0x03
    2df4:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2df6:	80 91 34 03 	lds	r24, 0x0334
    2dfa:	90 91 35 03 	lds	r25, 0x0335
    2dfe:	02 96       	adiw	r24, 0x02	; 2
    2e00:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2e04:	8a 81       	ldd	r24, Y+2	; 0x02
    2e06:	9b 81       	ldd	r25, Y+3	; 0x03
    2e08:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    2e0c:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>
    2e10:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2e12:	89 81       	ldd	r24, Y+1	; 0x01
    2e14:	88 23       	and	r24, r24
    2e16:	11 f4       	brne	.+4      	; 0x2e1c <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    2e18:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
		}
	}
    2e1c:	0f 90       	pop	r0
    2e1e:	0f 90       	pop	r0
    2e20:	0f 90       	pop	r0
    2e22:	0f 90       	pop	r0
    2e24:	0f 90       	pop	r0
    2e26:	cf 91       	pop	r28
    2e28:	df 91       	pop	r29
    2e2a:	08 95       	ret

00002e2c <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2e2c:	af 92       	push	r10
    2e2e:	bf 92       	push	r11
    2e30:	cf 92       	push	r12
    2e32:	df 92       	push	r13
    2e34:	ef 92       	push	r14
    2e36:	ff 92       	push	r15
    2e38:	0f 93       	push	r16
    2e3a:	df 93       	push	r29
    2e3c:	cf 93       	push	r28
    2e3e:	0f 92       	push	r0
    2e40:	cd b7       	in	r28, 0x3d	; 61
    2e42:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2e44:	20 e9       	ldi	r18, 0x90	; 144
    2e46:	30 e0       	ldi	r19, 0x00	; 0
    2e48:	8d e7       	ldi	r24, 0x7D	; 125
    2e4a:	9a e1       	ldi	r25, 0x1A	; 26
    2e4c:	b9 01       	movw	r22, r18
    2e4e:	45 e5       	ldi	r20, 0x55	; 85
    2e50:	50 e0       	ldi	r21, 0x00	; 0
    2e52:	20 e0       	ldi	r18, 0x00	; 0
    2e54:	30 e0       	ldi	r19, 0x00	; 0
    2e56:	00 e0       	ldi	r16, 0x00	; 0
    2e58:	ee 24       	eor	r14, r14
    2e5a:	ff 24       	eor	r15, r15
    2e5c:	cc 24       	eor	r12, r12
    2e5e:	dd 24       	eor	r13, r13
    2e60:	aa 24       	eor	r10, r10
    2e62:	bb 24       	eor	r11, r11
    2e64:	0e 94 1d 15 	call	0x2a3a	; 0x2a3a <xTaskGenericCreate>
    2e68:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2e6a:	89 81       	ldd	r24, Y+1	; 0x01
    2e6c:	81 30       	cpi	r24, 0x01	; 1
    2e6e:	51 f4       	brne	.+20     	; 0x2e84 <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2e70:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2e72:	81 e0       	ldi	r24, 0x01	; 1
    2e74:	80 93 3c 03 	sts	0x033C, r24
		xTickCount = ( portTickType ) 0U;
    2e78:	10 92 39 03 	sts	0x0339, r1
    2e7c:	10 92 38 03 	sts	0x0338, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2e80:	0e 94 4d 0f 	call	0x1e9a	; 0x1e9a <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2e84:	0f 90       	pop	r0
    2e86:	cf 91       	pop	r28
    2e88:	df 91       	pop	r29
    2e8a:	0f 91       	pop	r16
    2e8c:	ff 90       	pop	r15
    2e8e:	ef 90       	pop	r14
    2e90:	df 90       	pop	r13
    2e92:	cf 90       	pop	r12
    2e94:	bf 90       	pop	r11
    2e96:	af 90       	pop	r10
    2e98:	08 95       	ret

00002e9a <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2e9a:	df 93       	push	r29
    2e9c:	cf 93       	push	r28
    2e9e:	cd b7       	in	r28, 0x3d	; 61
    2ea0:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2ea2:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2ea4:	10 92 3c 03 	sts	0x033C, r1
	vPortEndScheduler();
    2ea8:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortEndScheduler>
}
    2eac:	cf 91       	pop	r28
    2eae:	df 91       	pop	r29
    2eb0:	08 95       	ret

00002eb2 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2eb2:	df 93       	push	r29
    2eb4:	cf 93       	push	r28
    2eb6:	cd b7       	in	r28, 0x3d	; 61
    2eb8:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2eba:	80 91 3d 03 	lds	r24, 0x033D
    2ebe:	8f 5f       	subi	r24, 0xFF	; 255
    2ec0:	80 93 3d 03 	sts	0x033D, r24
}
    2ec4:	cf 91       	pop	r28
    2ec6:	df 91       	pop	r29
    2ec8:	08 95       	ret

00002eca <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2eca:	df 93       	push	r29
    2ecc:	cf 93       	push	r28
    2ece:	00 d0       	rcall	.+0      	; 0x2ed0 <xTaskResumeAll+0x6>
    2ed0:	00 d0       	rcall	.+0      	; 0x2ed2 <xTaskResumeAll+0x8>
    2ed2:	cd b7       	in	r28, 0x3d	; 61
    2ed4:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2ed6:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2ed8:	0f b6       	in	r0, 0x3f	; 63
    2eda:	f8 94       	cli
    2edc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2ede:	80 91 3d 03 	lds	r24, 0x033D
    2ee2:	81 50       	subi	r24, 0x01	; 1
    2ee4:	80 93 3d 03 	sts	0x033D, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2ee8:	80 91 3d 03 	lds	r24, 0x033D
    2eec:	88 23       	and	r24, r24
    2eee:	09 f0       	breq	.+2      	; 0x2ef2 <xTaskResumeAll+0x28>
    2ef0:	6c c0       	rjmp	.+216    	; 0x2fca <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2ef2:	80 91 37 03 	lds	r24, 0x0337
    2ef6:	88 23       	and	r24, r24
    2ef8:	09 f4       	brne	.+2      	; 0x2efc <xTaskResumeAll+0x32>
    2efa:	67 c0       	rjmp	.+206    	; 0x2fca <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2efc:	19 82       	std	Y+1, r1	; 0x01
    2efe:	41 c0       	rjmp	.+130    	; 0x2f82 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2f00:	e0 91 78 03 	lds	r30, 0x0378
    2f04:	f0 91 79 03 	lds	r31, 0x0379
    2f08:	86 81       	ldd	r24, Z+6	; 0x06
    2f0a:	97 81       	ldd	r25, Z+7	; 0x07
    2f0c:	9c 83       	std	Y+4, r25	; 0x04
    2f0e:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2f10:	8b 81       	ldd	r24, Y+3	; 0x03
    2f12:	9c 81       	ldd	r25, Y+4	; 0x04
    2f14:	0c 96       	adiw	r24, 0x0c	; 12
    2f16:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2f1a:	8b 81       	ldd	r24, Y+3	; 0x03
    2f1c:	9c 81       	ldd	r25, Y+4	; 0x04
    2f1e:	02 96       	adiw	r24, 0x02	; 2
    2f20:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2f24:	eb 81       	ldd	r30, Y+3	; 0x03
    2f26:	fc 81       	ldd	r31, Y+4	; 0x04
    2f28:	96 89       	ldd	r25, Z+22	; 0x16
    2f2a:	80 91 3b 03 	lds	r24, 0x033B
    2f2e:	89 17       	cp	r24, r25
    2f30:	28 f4       	brcc	.+10     	; 0x2f3c <xTaskResumeAll+0x72>
    2f32:	eb 81       	ldd	r30, Y+3	; 0x03
    2f34:	fc 81       	ldd	r31, Y+4	; 0x04
    2f36:	86 89       	ldd	r24, Z+22	; 0x16
    2f38:	80 93 3b 03 	sts	0x033B, r24
    2f3c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f3e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f40:	86 89       	ldd	r24, Z+22	; 0x16
    2f42:	28 2f       	mov	r18, r24
    2f44:	30 e0       	ldi	r19, 0x00	; 0
    2f46:	c9 01       	movw	r24, r18
    2f48:	88 0f       	add	r24, r24
    2f4a:	99 1f       	adc	r25, r25
    2f4c:	88 0f       	add	r24, r24
    2f4e:	99 1f       	adc	r25, r25
    2f50:	88 0f       	add	r24, r24
    2f52:	99 1f       	adc	r25, r25
    2f54:	82 0f       	add	r24, r18
    2f56:	93 1f       	adc	r25, r19
    2f58:	8e 5b       	subi	r24, 0xBE	; 190
    2f5a:	9c 4f       	sbci	r25, 0xFC	; 252
    2f5c:	2b 81       	ldd	r18, Y+3	; 0x03
    2f5e:	3c 81       	ldd	r19, Y+4	; 0x04
    2f60:	2e 5f       	subi	r18, 0xFE	; 254
    2f62:	3f 4f       	sbci	r19, 0xFF	; 255
    2f64:	b9 01       	movw	r22, r18
    2f66:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f6a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6e:	96 89       	ldd	r25, Z+22	; 0x16
    2f70:	e0 91 34 03 	lds	r30, 0x0334
    2f74:	f0 91 35 03 	lds	r31, 0x0335
    2f78:	86 89       	ldd	r24, Z+22	; 0x16
    2f7a:	98 17       	cp	r25, r24
    2f7c:	10 f0       	brcs	.+4      	; 0x2f82 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2f7e:	81 e0       	ldi	r24, 0x01	; 1
    2f80:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2f82:	80 91 73 03 	lds	r24, 0x0373
    2f86:	88 23       	and	r24, r24
    2f88:	09 f0       	breq	.+2      	; 0x2f8c <xTaskResumeAll+0xc2>
    2f8a:	ba cf       	rjmp	.-140    	; 0x2f00 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f8c:	80 91 3e 03 	lds	r24, 0x033E
    2f90:	88 23       	and	r24, r24
    2f92:	71 f0       	breq	.+28     	; 0x2fb0 <xTaskResumeAll+0xe6>
    2f94:	07 c0       	rjmp	.+14     	; 0x2fa4 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2f96:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskIncrementTick>
						--uxMissedTicks;
    2f9a:	80 91 3e 03 	lds	r24, 0x033E
    2f9e:	81 50       	subi	r24, 0x01	; 1
    2fa0:	80 93 3e 03 	sts	0x033E, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2fa4:	80 91 3e 03 	lds	r24, 0x033E
    2fa8:	88 23       	and	r24, r24
    2faa:	a9 f7       	brne	.-22     	; 0x2f96 <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    2fac:	81 e0       	ldi	r24, 0x01	; 1
    2fae:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2fb0:	89 81       	ldd	r24, Y+1	; 0x01
    2fb2:	81 30       	cpi	r24, 0x01	; 1
    2fb4:	21 f0       	breq	.+8      	; 0x2fbe <xTaskResumeAll+0xf4>
    2fb6:	80 91 3f 03 	lds	r24, 0x033F
    2fba:	81 30       	cpi	r24, 0x01	; 1
    2fbc:	31 f4       	brne	.+12     	; 0x2fca <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2fc2:	10 92 3f 03 	sts	0x033F, r1
					portYIELD_WITHIN_API();
    2fc6:	0e 94 89 0f 	call	0x1f12	; 0x1f12 <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2fca:	0f 90       	pop	r0
    2fcc:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2fce:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2fd0:	0f 90       	pop	r0
    2fd2:	0f 90       	pop	r0
    2fd4:	0f 90       	pop	r0
    2fd6:	0f 90       	pop	r0
    2fd8:	cf 91       	pop	r28
    2fda:	df 91       	pop	r29
    2fdc:	08 95       	ret

00002fde <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2fde:	df 93       	push	r29
    2fe0:	cf 93       	push	r28
    2fe2:	00 d0       	rcall	.+0      	; 0x2fe4 <xTaskGetTickCount+0x6>
    2fe4:	cd b7       	in	r28, 0x3d	; 61
    2fe6:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2fe8:	0f b6       	in	r0, 0x3f	; 63
    2fea:	f8 94       	cli
    2fec:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2fee:	80 91 38 03 	lds	r24, 0x0338
    2ff2:	90 91 39 03 	lds	r25, 0x0339
    2ff6:	9a 83       	std	Y+2, r25	; 0x02
    2ff8:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2ffa:	0f 90       	pop	r0
    2ffc:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2ffe:	89 81       	ldd	r24, Y+1	; 0x01
    3000:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3002:	0f 90       	pop	r0
    3004:	0f 90       	pop	r0
    3006:	cf 91       	pop	r28
    3008:	df 91       	pop	r29
    300a:	08 95       	ret

0000300c <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    300c:	df 93       	push	r29
    300e:	cf 93       	push	r28
    3010:	00 d0       	rcall	.+0      	; 0x3012 <xTaskGetTickCountFromISR+0x6>
    3012:	0f 92       	push	r0
    3014:	cd b7       	in	r28, 0x3d	; 61
    3016:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3018:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    301a:	80 91 38 03 	lds	r24, 0x0338
    301e:	90 91 39 03 	lds	r25, 0x0339
    3022:	9b 83       	std	Y+3, r25	; 0x03
    3024:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	9b 81       	ldd	r25, Y+3	; 0x03
}
    302a:	0f 90       	pop	r0
    302c:	0f 90       	pop	r0
    302e:	0f 90       	pop	r0
    3030:	cf 91       	pop	r28
    3032:	df 91       	pop	r29
    3034:	08 95       	ret

00003036 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    3036:	df 93       	push	r29
    3038:	cf 93       	push	r28
    303a:	cd b7       	in	r28, 0x3d	; 61
    303c:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    303e:	80 91 37 03 	lds	r24, 0x0337
}
    3042:	cf 91       	pop	r28
    3044:	df 91       	pop	r29
    3046:	08 95       	ret

00003048 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    3048:	df 93       	push	r29
    304a:	cf 93       	push	r28
    304c:	00 d0       	rcall	.+0      	; 0x304e <vTaskIncrementTick+0x6>
    304e:	00 d0       	rcall	.+0      	; 0x3050 <vTaskIncrementTick+0x8>
    3050:	00 d0       	rcall	.+0      	; 0x3052 <vTaskIncrementTick+0xa>
    3052:	cd b7       	in	r28, 0x3d	; 61
    3054:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3056:	80 91 3d 03 	lds	r24, 0x033D
    305a:	88 23       	and	r24, r24
    305c:	09 f0       	breq	.+2      	; 0x3060 <vTaskIncrementTick+0x18>
    305e:	bb c0       	rjmp	.+374    	; 0x31d6 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    3060:	80 91 38 03 	lds	r24, 0x0338
    3064:	90 91 39 03 	lds	r25, 0x0339
    3068:	01 96       	adiw	r24, 0x01	; 1
    306a:	90 93 39 03 	sts	0x0339, r25
    306e:	80 93 38 03 	sts	0x0338, r24
		if( xTickCount == ( portTickType ) 0U )
    3072:	80 91 38 03 	lds	r24, 0x0338
    3076:	90 91 39 03 	lds	r25, 0x0339
    307a:	00 97       	sbiw	r24, 0x00	; 0
    307c:	d1 f5       	brne	.+116    	; 0x30f2 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    307e:	80 91 6f 03 	lds	r24, 0x036F
    3082:	90 91 70 03 	lds	r25, 0x0370
    3086:	9c 83       	std	Y+4, r25	; 0x04
    3088:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    308a:	80 91 71 03 	lds	r24, 0x0371
    308e:	90 91 72 03 	lds	r25, 0x0372
    3092:	90 93 70 03 	sts	0x0370, r25
    3096:	80 93 6f 03 	sts	0x036F, r24
			pxOverflowDelayedTaskList = pxTemp;
    309a:	8b 81       	ldd	r24, Y+3	; 0x03
    309c:	9c 81       	ldd	r25, Y+4	; 0x04
    309e:	90 93 72 03 	sts	0x0372, r25
    30a2:	80 93 71 03 	sts	0x0371, r24
			xNumOfOverflows++;
    30a6:	80 91 40 03 	lds	r24, 0x0340
    30aa:	8f 5f       	subi	r24, 0xFF	; 255
    30ac:	80 93 40 03 	sts	0x0340, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    30b0:	e0 91 6f 03 	lds	r30, 0x036F
    30b4:	f0 91 70 03 	lds	r31, 0x0370
    30b8:	80 81       	ld	r24, Z
    30ba:	88 23       	and	r24, r24
    30bc:	39 f4       	brne	.+14     	; 0x30cc <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    30be:	8f ef       	ldi	r24, 0xFF	; 255
    30c0:	9f ef       	ldi	r25, 0xFF	; 255
    30c2:	90 93 9e 00 	sts	0x009E, r25
    30c6:	80 93 9d 00 	sts	0x009D, r24
    30ca:	13 c0       	rjmp	.+38     	; 0x30f2 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    30cc:	e0 91 6f 03 	lds	r30, 0x036F
    30d0:	f0 91 70 03 	lds	r31, 0x0370
    30d4:	05 80       	ldd	r0, Z+5	; 0x05
    30d6:	f6 81       	ldd	r31, Z+6	; 0x06
    30d8:	e0 2d       	mov	r30, r0
    30da:	86 81       	ldd	r24, Z+6	; 0x06
    30dc:	97 81       	ldd	r25, Z+7	; 0x07
    30de:	9e 83       	std	Y+6, r25	; 0x06
    30e0:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    30e2:	ed 81       	ldd	r30, Y+5	; 0x05
    30e4:	fe 81       	ldd	r31, Y+6	; 0x06
    30e6:	82 81       	ldd	r24, Z+2	; 0x02
    30e8:	93 81       	ldd	r25, Z+3	; 0x03
    30ea:	90 93 9e 00 	sts	0x009E, r25
    30ee:	80 93 9d 00 	sts	0x009D, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    30f2:	20 91 38 03 	lds	r18, 0x0338
    30f6:	30 91 39 03 	lds	r19, 0x0339
    30fa:	80 91 9d 00 	lds	r24, 0x009D
    30fe:	90 91 9e 00 	lds	r25, 0x009E
    3102:	28 17       	cp	r18, r24
    3104:	39 07       	cpc	r19, r25
    3106:	08 f4       	brcc	.+2      	; 0x310a <vTaskIncrementTick+0xc2>
    3108:	6b c0       	rjmp	.+214    	; 0x31e0 <vTaskIncrementTick+0x198>
    310a:	e0 91 6f 03 	lds	r30, 0x036F
    310e:	f0 91 70 03 	lds	r31, 0x0370
    3112:	80 81       	ld	r24, Z
    3114:	88 23       	and	r24, r24
    3116:	39 f4       	brne	.+14     	; 0x3126 <vTaskIncrementTick+0xde>
    3118:	8f ef       	ldi	r24, 0xFF	; 255
    311a:	9f ef       	ldi	r25, 0xFF	; 255
    311c:	90 93 9e 00 	sts	0x009E, r25
    3120:	80 93 9d 00 	sts	0x009D, r24
    3124:	5d c0       	rjmp	.+186    	; 0x31e0 <vTaskIncrementTick+0x198>
    3126:	e0 91 6f 03 	lds	r30, 0x036F
    312a:	f0 91 70 03 	lds	r31, 0x0370
    312e:	05 80       	ldd	r0, Z+5	; 0x05
    3130:	f6 81       	ldd	r31, Z+6	; 0x06
    3132:	e0 2d       	mov	r30, r0
    3134:	86 81       	ldd	r24, Z+6	; 0x06
    3136:	97 81       	ldd	r25, Z+7	; 0x07
    3138:	9e 83       	std	Y+6, r25	; 0x06
    313a:	8d 83       	std	Y+5, r24	; 0x05
    313c:	ed 81       	ldd	r30, Y+5	; 0x05
    313e:	fe 81       	ldd	r31, Y+6	; 0x06
    3140:	82 81       	ldd	r24, Z+2	; 0x02
    3142:	93 81       	ldd	r25, Z+3	; 0x03
    3144:	9a 83       	std	Y+2, r25	; 0x02
    3146:	89 83       	std	Y+1, r24	; 0x01
    3148:	20 91 38 03 	lds	r18, 0x0338
    314c:	30 91 39 03 	lds	r19, 0x0339
    3150:	89 81       	ldd	r24, Y+1	; 0x01
    3152:	9a 81       	ldd	r25, Y+2	; 0x02
    3154:	28 17       	cp	r18, r24
    3156:	39 07       	cpc	r19, r25
    3158:	38 f4       	brcc	.+14     	; 0x3168 <vTaskIncrementTick+0x120>
    315a:	89 81       	ldd	r24, Y+1	; 0x01
    315c:	9a 81       	ldd	r25, Y+2	; 0x02
    315e:	90 93 9e 00 	sts	0x009E, r25
    3162:	80 93 9d 00 	sts	0x009D, r24
    3166:	3c c0       	rjmp	.+120    	; 0x31e0 <vTaskIncrementTick+0x198>
    3168:	8d 81       	ldd	r24, Y+5	; 0x05
    316a:	9e 81       	ldd	r25, Y+6	; 0x06
    316c:	02 96       	adiw	r24, 0x02	; 2
    316e:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
    3172:	ed 81       	ldd	r30, Y+5	; 0x05
    3174:	fe 81       	ldd	r31, Y+6	; 0x06
    3176:	84 89       	ldd	r24, Z+20	; 0x14
    3178:	95 89       	ldd	r25, Z+21	; 0x15
    317a:	00 97       	sbiw	r24, 0x00	; 0
    317c:	29 f0       	breq	.+10     	; 0x3188 <vTaskIncrementTick+0x140>
    317e:	8d 81       	ldd	r24, Y+5	; 0x05
    3180:	9e 81       	ldd	r25, Y+6	; 0x06
    3182:	0c 96       	adiw	r24, 0x0c	; 12
    3184:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
    3188:	ed 81       	ldd	r30, Y+5	; 0x05
    318a:	fe 81       	ldd	r31, Y+6	; 0x06
    318c:	96 89       	ldd	r25, Z+22	; 0x16
    318e:	80 91 3b 03 	lds	r24, 0x033B
    3192:	89 17       	cp	r24, r25
    3194:	28 f4       	brcc	.+10     	; 0x31a0 <vTaskIncrementTick+0x158>
    3196:	ed 81       	ldd	r30, Y+5	; 0x05
    3198:	fe 81       	ldd	r31, Y+6	; 0x06
    319a:	86 89       	ldd	r24, Z+22	; 0x16
    319c:	80 93 3b 03 	sts	0x033B, r24
    31a0:	ed 81       	ldd	r30, Y+5	; 0x05
    31a2:	fe 81       	ldd	r31, Y+6	; 0x06
    31a4:	86 89       	ldd	r24, Z+22	; 0x16
    31a6:	28 2f       	mov	r18, r24
    31a8:	30 e0       	ldi	r19, 0x00	; 0
    31aa:	c9 01       	movw	r24, r18
    31ac:	88 0f       	add	r24, r24
    31ae:	99 1f       	adc	r25, r25
    31b0:	88 0f       	add	r24, r24
    31b2:	99 1f       	adc	r25, r25
    31b4:	88 0f       	add	r24, r24
    31b6:	99 1f       	adc	r25, r25
    31b8:	82 0f       	add	r24, r18
    31ba:	93 1f       	adc	r25, r19
    31bc:	ac 01       	movw	r20, r24
    31be:	4e 5b       	subi	r20, 0xBE	; 190
    31c0:	5c 4f       	sbci	r21, 0xFC	; 252
    31c2:	8d 81       	ldd	r24, Y+5	; 0x05
    31c4:	9e 81       	ldd	r25, Y+6	; 0x06
    31c6:	9c 01       	movw	r18, r24
    31c8:	2e 5f       	subi	r18, 0xFE	; 254
    31ca:	3f 4f       	sbci	r19, 0xFF	; 255
    31cc:	ca 01       	movw	r24, r20
    31ce:	b9 01       	movw	r22, r18
    31d0:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>
    31d4:	9a cf       	rjmp	.-204    	; 0x310a <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    31d6:	80 91 3e 03 	lds	r24, 0x033E
    31da:	8f 5f       	subi	r24, 0xFF	; 255
    31dc:	80 93 3e 03 	sts	0x033E, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    31e0:	26 96       	adiw	r28, 0x06	; 6
    31e2:	0f b6       	in	r0, 0x3f	; 63
    31e4:	f8 94       	cli
    31e6:	de bf       	out	0x3e, r29	; 62
    31e8:	0f be       	out	0x3f, r0	; 63
    31ea:	cd bf       	out	0x3d, r28	; 61
    31ec:	cf 91       	pop	r28
    31ee:	df 91       	pop	r29
    31f0:	08 95       	ret

000031f2 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    31f2:	df 93       	push	r29
    31f4:	cf 93       	push	r28
    31f6:	00 d0       	rcall	.+0      	; 0x31f8 <vTaskSwitchContext+0x6>
    31f8:	cd b7       	in	r28, 0x3d	; 61
    31fa:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    31fc:	80 91 3d 03 	lds	r24, 0x033D
    3200:	88 23       	and	r24, r24
    3202:	49 f0       	breq	.+18     	; 0x3216 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    3204:	81 e0       	ldi	r24, 0x01	; 1
    3206:	80 93 3f 03 	sts	0x033F, r24
    320a:	54 c0       	rjmp	.+168    	; 0x32b4 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    320c:	80 91 3b 03 	lds	r24, 0x033B
    3210:	81 50       	subi	r24, 0x01	; 1
    3212:	80 93 3b 03 	sts	0x033B, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    3216:	80 91 3b 03 	lds	r24, 0x033B
    321a:	28 2f       	mov	r18, r24
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	c9 01       	movw	r24, r18
    3220:	88 0f       	add	r24, r24
    3222:	99 1f       	adc	r25, r25
    3224:	88 0f       	add	r24, r24
    3226:	99 1f       	adc	r25, r25
    3228:	88 0f       	add	r24, r24
    322a:	99 1f       	adc	r25, r25
    322c:	82 0f       	add	r24, r18
    322e:	93 1f       	adc	r25, r19
    3230:	fc 01       	movw	r30, r24
    3232:	ee 5b       	subi	r30, 0xBE	; 190
    3234:	fc 4f       	sbci	r31, 0xFC	; 252
    3236:	80 81       	ld	r24, Z
    3238:	88 23       	and	r24, r24
    323a:	41 f3       	breq	.-48     	; 0x320c <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    323c:	80 91 3b 03 	lds	r24, 0x033B
    3240:	28 2f       	mov	r18, r24
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	c9 01       	movw	r24, r18
    3246:	88 0f       	add	r24, r24
    3248:	99 1f       	adc	r25, r25
    324a:	88 0f       	add	r24, r24
    324c:	99 1f       	adc	r25, r25
    324e:	88 0f       	add	r24, r24
    3250:	99 1f       	adc	r25, r25
    3252:	82 0f       	add	r24, r18
    3254:	93 1f       	adc	r25, r19
    3256:	8e 5b       	subi	r24, 0xBE	; 190
    3258:	9c 4f       	sbci	r25, 0xFC	; 252
    325a:	9a 83       	std	Y+2, r25	; 0x02
    325c:	89 83       	std	Y+1, r24	; 0x01
    325e:	e9 81       	ldd	r30, Y+1	; 0x01
    3260:	fa 81       	ldd	r31, Y+2	; 0x02
    3262:	01 80       	ldd	r0, Z+1	; 0x01
    3264:	f2 81       	ldd	r31, Z+2	; 0x02
    3266:	e0 2d       	mov	r30, r0
    3268:	82 81       	ldd	r24, Z+2	; 0x02
    326a:	93 81       	ldd	r25, Z+3	; 0x03
    326c:	e9 81       	ldd	r30, Y+1	; 0x01
    326e:	fa 81       	ldd	r31, Y+2	; 0x02
    3270:	92 83       	std	Z+2, r25	; 0x02
    3272:	81 83       	std	Z+1, r24	; 0x01
    3274:	e9 81       	ldd	r30, Y+1	; 0x01
    3276:	fa 81       	ldd	r31, Y+2	; 0x02
    3278:	21 81       	ldd	r18, Z+1	; 0x01
    327a:	32 81       	ldd	r19, Z+2	; 0x02
    327c:	89 81       	ldd	r24, Y+1	; 0x01
    327e:	9a 81       	ldd	r25, Y+2	; 0x02
    3280:	03 96       	adiw	r24, 0x03	; 3
    3282:	28 17       	cp	r18, r24
    3284:	39 07       	cpc	r19, r25
    3286:	59 f4       	brne	.+22     	; 0x329e <vTaskSwitchContext+0xac>
    3288:	e9 81       	ldd	r30, Y+1	; 0x01
    328a:	fa 81       	ldd	r31, Y+2	; 0x02
    328c:	01 80       	ldd	r0, Z+1	; 0x01
    328e:	f2 81       	ldd	r31, Z+2	; 0x02
    3290:	e0 2d       	mov	r30, r0
    3292:	82 81       	ldd	r24, Z+2	; 0x02
    3294:	93 81       	ldd	r25, Z+3	; 0x03
    3296:	e9 81       	ldd	r30, Y+1	; 0x01
    3298:	fa 81       	ldd	r31, Y+2	; 0x02
    329a:	92 83       	std	Z+2, r25	; 0x02
    329c:	81 83       	std	Z+1, r24	; 0x01
    329e:	e9 81       	ldd	r30, Y+1	; 0x01
    32a0:	fa 81       	ldd	r31, Y+2	; 0x02
    32a2:	01 80       	ldd	r0, Z+1	; 0x01
    32a4:	f2 81       	ldd	r31, Z+2	; 0x02
    32a6:	e0 2d       	mov	r30, r0
    32a8:	86 81       	ldd	r24, Z+6	; 0x06
    32aa:	97 81       	ldd	r25, Z+7	; 0x07
    32ac:	90 93 35 03 	sts	0x0335, r25
    32b0:	80 93 34 03 	sts	0x0334, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    32b4:	0f 90       	pop	r0
    32b6:	0f 90       	pop	r0
    32b8:	cf 91       	pop	r28
    32ba:	df 91       	pop	r29
    32bc:	08 95       	ret

000032be <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    32be:	df 93       	push	r29
    32c0:	cf 93       	push	r28
    32c2:	00 d0       	rcall	.+0      	; 0x32c4 <vTaskPlaceOnEventList+0x6>
    32c4:	00 d0       	rcall	.+0      	; 0x32c6 <vTaskPlaceOnEventList+0x8>
    32c6:	00 d0       	rcall	.+0      	; 0x32c8 <vTaskPlaceOnEventList+0xa>
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
    32cc:	9c 83       	std	Y+4, r25	; 0x04
    32ce:	8b 83       	std	Y+3, r24	; 0x03
    32d0:	7e 83       	std	Y+6, r23	; 0x06
    32d2:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    32d4:	4b 81       	ldd	r20, Y+3	; 0x03
    32d6:	5c 81       	ldd	r21, Y+4	; 0x04
    32d8:	80 91 34 03 	lds	r24, 0x0334
    32dc:	90 91 35 03 	lds	r25, 0x0335
    32e0:	9c 01       	movw	r18, r24
    32e2:	24 5f       	subi	r18, 0xF4	; 244
    32e4:	3f 4f       	sbci	r19, 0xFF	; 255
    32e6:	ca 01       	movw	r24, r20
    32e8:	b9 01       	movw	r22, r18
    32ea:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    32ee:	80 91 34 03 	lds	r24, 0x0334
    32f2:	90 91 35 03 	lds	r25, 0x0335
    32f6:	02 96       	adiw	r24, 0x02	; 2
    32f8:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    32fc:	20 91 38 03 	lds	r18, 0x0338
    3300:	30 91 39 03 	lds	r19, 0x0339
    3304:	8d 81       	ldd	r24, Y+5	; 0x05
    3306:	9e 81       	ldd	r25, Y+6	; 0x06
    3308:	82 0f       	add	r24, r18
    330a:	93 1f       	adc	r25, r19
    330c:	9a 83       	std	Y+2, r25	; 0x02
    330e:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    3310:	89 81       	ldd	r24, Y+1	; 0x01
    3312:	9a 81       	ldd	r25, Y+2	; 0x02
    3314:	0e 94 59 1b 	call	0x36b2	; 0x36b2 <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    3318:	26 96       	adiw	r28, 0x06	; 6
    331a:	0f b6       	in	r0, 0x3f	; 63
    331c:	f8 94       	cli
    331e:	de bf       	out	0x3e, r29	; 62
    3320:	0f be       	out	0x3f, r0	; 63
    3322:	cd bf       	out	0x3d, r28	; 61
    3324:	cf 91       	pop	r28
    3326:	df 91       	pop	r29
    3328:	08 95       	ret

0000332a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    332a:	df 93       	push	r29
    332c:	cf 93       	push	r28
    332e:	00 d0       	rcall	.+0      	; 0x3330 <xTaskRemoveFromEventList+0x6>
    3330:	00 d0       	rcall	.+0      	; 0x3332 <xTaskRemoveFromEventList+0x8>
    3332:	0f 92       	push	r0
    3334:	cd b7       	in	r28, 0x3d	; 61
    3336:	de b7       	in	r29, 0x3e	; 62
    3338:	9d 83       	std	Y+5, r25	; 0x05
    333a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    333c:	ec 81       	ldd	r30, Y+4	; 0x04
    333e:	fd 81       	ldd	r31, Y+5	; 0x05
    3340:	05 80       	ldd	r0, Z+5	; 0x05
    3342:	f6 81       	ldd	r31, Z+6	; 0x06
    3344:	e0 2d       	mov	r30, r0
    3346:	86 81       	ldd	r24, Z+6	; 0x06
    3348:	97 81       	ldd	r25, Z+7	; 0x07
    334a:	9b 83       	std	Y+3, r25	; 0x03
    334c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    334e:	8a 81       	ldd	r24, Y+2	; 0x02
    3350:	9b 81       	ldd	r25, Y+3	; 0x03
    3352:	0c 96       	adiw	r24, 0x0c	; 12
    3354:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3358:	80 91 3d 03 	lds	r24, 0x033D
    335c:	88 23       	and	r24, r24
    335e:	61 f5       	brne	.+88     	; 0x33b8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3360:	8a 81       	ldd	r24, Y+2	; 0x02
    3362:	9b 81       	ldd	r25, Y+3	; 0x03
    3364:	02 96       	adiw	r24, 0x02	; 2
    3366:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    336a:	ea 81       	ldd	r30, Y+2	; 0x02
    336c:	fb 81       	ldd	r31, Y+3	; 0x03
    336e:	96 89       	ldd	r25, Z+22	; 0x16
    3370:	80 91 3b 03 	lds	r24, 0x033B
    3374:	89 17       	cp	r24, r25
    3376:	28 f4       	brcc	.+10     	; 0x3382 <xTaskRemoveFromEventList+0x58>
    3378:	ea 81       	ldd	r30, Y+2	; 0x02
    337a:	fb 81       	ldd	r31, Y+3	; 0x03
    337c:	86 89       	ldd	r24, Z+22	; 0x16
    337e:	80 93 3b 03 	sts	0x033B, r24
    3382:	ea 81       	ldd	r30, Y+2	; 0x02
    3384:	fb 81       	ldd	r31, Y+3	; 0x03
    3386:	86 89       	ldd	r24, Z+22	; 0x16
    3388:	28 2f       	mov	r18, r24
    338a:	30 e0       	ldi	r19, 0x00	; 0
    338c:	c9 01       	movw	r24, r18
    338e:	88 0f       	add	r24, r24
    3390:	99 1f       	adc	r25, r25
    3392:	88 0f       	add	r24, r24
    3394:	99 1f       	adc	r25, r25
    3396:	88 0f       	add	r24, r24
    3398:	99 1f       	adc	r25, r25
    339a:	82 0f       	add	r24, r18
    339c:	93 1f       	adc	r25, r19
    339e:	ac 01       	movw	r20, r24
    33a0:	4e 5b       	subi	r20, 0xBE	; 190
    33a2:	5c 4f       	sbci	r21, 0xFC	; 252
    33a4:	8a 81       	ldd	r24, Y+2	; 0x02
    33a6:	9b 81       	ldd	r25, Y+3	; 0x03
    33a8:	9c 01       	movw	r18, r24
    33aa:	2e 5f       	subi	r18, 0xFE	; 254
    33ac:	3f 4f       	sbci	r19, 0xFF	; 255
    33ae:	ca 01       	movw	r24, r20
    33b0:	b9 01       	movw	r22, r18
    33b2:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>
    33b6:	0a c0       	rjmp	.+20     	; 0x33cc <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    33b8:	8a 81       	ldd	r24, Y+2	; 0x02
    33ba:	9b 81       	ldd	r25, Y+3	; 0x03
    33bc:	9c 01       	movw	r18, r24
    33be:	24 5f       	subi	r18, 0xF4	; 244
    33c0:	3f 4f       	sbci	r19, 0xFF	; 255
    33c2:	83 e7       	ldi	r24, 0x73	; 115
    33c4:	93 e0       	ldi	r25, 0x03	; 3
    33c6:	b9 01       	movw	r22, r18
    33c8:	0e 94 c9 0c 	call	0x1992	; 0x1992 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    33cc:	ea 81       	ldd	r30, Y+2	; 0x02
    33ce:	fb 81       	ldd	r31, Y+3	; 0x03
    33d0:	96 89       	ldd	r25, Z+22	; 0x16
    33d2:	e0 91 34 03 	lds	r30, 0x0334
    33d6:	f0 91 35 03 	lds	r31, 0x0335
    33da:	86 89       	ldd	r24, Z+22	; 0x16
    33dc:	98 17       	cp	r25, r24
    33de:	18 f0       	brcs	.+6      	; 0x33e6 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    33e0:	81 e0       	ldi	r24, 0x01	; 1
    33e2:	89 83       	std	Y+1, r24	; 0x01
    33e4:	01 c0       	rjmp	.+2      	; 0x33e8 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    33e6:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    33e8:	89 81       	ldd	r24, Y+1	; 0x01
}
    33ea:	0f 90       	pop	r0
    33ec:	0f 90       	pop	r0
    33ee:	0f 90       	pop	r0
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	cf 91       	pop	r28
    33f6:	df 91       	pop	r29
    33f8:	08 95       	ret

000033fa <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    33fa:	df 93       	push	r29
    33fc:	cf 93       	push	r28
    33fe:	00 d0       	rcall	.+0      	; 0x3400 <vTaskSetTimeOutState+0x6>
    3400:	cd b7       	in	r28, 0x3d	; 61
    3402:	de b7       	in	r29, 0x3e	; 62
    3404:	9a 83       	std	Y+2, r25	; 0x02
    3406:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3408:	80 91 40 03 	lds	r24, 0x0340
    340c:	e9 81       	ldd	r30, Y+1	; 0x01
    340e:	fa 81       	ldd	r31, Y+2	; 0x02
    3410:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3412:	80 91 38 03 	lds	r24, 0x0338
    3416:	90 91 39 03 	lds	r25, 0x0339
    341a:	e9 81       	ldd	r30, Y+1	; 0x01
    341c:	fa 81       	ldd	r31, Y+2	; 0x02
    341e:	92 83       	std	Z+2, r25	; 0x02
    3420:	81 83       	std	Z+1, r24	; 0x01
}
    3422:	0f 90       	pop	r0
    3424:	0f 90       	pop	r0
    3426:	cf 91       	pop	r28
    3428:	df 91       	pop	r29
    342a:	08 95       	ret

0000342c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    342c:	df 93       	push	r29
    342e:	cf 93       	push	r28
    3430:	00 d0       	rcall	.+0      	; 0x3432 <xTaskCheckForTimeOut+0x6>
    3432:	00 d0       	rcall	.+0      	; 0x3434 <xTaskCheckForTimeOut+0x8>
    3434:	0f 92       	push	r0
    3436:	cd b7       	in	r28, 0x3d	; 61
    3438:	de b7       	in	r29, 0x3e	; 62
    343a:	9b 83       	std	Y+3, r25	; 0x03
    343c:	8a 83       	std	Y+2, r24	; 0x02
    343e:	7d 83       	std	Y+5, r23	; 0x05
    3440:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3442:	0f b6       	in	r0, 0x3f	; 63
    3444:	f8 94       	cli
    3446:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    3448:	ea 81       	ldd	r30, Y+2	; 0x02
    344a:	fb 81       	ldd	r31, Y+3	; 0x03
    344c:	90 81       	ld	r25, Z
    344e:	80 91 40 03 	lds	r24, 0x0340
    3452:	98 17       	cp	r25, r24
    3454:	71 f0       	breq	.+28     	; 0x3472 <xTaskCheckForTimeOut+0x46>
    3456:	ea 81       	ldd	r30, Y+2	; 0x02
    3458:	fb 81       	ldd	r31, Y+3	; 0x03
    345a:	21 81       	ldd	r18, Z+1	; 0x01
    345c:	32 81       	ldd	r19, Z+2	; 0x02
    345e:	80 91 38 03 	lds	r24, 0x0338
    3462:	90 91 39 03 	lds	r25, 0x0339
    3466:	82 17       	cp	r24, r18
    3468:	93 07       	cpc	r25, r19
    346a:	18 f0       	brcs	.+6      	; 0x3472 <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    346c:	81 e0       	ldi	r24, 0x01	; 1
    346e:	89 83       	std	Y+1, r24	; 0x01
    3470:	2f c0       	rjmp	.+94     	; 0x34d0 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3472:	20 91 38 03 	lds	r18, 0x0338
    3476:	30 91 39 03 	lds	r19, 0x0339
    347a:	ea 81       	ldd	r30, Y+2	; 0x02
    347c:	fb 81       	ldd	r31, Y+3	; 0x03
    347e:	81 81       	ldd	r24, Z+1	; 0x01
    3480:	92 81       	ldd	r25, Z+2	; 0x02
    3482:	28 1b       	sub	r18, r24
    3484:	39 0b       	sbc	r19, r25
    3486:	ec 81       	ldd	r30, Y+4	; 0x04
    3488:	fd 81       	ldd	r31, Y+5	; 0x05
    348a:	80 81       	ld	r24, Z
    348c:	91 81       	ldd	r25, Z+1	; 0x01
    348e:	28 17       	cp	r18, r24
    3490:	39 07       	cpc	r19, r25
    3492:	e0 f4       	brcc	.+56     	; 0x34cc <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    3494:	ec 81       	ldd	r30, Y+4	; 0x04
    3496:	fd 81       	ldd	r31, Y+5	; 0x05
    3498:	40 81       	ld	r20, Z
    349a:	51 81       	ldd	r21, Z+1	; 0x01
    349c:	ea 81       	ldd	r30, Y+2	; 0x02
    349e:	fb 81       	ldd	r31, Y+3	; 0x03
    34a0:	21 81       	ldd	r18, Z+1	; 0x01
    34a2:	32 81       	ldd	r19, Z+2	; 0x02
    34a4:	80 91 38 03 	lds	r24, 0x0338
    34a8:	90 91 39 03 	lds	r25, 0x0339
    34ac:	b9 01       	movw	r22, r18
    34ae:	68 1b       	sub	r22, r24
    34b0:	79 0b       	sbc	r23, r25
    34b2:	cb 01       	movw	r24, r22
    34b4:	84 0f       	add	r24, r20
    34b6:	95 1f       	adc	r25, r21
    34b8:	ec 81       	ldd	r30, Y+4	; 0x04
    34ba:	fd 81       	ldd	r31, Y+5	; 0x05
    34bc:	91 83       	std	Z+1, r25	; 0x01
    34be:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    34c0:	8a 81       	ldd	r24, Y+2	; 0x02
    34c2:	9b 81       	ldd	r25, Y+3	; 0x03
    34c4:	0e 94 fd 19 	call	0x33fa	; 0x33fa <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    34c8:	19 82       	std	Y+1, r1	; 0x01
    34ca:	02 c0       	rjmp	.+4      	; 0x34d0 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    34cc:	81 e0       	ldi	r24, 0x01	; 1
    34ce:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    34d0:	0f 90       	pop	r0
    34d2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    34d4:	89 81       	ldd	r24, Y+1	; 0x01
}
    34d6:	0f 90       	pop	r0
    34d8:	0f 90       	pop	r0
    34da:	0f 90       	pop	r0
    34dc:	0f 90       	pop	r0
    34de:	0f 90       	pop	r0
    34e0:	cf 91       	pop	r28
    34e2:	df 91       	pop	r29
    34e4:	08 95       	ret

000034e6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    34e6:	df 93       	push	r29
    34e8:	cf 93       	push	r28
    34ea:	cd b7       	in	r28, 0x3d	; 61
    34ec:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    34ee:	81 e0       	ldi	r24, 0x01	; 1
    34f0:	80 93 3f 03 	sts	0x033F, r24
}
    34f4:	cf 91       	pop	r28
    34f6:	df 91       	pop	r29
    34f8:	08 95       	ret

000034fa <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    34fa:	df 93       	push	r29
    34fc:	cf 93       	push	r28
    34fe:	00 d0       	rcall	.+0      	; 0x3500 <prvIdleTask+0x6>
    3500:	cd b7       	in	r28, 0x3d	; 61
    3502:	de b7       	in	r29, 0x3e	; 62
    3504:	9a 83       	std	Y+2, r25	; 0x02
    3506:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    3508:	0e 94 1b 1b 	call	0x3636	; 0x3636 <prvCheckTasksWaitingTermination>
    350c:	fd cf       	rjmp	.-6      	; 0x3508 <prvIdleTask+0xe>

0000350e <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    350e:	0f 93       	push	r16
    3510:	1f 93       	push	r17
    3512:	df 93       	push	r29
    3514:	cf 93       	push	r28
    3516:	cd b7       	in	r28, 0x3d	; 61
    3518:	de b7       	in	r29, 0x3e	; 62
    351a:	29 97       	sbiw	r28, 0x09	; 9
    351c:	0f b6       	in	r0, 0x3f	; 63
    351e:	f8 94       	cli
    3520:	de bf       	out	0x3e, r29	; 62
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	cd bf       	out	0x3d, r28	; 61
    3526:	9a 83       	std	Y+2, r25	; 0x02
    3528:	89 83       	std	Y+1, r24	; 0x01
    352a:	7c 83       	std	Y+4, r23	; 0x04
    352c:	6b 83       	std	Y+3, r22	; 0x03
    352e:	4d 83       	std	Y+5, r20	; 0x05
    3530:	3f 83       	std	Y+7, r19	; 0x07
    3532:	2e 83       	std	Y+6, r18	; 0x06
    3534:	19 87       	std	Y+9, r17	; 0x09
    3536:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3538:	89 81       	ldd	r24, Y+1	; 0x01
    353a:	9a 81       	ldd	r25, Y+2	; 0x02
    353c:	49 96       	adiw	r24, 0x19	; 25
    353e:	2b 81       	ldd	r18, Y+3	; 0x03
    3540:	3c 81       	ldd	r19, Y+4	; 0x04
    3542:	b9 01       	movw	r22, r18
    3544:	48 e0       	ldi	r20, 0x08	; 8
    3546:	50 e0       	ldi	r21, 0x00	; 0
    3548:	0e 94 76 1c 	call	0x38ec	; 0x38ec <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    354c:	e9 81       	ldd	r30, Y+1	; 0x01
    354e:	fa 81       	ldd	r31, Y+2	; 0x02
    3550:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    3552:	8d 81       	ldd	r24, Y+5	; 0x05
    3554:	83 30       	cpi	r24, 0x03	; 3
    3556:	10 f0       	brcs	.+4      	; 0x355c <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    3558:	82 e0       	ldi	r24, 0x02	; 2
    355a:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    355c:	e9 81       	ldd	r30, Y+1	; 0x01
    355e:	fa 81       	ldd	r31, Y+2	; 0x02
    3560:	8d 81       	ldd	r24, Y+5	; 0x05
    3562:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    3564:	89 81       	ldd	r24, Y+1	; 0x01
    3566:	9a 81       	ldd	r25, Y+2	; 0x02
    3568:	02 96       	adiw	r24, 0x02	; 2
    356a:	0e 94 b9 0c 	call	0x1972	; 0x1972 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    356e:	89 81       	ldd	r24, Y+1	; 0x01
    3570:	9a 81       	ldd	r25, Y+2	; 0x02
    3572:	0c 96       	adiw	r24, 0x0c	; 12
    3574:	0e 94 b9 0c 	call	0x1972	; 0x1972 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    3578:	e9 81       	ldd	r30, Y+1	; 0x01
    357a:	fa 81       	ldd	r31, Y+2	; 0x02
    357c:	89 81       	ldd	r24, Y+1	; 0x01
    357e:	9a 81       	ldd	r25, Y+2	; 0x02
    3580:	91 87       	std	Z+9, r25	; 0x09
    3582:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    3584:	8d 81       	ldd	r24, Y+5	; 0x05
    3586:	28 2f       	mov	r18, r24
    3588:	30 e0       	ldi	r19, 0x00	; 0
    358a:	83 e0       	ldi	r24, 0x03	; 3
    358c:	90 e0       	ldi	r25, 0x00	; 0
    358e:	82 1b       	sub	r24, r18
    3590:	93 0b       	sbc	r25, r19
    3592:	e9 81       	ldd	r30, Y+1	; 0x01
    3594:	fa 81       	ldd	r31, Y+2	; 0x02
    3596:	95 87       	std	Z+13, r25	; 0x0d
    3598:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    359a:	e9 81       	ldd	r30, Y+1	; 0x01
    359c:	fa 81       	ldd	r31, Y+2	; 0x02
    359e:	89 81       	ldd	r24, Y+1	; 0x01
    35a0:	9a 81       	ldd	r25, Y+2	; 0x02
    35a2:	93 8b       	std	Z+19, r25	; 0x13
    35a4:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    35a6:	29 96       	adiw	r28, 0x09	; 9
    35a8:	0f b6       	in	r0, 0x3f	; 63
    35aa:	f8 94       	cli
    35ac:	de bf       	out	0x3e, r29	; 62
    35ae:	0f be       	out	0x3f, r0	; 63
    35b0:	cd bf       	out	0x3d, r28	; 61
    35b2:	cf 91       	pop	r28
    35b4:	df 91       	pop	r29
    35b6:	1f 91       	pop	r17
    35b8:	0f 91       	pop	r16
    35ba:	08 95       	ret

000035bc <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    35bc:	df 93       	push	r29
    35be:	cf 93       	push	r28
    35c0:	0f 92       	push	r0
    35c2:	cd b7       	in	r28, 0x3d	; 61
    35c4:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    35c6:	19 82       	std	Y+1, r1	; 0x01
    35c8:	13 c0       	rjmp	.+38     	; 0x35f0 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    35ca:	89 81       	ldd	r24, Y+1	; 0x01
    35cc:	28 2f       	mov	r18, r24
    35ce:	30 e0       	ldi	r19, 0x00	; 0
    35d0:	c9 01       	movw	r24, r18
    35d2:	88 0f       	add	r24, r24
    35d4:	99 1f       	adc	r25, r25
    35d6:	88 0f       	add	r24, r24
    35d8:	99 1f       	adc	r25, r25
    35da:	88 0f       	add	r24, r24
    35dc:	99 1f       	adc	r25, r25
    35de:	82 0f       	add	r24, r18
    35e0:	93 1f       	adc	r25, r19
    35e2:	8e 5b       	subi	r24, 0xBE	; 190
    35e4:	9c 4f       	sbci	r25, 0xFC	; 252
    35e6:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    35ea:	89 81       	ldd	r24, Y+1	; 0x01
    35ec:	8f 5f       	subi	r24, 0xFF	; 255
    35ee:	89 83       	std	Y+1, r24	; 0x01
    35f0:	89 81       	ldd	r24, Y+1	; 0x01
    35f2:	83 30       	cpi	r24, 0x03	; 3
    35f4:	50 f3       	brcs	.-44     	; 0x35ca <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    35f6:	8d e5       	ldi	r24, 0x5D	; 93
    35f8:	93 e0       	ldi	r25, 0x03	; 3
    35fa:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    35fe:	86 e6       	ldi	r24, 0x66	; 102
    3600:	93 e0       	ldi	r25, 0x03	; 3
    3602:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    3606:	83 e7       	ldi	r24, 0x73	; 115
    3608:	93 e0       	ldi	r25, 0x03	; 3
    360a:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    360e:	8c e7       	ldi	r24, 0x7C	; 124
    3610:	93 e0       	ldi	r25, 0x03	; 3
    3612:	0e 94 8f 0c 	call	0x191e	; 0x191e <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3616:	8d e5       	ldi	r24, 0x5D	; 93
    3618:	93 e0       	ldi	r25, 0x03	; 3
    361a:	90 93 70 03 	sts	0x0370, r25
    361e:	80 93 6f 03 	sts	0x036F, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3622:	86 e6       	ldi	r24, 0x66	; 102
    3624:	93 e0       	ldi	r25, 0x03	; 3
    3626:	90 93 72 03 	sts	0x0372, r25
    362a:	80 93 71 03 	sts	0x0371, r24
}
    362e:	0f 90       	pop	r0
    3630:	cf 91       	pop	r28
    3632:	df 91       	pop	r29
    3634:	08 95       	ret

00003636 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3636:	df 93       	push	r29
    3638:	cf 93       	push	r28
    363a:	00 d0       	rcall	.+0      	; 0x363c <prvCheckTasksWaitingTermination+0x6>
    363c:	0f 92       	push	r0
    363e:	cd b7       	in	r28, 0x3d	; 61
    3640:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    3642:	80 91 36 03 	lds	r24, 0x0336
    3646:	88 23       	and	r24, r24
    3648:	71 f1       	breq	.+92     	; 0x36a6 <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    364a:	0e 94 59 17 	call	0x2eb2	; 0x2eb2 <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    364e:	80 91 7c 03 	lds	r24, 0x037C
    3652:	1b 82       	std	Y+3, r1	; 0x03
    3654:	88 23       	and	r24, r24
    3656:	11 f4       	brne	.+4      	; 0x365c <prvCheckTasksWaitingTermination+0x26>
    3658:	81 e0       	ldi	r24, 0x01	; 1
    365a:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    365c:	0e 94 65 17 	call	0x2eca	; 0x2eca <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    3660:	8b 81       	ldd	r24, Y+3	; 0x03
    3662:	88 23       	and	r24, r24
    3664:	01 f5       	brne	.+64     	; 0x36a6 <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    366c:	e0 91 81 03 	lds	r30, 0x0381
    3670:	f0 91 82 03 	lds	r31, 0x0382
    3674:	86 81       	ldd	r24, Z+6	; 0x06
    3676:	97 81       	ldd	r25, Z+7	; 0x07
    3678:	9a 83       	std	Y+2, r25	; 0x02
    367a:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    367c:	89 81       	ldd	r24, Y+1	; 0x01
    367e:	9a 81       	ldd	r25, Y+2	; 0x02
    3680:	02 96       	adiw	r24, 0x02	; 2
    3682:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <vListRemove>
					--uxCurrentNumberOfTasks;
    3686:	80 91 37 03 	lds	r24, 0x0337
    368a:	81 50       	subi	r24, 0x01	; 1
    368c:	80 93 37 03 	sts	0x0337, r24
					--uxTasksDeleted;
    3690:	80 91 36 03 	lds	r24, 0x0336
    3694:	81 50       	subi	r24, 0x01	; 1
    3696:	80 93 36 03 	sts	0x0336, r24
				}
				taskEXIT_CRITICAL();
    369a:	0f 90       	pop	r0
    369c:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    369e:	89 81       	ldd	r24, Y+1	; 0x01
    36a0:	9a 81       	ldd	r25, Y+2	; 0x02
    36a2:	0e 94 f2 1b 	call	0x37e4	; 0x37e4 <prvDeleteTCB>
			}
		}
	}
	#endif
}
    36a6:	0f 90       	pop	r0
    36a8:	0f 90       	pop	r0
    36aa:	0f 90       	pop	r0
    36ac:	cf 91       	pop	r28
    36ae:	df 91       	pop	r29
    36b0:	08 95       	ret

000036b2 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    36b2:	df 93       	push	r29
    36b4:	cf 93       	push	r28
    36b6:	00 d0       	rcall	.+0      	; 0x36b8 <prvAddCurrentTaskToDelayedList+0x6>
    36b8:	cd b7       	in	r28, 0x3d	; 61
    36ba:	de b7       	in	r29, 0x3e	; 62
    36bc:	9a 83       	std	Y+2, r25	; 0x02
    36be:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    36c0:	e0 91 34 03 	lds	r30, 0x0334
    36c4:	f0 91 35 03 	lds	r31, 0x0335
    36c8:	89 81       	ldd	r24, Y+1	; 0x01
    36ca:	9a 81       	ldd	r25, Y+2	; 0x02
    36cc:	93 83       	std	Z+3, r25	; 0x03
    36ce:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    36d0:	20 91 38 03 	lds	r18, 0x0338
    36d4:	30 91 39 03 	lds	r19, 0x0339
    36d8:	89 81       	ldd	r24, Y+1	; 0x01
    36da:	9a 81       	ldd	r25, Y+2	; 0x02
    36dc:	82 17       	cp	r24, r18
    36de:	93 07       	cpc	r25, r19
    36e0:	70 f4       	brcc	.+28     	; 0x36fe <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36e2:	80 91 71 03 	lds	r24, 0x0371
    36e6:	90 91 72 03 	lds	r25, 0x0372
    36ea:	20 91 34 03 	lds	r18, 0x0334
    36ee:	30 91 35 03 	lds	r19, 0x0335
    36f2:	2e 5f       	subi	r18, 0xFE	; 254
    36f4:	3f 4f       	sbci	r19, 0xFF	; 255
    36f6:	b9 01       	movw	r22, r18
    36f8:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>
    36fc:	1e c0       	rjmp	.+60     	; 0x373a <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36fe:	40 91 6f 03 	lds	r20, 0x036F
    3702:	50 91 70 03 	lds	r21, 0x0370
    3706:	80 91 34 03 	lds	r24, 0x0334
    370a:	90 91 35 03 	lds	r25, 0x0335
    370e:	9c 01       	movw	r18, r24
    3710:	2e 5f       	subi	r18, 0xFE	; 254
    3712:	3f 4f       	sbci	r19, 0xFF	; 255
    3714:	ca 01       	movw	r24, r20
    3716:	b9 01       	movw	r22, r18
    3718:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    371c:	20 91 9d 00 	lds	r18, 0x009D
    3720:	30 91 9e 00 	lds	r19, 0x009E
    3724:	89 81       	ldd	r24, Y+1	; 0x01
    3726:	9a 81       	ldd	r25, Y+2	; 0x02
    3728:	82 17       	cp	r24, r18
    372a:	93 07       	cpc	r25, r19
    372c:	30 f4       	brcc	.+12     	; 0x373a <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    372e:	89 81       	ldd	r24, Y+1	; 0x01
    3730:	9a 81       	ldd	r25, Y+2	; 0x02
    3732:	90 93 9e 00 	sts	0x009E, r25
    3736:	80 93 9d 00 	sts	0x009D, r24
		}
	}
}
    373a:	0f 90       	pop	r0
    373c:	0f 90       	pop	r0
    373e:	cf 91       	pop	r28
    3740:	df 91       	pop	r29
    3742:	08 95       	ret

00003744 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    3744:	df 93       	push	r29
    3746:	cf 93       	push	r28
    3748:	cd b7       	in	r28, 0x3d	; 61
    374a:	de b7       	in	r29, 0x3e	; 62
    374c:	28 97       	sbiw	r28, 0x08	; 8
    374e:	0f b6       	in	r0, 0x3f	; 63
    3750:	f8 94       	cli
    3752:	de bf       	out	0x3e, r29	; 62
    3754:	0f be       	out	0x3f, r0	; 63
    3756:	cd bf       	out	0x3d, r28	; 61
    3758:	9c 83       	std	Y+4, r25	; 0x04
    375a:	8b 83       	std	Y+3, r24	; 0x03
    375c:	7e 83       	std	Y+6, r23	; 0x06
    375e:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    3760:	81 e2       	ldi	r24, 0x21	; 33
    3762:	90 e0       	ldi	r25, 0x00	; 0
    3764:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <pvPortMalloc>
    3768:	9a 83       	std	Y+2, r25	; 0x02
    376a:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    376c:	89 81       	ldd	r24, Y+1	; 0x01
    376e:	9a 81       	ldd	r25, Y+2	; 0x02
    3770:	00 97       	sbiw	r24, 0x00	; 0
    3772:	69 f1       	breq	.+90     	; 0x37ce <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    3774:	8d 81       	ldd	r24, Y+5	; 0x05
    3776:	9e 81       	ldd	r25, Y+6	; 0x06
    3778:	00 97       	sbiw	r24, 0x00	; 0
    377a:	39 f4       	brne	.+14     	; 0x378a <prvAllocateTCBAndStack+0x46>
    377c:	8b 81       	ldd	r24, Y+3	; 0x03
    377e:	9c 81       	ldd	r25, Y+4	; 0x04
    3780:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <pvPortMalloc>
    3784:	98 87       	std	Y+8, r25	; 0x08
    3786:	8f 83       	std	Y+7, r24	; 0x07
    3788:	04 c0       	rjmp	.+8      	; 0x3792 <prvAllocateTCBAndStack+0x4e>
    378a:	8d 81       	ldd	r24, Y+5	; 0x05
    378c:	9e 81       	ldd	r25, Y+6	; 0x06
    378e:	98 87       	std	Y+8, r25	; 0x08
    3790:	8f 83       	std	Y+7, r24	; 0x07
    3792:	e9 81       	ldd	r30, Y+1	; 0x01
    3794:	fa 81       	ldd	r31, Y+2	; 0x02
    3796:	8f 81       	ldd	r24, Y+7	; 0x07
    3798:	98 85       	ldd	r25, Y+8	; 0x08
    379a:	90 8f       	std	Z+24, r25	; 0x18
    379c:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    379e:	e9 81       	ldd	r30, Y+1	; 0x01
    37a0:	fa 81       	ldd	r31, Y+2	; 0x02
    37a2:	87 89       	ldd	r24, Z+23	; 0x17
    37a4:	90 8d       	ldd	r25, Z+24	; 0x18
    37a6:	00 97       	sbiw	r24, 0x00	; 0
    37a8:	39 f4       	brne	.+14     	; 0x37b8 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    37aa:	89 81       	ldd	r24, Y+1	; 0x01
    37ac:	9a 81       	ldd	r25, Y+2	; 0x02
    37ae:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
			pxNewTCB = NULL;
    37b2:	1a 82       	std	Y+2, r1	; 0x02
    37b4:	19 82       	std	Y+1, r1	; 0x01
    37b6:	0b c0       	rjmp	.+22     	; 0x37ce <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    37b8:	e9 81       	ldd	r30, Y+1	; 0x01
    37ba:	fa 81       	ldd	r31, Y+2	; 0x02
    37bc:	87 89       	ldd	r24, Z+23	; 0x17
    37be:	90 8d       	ldd	r25, Z+24	; 0x18
    37c0:	2b 81       	ldd	r18, Y+3	; 0x03
    37c2:	3c 81       	ldd	r19, Y+4	; 0x04
    37c4:	65 ea       	ldi	r22, 0xA5	; 165
    37c6:	70 e0       	ldi	r23, 0x00	; 0
    37c8:	a9 01       	movw	r20, r18
    37ca:	0e 94 6f 1c 	call	0x38de	; 0x38de <memset>
		}
	}

	return pxNewTCB;
    37ce:	89 81       	ldd	r24, Y+1	; 0x01
    37d0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    37d2:	28 96       	adiw	r28, 0x08	; 8
    37d4:	0f b6       	in	r0, 0x3f	; 63
    37d6:	f8 94       	cli
    37d8:	de bf       	out	0x3e, r29	; 62
    37da:	0f be       	out	0x3f, r0	; 63
    37dc:	cd bf       	out	0x3d, r28	; 61
    37de:	cf 91       	pop	r28
    37e0:	df 91       	pop	r29
    37e2:	08 95       	ret

000037e4 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    37e4:	df 93       	push	r29
    37e6:	cf 93       	push	r28
    37e8:	00 d0       	rcall	.+0      	; 0x37ea <prvDeleteTCB+0x6>
    37ea:	cd b7       	in	r28, 0x3d	; 61
    37ec:	de b7       	in	r29, 0x3e	; 62
    37ee:	9a 83       	std	Y+2, r25	; 0x02
    37f0:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    37f2:	e9 81       	ldd	r30, Y+1	; 0x01
    37f4:	fa 81       	ldd	r31, Y+2	; 0x02
    37f6:	87 89       	ldd	r24, Z+23	; 0x17
    37f8:	90 8d       	ldd	r25, Z+24	; 0x18
    37fa:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
		vPortFree( pxTCB );
    37fe:	89 81       	ldd	r24, Y+1	; 0x01
    3800:	9a 81       	ldd	r25, Y+2	; 0x02
    3802:	0e 94 32 0a 	call	0x1464	; 0x1464 <vPortFree>
	}
    3806:	0f 90       	pop	r0
    3808:	0f 90       	pop	r0
    380a:	cf 91       	pop	r28
    380c:	df 91       	pop	r29
    380e:	08 95       	ret

00003810 <__divmodhi4>:
    3810:	97 fb       	bst	r25, 7
    3812:	09 2e       	mov	r0, r25
    3814:	07 26       	eor	r0, r23
    3816:	0a d0       	rcall	.+20     	; 0x382c <__divmodhi4_neg1>
    3818:	77 fd       	sbrc	r23, 7
    381a:	04 d0       	rcall	.+8      	; 0x3824 <__divmodhi4_neg2>
    381c:	0c d0       	rcall	.+24     	; 0x3836 <__udivmodhi4>
    381e:	06 d0       	rcall	.+12     	; 0x382c <__divmodhi4_neg1>
    3820:	00 20       	and	r0, r0
    3822:	1a f4       	brpl	.+6      	; 0x382a <__divmodhi4_exit>

00003824 <__divmodhi4_neg2>:
    3824:	70 95       	com	r23
    3826:	61 95       	neg	r22
    3828:	7f 4f       	sbci	r23, 0xFF	; 255

0000382a <__divmodhi4_exit>:
    382a:	08 95       	ret

0000382c <__divmodhi4_neg1>:
    382c:	f6 f7       	brtc	.-4      	; 0x382a <__divmodhi4_exit>
    382e:	90 95       	com	r25
    3830:	81 95       	neg	r24
    3832:	9f 4f       	sbci	r25, 0xFF	; 255
    3834:	08 95       	ret

00003836 <__udivmodhi4>:
    3836:	aa 1b       	sub	r26, r26
    3838:	bb 1b       	sub	r27, r27
    383a:	51 e1       	ldi	r21, 0x11	; 17
    383c:	07 c0       	rjmp	.+14     	; 0x384c <__udivmodhi4_ep>

0000383e <__udivmodhi4_loop>:
    383e:	aa 1f       	adc	r26, r26
    3840:	bb 1f       	adc	r27, r27
    3842:	a6 17       	cp	r26, r22
    3844:	b7 07       	cpc	r27, r23
    3846:	10 f0       	brcs	.+4      	; 0x384c <__udivmodhi4_ep>
    3848:	a6 1b       	sub	r26, r22
    384a:	b7 0b       	sbc	r27, r23

0000384c <__udivmodhi4_ep>:
    384c:	88 1f       	adc	r24, r24
    384e:	99 1f       	adc	r25, r25
    3850:	5a 95       	dec	r21
    3852:	a9 f7       	brne	.-22     	; 0x383e <__udivmodhi4_loop>
    3854:	80 95       	com	r24
    3856:	90 95       	com	r25
    3858:	bc 01       	movw	r22, r24
    385a:	cd 01       	movw	r24, r26
    385c:	08 95       	ret

0000385e <__prologue_saves__>:
    385e:	2f 92       	push	r2
    3860:	3f 92       	push	r3
    3862:	4f 92       	push	r4
    3864:	5f 92       	push	r5
    3866:	6f 92       	push	r6
    3868:	7f 92       	push	r7
    386a:	8f 92       	push	r8
    386c:	9f 92       	push	r9
    386e:	af 92       	push	r10
    3870:	bf 92       	push	r11
    3872:	cf 92       	push	r12
    3874:	df 92       	push	r13
    3876:	ef 92       	push	r14
    3878:	ff 92       	push	r15
    387a:	0f 93       	push	r16
    387c:	1f 93       	push	r17
    387e:	cf 93       	push	r28
    3880:	df 93       	push	r29
    3882:	cd b7       	in	r28, 0x3d	; 61
    3884:	de b7       	in	r29, 0x3e	; 62
    3886:	ca 1b       	sub	r28, r26
    3888:	db 0b       	sbc	r29, r27
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	de bf       	out	0x3e, r29	; 62
    3890:	0f be       	out	0x3f, r0	; 63
    3892:	cd bf       	out	0x3d, r28	; 61
    3894:	09 94       	ijmp

00003896 <__epilogue_restores__>:
    3896:	2a 88       	ldd	r2, Y+18	; 0x12
    3898:	39 88       	ldd	r3, Y+17	; 0x11
    389a:	48 88       	ldd	r4, Y+16	; 0x10
    389c:	5f 84       	ldd	r5, Y+15	; 0x0f
    389e:	6e 84       	ldd	r6, Y+14	; 0x0e
    38a0:	7d 84       	ldd	r7, Y+13	; 0x0d
    38a2:	8c 84       	ldd	r8, Y+12	; 0x0c
    38a4:	9b 84       	ldd	r9, Y+11	; 0x0b
    38a6:	aa 84       	ldd	r10, Y+10	; 0x0a
    38a8:	b9 84       	ldd	r11, Y+9	; 0x09
    38aa:	c8 84       	ldd	r12, Y+8	; 0x08
    38ac:	df 80       	ldd	r13, Y+7	; 0x07
    38ae:	ee 80       	ldd	r14, Y+6	; 0x06
    38b0:	fd 80       	ldd	r15, Y+5	; 0x05
    38b2:	0c 81       	ldd	r16, Y+4	; 0x04
    38b4:	1b 81       	ldd	r17, Y+3	; 0x03
    38b6:	aa 81       	ldd	r26, Y+2	; 0x02
    38b8:	b9 81       	ldd	r27, Y+1	; 0x01
    38ba:	ce 0f       	add	r28, r30
    38bc:	d1 1d       	adc	r29, r1
    38be:	0f b6       	in	r0, 0x3f	; 63
    38c0:	f8 94       	cli
    38c2:	de bf       	out	0x3e, r29	; 62
    38c4:	0f be       	out	0x3f, r0	; 63
    38c6:	cd bf       	out	0x3d, r28	; 61
    38c8:	ed 01       	movw	r28, r26
    38ca:	08 95       	ret

000038cc <memcpy>:
    38cc:	fb 01       	movw	r30, r22
    38ce:	dc 01       	movw	r26, r24
    38d0:	02 c0       	rjmp	.+4      	; 0x38d6 <memcpy+0xa>
    38d2:	01 90       	ld	r0, Z+
    38d4:	0d 92       	st	X+, r0
    38d6:	41 50       	subi	r20, 0x01	; 1
    38d8:	50 40       	sbci	r21, 0x00	; 0
    38da:	d8 f7       	brcc	.-10     	; 0x38d2 <memcpy+0x6>
    38dc:	08 95       	ret

000038de <memset>:
    38de:	dc 01       	movw	r26, r24
    38e0:	01 c0       	rjmp	.+2      	; 0x38e4 <memset+0x6>
    38e2:	6d 93       	st	X+, r22
    38e4:	41 50       	subi	r20, 0x01	; 1
    38e6:	50 40       	sbci	r21, 0x00	; 0
    38e8:	e0 f7       	brcc	.-8      	; 0x38e2 <memset+0x4>
    38ea:	08 95       	ret

000038ec <strncpy>:
    38ec:	fb 01       	movw	r30, r22
    38ee:	dc 01       	movw	r26, r24
    38f0:	41 50       	subi	r20, 0x01	; 1
    38f2:	50 40       	sbci	r21, 0x00	; 0
    38f4:	48 f0       	brcs	.+18     	; 0x3908 <strncpy+0x1c>
    38f6:	01 90       	ld	r0, Z+
    38f8:	0d 92       	st	X+, r0
    38fa:	00 20       	and	r0, r0
    38fc:	c9 f7       	brne	.-14     	; 0x38f0 <strncpy+0x4>
    38fe:	01 c0       	rjmp	.+2      	; 0x3902 <strncpy+0x16>
    3900:	1d 92       	st	X+, r1
    3902:	41 50       	subi	r20, 0x01	; 1
    3904:	50 40       	sbci	r21, 0x00	; 0
    3906:	e0 f7       	brcc	.-8      	; 0x3900 <strncpy+0x14>
    3908:	08 95       	ret

0000390a <_exit>:
    390a:	f8 94       	cli

0000390c <__stop_program>:
    390c:	ff cf       	rjmp	.-2      	; 0x390c <__stop_program>
